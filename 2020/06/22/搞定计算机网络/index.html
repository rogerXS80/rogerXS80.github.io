<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="uW8bwgMGUwIA01nPfItoty1rmtmmuVkOVTeS9O0nAUg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="在浏览器中输入一个 URL 至页面呈现，网络上都发生了什么事？能说说 ISO 七层模型和 TCP&#x2F;IP 四层模型吗？CP&#x2F;IP 与 HTTP 有什么关系吗？...">
<meta property="og:type" content="article">
<meta property="og:title" content="[「直击面试」搞定计算机网络]">
<meta property="og:url" content="http://yoursite.com/2020/06/22/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/index.html">
<meta property="og:site_name" content="Lupinus">
<meta property="og:description" content="在浏览器中输入一个 URL 至页面呈现，网络上都发生了什么事？能说说 ISO 七层模型和 TCP&#x2F;IP 四层模型吗？CP&#x2F;IP 与 HTTP 有什么关系吗？...">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bed7719799d.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bed76faefb0.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bed76fa926f.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bed764405fc.jpg">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2020/4/16/17180bed7721f0c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bed772ce689.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9bb2cb0c.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9d208228.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180beda8938bd4.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9f762409.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bedb27f3f29.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bedb8848bf2.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bedbd853fe2.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bede10f9420.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bedc063a776.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bedeeb2c715.jpg">
<meta property="og:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bedf2021893.jpg">
<meta property="article:published_time" content="2020-06-21T23:45:33.000Z">
<meta property="article:modified_time" content="2020-06-21T23:45:34.000Z">
<meta property="article:author" content="Lupinus">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/wjxyzs/img/raw/master/img/17180bed7719799d.jpg">

<link rel="canonical" href="http://yoursite.com/2020/06/22/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>[「直击面试」搞定计算机网络] | Lupinus</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Lupinus" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lupinus</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Re：从零开始的go学习生活(｀・ω・´)</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/rogerXS80" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/06/22/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_devops/20160715144434_fZCsF.jpeg">
      <meta itemprop="name" content="Lupinus">
      <meta itemprop="description" content="Re：从零开始的go学习生活(｀・ω・´)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lupinus">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          [「直击面试」搞定计算机网络]
        </h1>

        <div class="post-meta">
          <!-- 置顶图标 -->
            <span class="post-meta-item">
              
              
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-22 07:45:33 / Modified: 07:45:34" itemprop="dateCreated datePublished" datetime="2020-06-22T07:45:33+08:00">2020-06-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9B%B4%E5%87%BB%E9%9D%A2%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">直击面试</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
            <div class="post-description">在浏览器中输入一个 URL 至页面呈现，网络上都发生了什么事？能说说 ISO 七层模型和 TCP/IP 四层模型吗？CP/IP 与 HTTP 有什么关系吗？...</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>在浏览器中输入一个 URL 至页面呈现，网络上都发生了什么事？</p>
<p>能说说 ISO 七层模型和 TCP/IP 四层模型吗？</p>
<p>TCP/IP 与 HTTP 有什么关系吗？</p>
<p>TCP协议与UDP协议的区别？</p>
<p>请详细介绍一下 TCP 的三次握手机制，为什么要三次握手？挥手却又是四次呢？</p>
<p>详细讲一下TCP的滑动窗口？知道流量控制和拥塞控制吗？</p>
<p>说一下对称加密与非对称加密？</p>
<p>状态码 206 是什么意思？</p>
<p>你们用的 https 是吧，https 工作原理是什么？</p>
<p>……</p>
</blockquote>
<blockquote>
<p>成长手册，<strong>GitHub</strong> <a href="https://github.com/rogerXS80/roger" target="_blank" rel="noopener">Lupinus</a> ，N线互联网开发必备技能兵器谱</p>
</blockquote>
<h2 id="一、计算机网络"><a href="#一、计算机网络" class="headerlink" title="一、计算机网络"></a>一、计算机网络</h2><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>通信协议（communications protocol）是指双方实体完成通信或服务所必须遵循的规则和约定。通过通信信道和设备互连起来的多个不同地理位置的数据通信系统，要使其能协同工作实现信息交换和资源共享，它们之间必须具有共同的语言。交流什么、怎样交流及何时交流，都必须遵循某种互相都能接受的规则。这个规则就是通信协议。</p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>随着技术的发展，计算机的应用越来越广泛，计算机之间的通信开始了百花齐放的状态，每个具有独立计算服务体系的信息技术公司都会建立自己的计算机通信规则，而这种情况会导致异构计算机之间无法通信，极大的阻碍了网络通信的发展，至此为了解决这个问题，国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，OSI模型把网络通信的工作分为7层，分别是<strong>物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</strong>。</p>
<p>这七层模型是设计层面的概念，每一层都有固定要完成的职责和功能，分层的好处在于清晰和功能独立性，但分层过多会使层次变的更加复杂，虽然不需要实现本层的功能，但是也需要构造本层的上下文，空耗系统资源，所以在落地实施网络通信模型的时候将这七层模型简化合并为四层模型分别是<strong>应用层、传输层、网络层、网络接口层</strong>（各层之间的模型、协议统称为：<strong>TCP/IP协议簇</strong>）。</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed7719799d.jpg" alt=""></p>
<p>从上图可以看到，TCP/IP模型合并了OSI模型的应用层、表示层和会话层，将OSI模型的数据链路层和物理层合并为网络访问层。</p>
<p>上图还列出了各层模型对应TCP/IP协议栈中的协议以及各层协议之间的关系。比如DNS协议是建立在TCP和UDP协议的基础上，FTP、HTTP、TELNET协议建立在TCP协议的基础上，NTP、TFTP、SNMP建立在UDP协议的基础上，而TCP、UDP协议又建立在IP协议的基础上，以此类推….</p>
<table>
<thead>
<tr>
<th align="left">OSI中的层</th>
<th>功能</th>
<th align="left">TCP/IP协议族</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>应用层</strong></td>
<td>文件传输，电子邮件，文件服务，虚拟终端</td>
<td align="left">TFTP，HTTP，SNMP，FTP，SMTP，DNS，RIP，Telnet</td>
</tr>
<tr>
<td align="left"><strong>表示层</strong></td>
<td>数据格式化，代码转换，数据加密</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left"><strong>会话层</strong></td>
<td>控制应用程序之间会话能力；如不同软件数据分发给不同软件</td>
<td align="left">ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets</td>
</tr>
<tr>
<td align="left"><strong>传输层</strong></td>
<td>端到端传输数据的基本功能</td>
<td align="left">TCP、UDP</td>
</tr>
<tr>
<td align="left"><strong>网络层</strong></td>
<td>定义IP编址，定义路由功能；如不同设备的数据转发</td>
<td align="left">IP，ICMP，RIP，OSPF，BGP，IGMP</td>
</tr>
<tr>
<td align="left"><strong>数据链路层</strong></td>
<td>定义数据的基本格式，如何传输，如何标识</td>
<td align="left">SLIP，CSLIP，PPP，ARP，RARP，MTU</td>
</tr>
<tr>
<td align="left"><strong>物理层</strong></td>
<td>以<strong>二进制</strong>数据形式在物理媒体上传输数据</td>
<td align="left">ISO2110，IEEE802</td>
</tr>
</tbody></table>
<p>当我们某一个网站上不去的时候。通常会ping一下这个网站</p>
<p><code>ping</code> 可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用<code>ping</code>命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p>
<h2 id="二、TCP-IP"><a href="#二、TCP-IP" class="headerlink" title="二、TCP/IP"></a>二、TCP/IP</h2><p>数据在网络中传输最终一定是通过物理介质传输。物理介质就是把电脑连接起来的物理手段，常见的有光纤、双绞线，以及无线电波，它决定了电信号(0和1)的传输方式，物理介质的不同决定了电信号的传输带宽、速率、传输距离以及抗干扰性等等。网络数据传输就像快递邮寄，数据就是快件。只有路打通了，你的”快递”才能送到，因此物理介质是网络通信的基石。</p>
<p>寄快递首先得称重、确认体积(确认数据大小)，贵重物品还得层层包裹填充物确保安全，封装，然后填写发件地址(源主机地址)和收件地址(目标主机地址)，确认快递方式。对于偏远地区，快递不能直达，还需要中途转发。网络通信也是一样的道理，只不过把这些步骤都规定成了各种协议。</p>
<p>TCP/IP的模型的每一层都需要下一层所提供的协议来完成自己的目的。我们来看下数据是怎么通过TCP/IP协议模型从一台主机发送到另一台主机的。</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed76faefb0.jpg" alt=""></p>
<p>当用户通过HTTP协议发起一个请求，应用层、传输层、网络互联层和网络访问层的相关协议依次对该请求进行包装并携带对应的首部，最终在网络访问层生成以太网数据包，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。</p>
<h3 id="TCP-IP-与-HTTP"><a href="#TCP-IP-与-HTTP" class="headerlink" title="TCP/IP 与 HTTP"></a>TCP/IP 与 HTTP</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP 协议不仅仅指的是 TCP 和 IP 两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。</p>
<p><strong>而HTTP是应用层协议，主要解决如何包装数据。</strong></p>
<p>“IP”代表网际协议，TCP 和 UDP 使用该协议从一个网络传送数据包到另一个网络。把<strong>IP想像成一种高速公路</strong>，它允许其它协议在上面行驶并找到到其它电脑的出口。<strong>TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP</strong>，文件传输协议FTP这样的协议等。</p>
<h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><p>都属于传输层协议。</p>
<p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须有三次握手、四次挥手。</p>
<p>UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">TCP</th>
<th align="left">UDP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">连接性</td>
<td align="left">面向连接</td>
<td align="left">面向非连接</td>
</tr>
<tr>
<td align="left">传输可靠性</td>
<td align="left">可靠</td>
<td align="left">不可靠</td>
</tr>
<tr>
<td align="left">报文</td>
<td align="left">面向字节流</td>
<td align="left">面向报文</td>
</tr>
<tr>
<td align="left">效率</td>
<td align="left">传输效率低</td>
<td align="left">传输效率高</td>
</tr>
<tr>
<td align="left">流量控制</td>
<td align="left">滑动窗口</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">拥塞控制</td>
<td align="left">慢开始、拥塞避免、快重传、快恢复</td>
<td align="left">无</td>
</tr>
<tr>
<td align="left">传输速度</td>
<td align="left">慢</td>
<td align="left">快</td>
</tr>
<tr>
<td align="left">应用场合</td>
<td align="left">对效率要求低，对准确性要求高或要求有连接的场景</td>
<td align="left">对效率要求高，对准确性要求低</td>
</tr>
</tbody></table>
<p>TCP和UDP协议的一些应用</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed76fa926f.jpg" alt=""></p>
<h3 id="TCP连接的建立与终止"><a href="#TCP连接的建立与终止" class="headerlink" title="TCP连接的建立与终止"></a>TCP连接的建立与终止</h3><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能体现在它首部中的各字段的作用。</p>
<p>TCP报文段首部的前20个字节是固定的（下图），后面有4n字节是根据需要而增加的选项（n是整数）。因此TCP首部的最小长度是20字节。</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed764405fc.jpg" alt=""></p>
<h4 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h4><ul>
<li><p>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</p>
</li>
<li><p><strong>序列号</strong>（Sequence number），占4字节。序号范围是【0，2^32 - 1】，共2^32个序号。序号增加到 2^32-1后，下一个序号就又回到 0。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是301，而接待的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”;</p>
</li>
<li><p><strong>确认号</strong>（Acknowledge number），占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</p>
</li>
<li><p>数据偏移，占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。</p>
</li>
<li><p>保留，占6位，保留为今后使用，但目前应置为0；</p>
</li>
<li><p>紧急URG（URGent），当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</p>
</li>
<li><p>确认ACK（ACKnowledgment），仅当ACK=1时，确认号字段才有效。<strong>TCP规定，在连接建立后所有报文的传输都必须把ACK置1</strong>；</p>
</li>
<li><p>推送PSH（PuSH） ，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</p>
</li>
<li><p>复位RST（ReSeT），当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</p>
</li>
<li><p>同步SYN（SYNchronization），在连接建立时用来同步序号。<strong>当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1</strong>；</p>
</li>
<li><p>终止FIN（FINis），用来释放连接。</p>
<p>当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放</p>
<p>；</p>
<ul>
<li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li>
</ul>
</li>
<li><p>检验和，占2字节，校验首部和数据这两部分；</p>
</li>
<li><p>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</p>
</li>
<li><p>选项，长度可变，定义一些其他的可选的参数</p>
</li>
</ul>
<p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p>
<h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p>
<p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/4/16/17180bed7721f0c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li><p><strong>第一次握手</strong>(SYN=1, seq=x)</p>
<p>建立连接。客户端发送连接请求报文段，这是报文首部中的同步位SYN=1，同时选择一个初始序列号 seq=x ，此时，客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号；</p>
</li>
<li><p><strong>第二次握手</strong>(SYN=1, ACK=1, seq=y, ACKnum=x+1)</p>
<p>服务器收到客户端的SYN报文段，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号ACKnum=x+1，同时，自己还要发送SYN请求信息，SYN=1，为自己初始化一个序列号 seq=y，服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号</p>
</li>
<li><p><strong>第三次握手</strong>(ACK=1，ACKnum=y+1)</p>
<p>客户端收到服务器的SYN+ACK报文段，再次发送确认包(ACK)，<strong>SYN 标志位为0</strong>，ACK 标志位为1，确认号 ACKnum = y+1，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED（已建立连接）状态，完成TCP三次握手。</p>
</li>
</ul>
<blockquote>
<p>为什么需要三次握手呢？两次不行吗？</p>
</blockquote>
<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>
<p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。<strong>客户端或服务器均可主动发起挥手动作</strong>。</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed772ce689.jpg" alt=""></p>
<ul>
<li><p>第一次挥手(FIN=1，seq=x)red</p>
<p>主机1（可以使客户端，也可以是服务器端），设置seq=x，向主机2发送一个FIN报文段；此时，主机1进入<font color=red size=4><code>FIN_WAIT_1</code></font>状态；这表示主机1没有数据要发送给主机2了；</p>
</li>
<li><p>第二次挥手(ACK=1，ACKnum=x+1)</p>
<p>主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknnum=x+1，主机1进入<font color=red size=4><code>FIN_WAIT_2</code></font>状态；主机2告诉主机1，我“同意”你的关闭请求；</p>
</li>
<li><p>第三次挥手(FIN=1，seq=y)</p>
<p>主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入<code>LAST_ACK</code> 状态</p>
</li>
<li><p>第四次挥手(ACK=1，ACKnum=y+1)</p>
<p>主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入<font color=red size=4><code>TIME_WAIT</code></font>状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，<strong>主机1等待2MSL后依然没有收到回复</strong>，则证明Server端已正常关闭，那好，主机1也可以关闭连接了，进入 <font color=red size=4><code>CLOSED</code></font> 状态。</p>
<p>主机 1 等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <font color=red size=4><code>CLOSED</code></font>  状态。</p>
</li>
</ul>
<blockquote>
<p>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p>
</blockquote>
<p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p>
<p>由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。</p>
<blockquote>
<p><strong>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p>
</blockquote>
<p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<p>还有一个原因，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h3 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h3><p>对于可靠性，TCP通过以下方式进行保证：</p>
<ul>
<li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li>
<li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li>
<li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li>
<li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li>
<li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li>
<li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li>
</ul>
<blockquote>
<p>详细讲一下TCP的滑动窗口</p>
</blockquote>
<h3 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h3><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓<strong>流量控制</strong>就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9bb2cb0c.jpg" alt=""></p>
<p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p>
<p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方，我们现在假设一个发送方向接收方发送数据的场景来讲解流量控制。首先我们的接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p>
<p>假设应用程序最后读走的数据序号是 lastByteRead，接收缓存中接收到的最后一个数据序号是 lastByteRcv，接收缓存的大小为 RcvSize，那么必须要满足 lastByteRcv - lastByteRead &lt;= RcvSize 才能保证接收缓存不会溢出，所以我们定义流量窗口为接收缓存剩余的空间，也就是Rcv = RcvSize - (lastByteRcv - lastByteRead)。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时/三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p>
<p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p>
<h3 id="TCP的拥塞处理"><a href="#TCP的拥塞处理" class="headerlink" title="TCP的拥塞处理"></a>TCP的拥塞处理</h3><p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：</p>
<ol>
<li>慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</li>
<li>拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。          </li>
<li>快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。         </li>
<li>快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</li>
</ol>
<h3 id="服务器出现了大量CLOSE-WAIT状态如何解决"><a href="#服务器出现了大量CLOSE-WAIT状态如何解决" class="headerlink" title="服务器出现了大量CLOSE_WAIT状态如何解决"></a>服务器出现了大量CLOSE_WAIT状态如何解决</h3><p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。</p>
<h3 id="讲一讲SYN超时，洪泛攻击，以及解决策略"><a href="#讲一讲SYN超时，洪泛攻击，以及解决策略" class="headerlink" title="讲一讲SYN超时，洪泛攻击，以及解决策略"></a>讲一讲SYN超时，洪泛攻击，以及解决策略</h3><p>什么 SYN 是洪泛攻击？ 在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。服务器接收到 SYN 报文段后会为该TCP分配缓存和变量，如果攻击分子大量地往服务器发送 SYN 报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。</p>
<p>解决策略： 当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源Id，目的Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</p>
<p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源Id，目的Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源</p>
<p>这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。</p>
<h2 id="三、HTTP"><a href="#三、HTTP" class="headerlink" title="三、HTTP"></a>三、HTTP</h2><blockquote>
<p>HTTP1.0、HTTP1.1、HTTP2.0 的区别</p>
<p>post 和 get 的区别</p>
</blockquote>
<p>HTTP全称是 HyperText Transfer Protocal，即：超文本传输协议。是互联网上应用最为广泛的一种<strong>网络通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。目前我们使用的是<strong>HTTP/1.1 版本</strong>。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext），这成为了HTTP超文本传输协议标准架构的发展根基。</p>
<h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><p>每个Web 服务器资源都有一个名字，这样客户端就可以说明他们感兴趣的资源是什么了，服务器资源名被称为统一资源标识符（Uniform Resource Identifier,URI）。URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源。</p>
<p>统一资源定位符（URL）是资源标识符最常见的形式。 URL 描述了一台特定服务器上某资源的特定位置。</p>
<p>现在几乎所有的 URI 都是 URL。</p>
<p>URI 的第二种形式就是统一资源名（URN）。URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。 </p>
<h3 id="HTTP消息的结构"><a href="#HTTP消息的结构" class="headerlink" title="HTTP消息的结构"></a>HTTP消息的结构</h3><p><strong>事务和报文</strong></p>
<p>客户端是怎样通过HTTP与Web服务器及其资源进行事务处理的呢？一个<strong>HTTP事务</strong>由一条请求命令（从客户端发往服务器）和一个响应（从服务器发回客户端）结果组成。这种通信是通过名为<strong>HTTP报文</strong>（HTTP Message）的格式化数据块进行的。</p>
<h4 id="HTTP事务："><a href="#HTTP事务：" class="headerlink" title="HTTP事务："></a>HTTP事务：</h4><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9d208228.jpg" alt=""></p>
<h4 id="报文："><a href="#报文：" class="headerlink" title="报文："></a>报文：</h4><p>HTTP 报文是纯文本，不是二进制代码。从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文。</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180beda8938bd4.jpg" alt=""></p>
<p>HTTP 报文包括三部分：</p>
<ul>
<li>起始行</li>
<li>首部字段</li>
<li>主体</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是<strong>GET,POST,PUT,DELETE</strong>. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</p>
<ul>
<li>GET</li>
<li>HEAD</li>
<li>PUT</li>
<li>POST</li>
<li>TRACE</li>
<li>OPTIONS</li>
<li>DELETE</li>
</ul>
<h3 id="Get与POST的区别"><a href="#Get与POST的区别" class="headerlink" title="Get与POST的区别"></a>Get与POST的区别</h3><p>GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：</p>
<ol>
<li>从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</li>
<li>从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</li>
<li>从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。</li>
<li>就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。</li>
<li>从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</li>
</ol>
<p>HTTP请求结构： 请求方式 + 请求URI + 协议及其版本</p>
<p>HTTP响应结构： 状态码 + 原因短语 + 协议及其版本</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>每条HTTP响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是都需要采取其他动作。</p>
<ul>
<li>1xx：表明服务端接收了客户端请求，客户端继续发送请求；</li>
<li>2xx：客户端发送的请求被服务端成功接收并成功进行了处理；</li>
<li>3xx：服务端给客户端返回用于重定向的信息；</li>
<li>4xx：客户端的请求有非法内容；</li>
<li>5xx：服务端未能正常处理客户端的请求而出现意外错误。</li>
<li><strong>200 OK</strong>：表示从客户端发送给服务器的请求被正常处理并返回；</li>
<li><strong>204 No Content</strong>：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）</li>
<li><strong>206 Patial Content</strong>：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。</li>
<li><strong>301 Moved Permanently</strong>：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；</li>
<li><strong>302 Found</strong>：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；</li>
<li><strong>303 See Other</strong>：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源</li>
<li>304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；</li>
<li><strong>400 Bad Request</strong>:表示请求报文中存在语法错误；</li>
<li><strong>401 Unauthorized</strong>：经许可，需要通过HTTP认证；</li>
<li><strong>403 Forbidden</strong>：服务器拒绝该次访问（访问权限出现问题）</li>
<li><strong>404 Not Found</strong>：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</li>
<li><strong>500 Inter Server Error</strong>：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</li>
<li><strong>503 Server Unavailable</strong>：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</li>
</ul>
<p>HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节，而是把这些细节都交给了通用可靠的因特网传输协议 TCP/IP。</p>
<p>在 HTTP 客户端向服务器发送报文之前，需要用网络协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条 TCP/IP 协议。而 IP 地址就是通过 URL 提供的，像<font color=red size=4><code>http://207.200.21.11:80/index.html</code></font> ，还有使用域名服务（Domain Name Services，DNS）的 <font color=red size=4><code>http://www.lazyegg.net</code></font>。</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9f762409.jpg" alt=""></p>
<h3 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h3><ul>
<li><p><strong>HTTP/0.9</strong></p>
<p>HTTP协议的最初版本，功能简陋，仅支持 GET 方法，并且仅能请求访问 HTML 格式的资源</p>
</li>
<li><p><strong>HTTP/1.0</strong></p>
<ul>
<li>增加了请求方式 POST 和 HEAD</li>
<li>不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等</li>
<li>同时也开始支持 cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可</li>
<li>HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等</li>
<li>但是1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive</li>
</ul>
</li>
<li><p><strong>HTTP/1.0+</strong></p>
<p>在20世纪90年代中叶，为满足飞快发展的万维网，很多流行的 Web 客户端和服务器飞快的向 HTTP 中添加各种特性，包括持久的 keep-alive 连接、虚拟主机支持，以及代理连接支持都被假如到 HTTP 中，并称为非官方的事实标准。这种非正式的 HTTP 扩展版本通常称为 HTTP/1.0+</p>
</li>
<li><p><strong>HTTP/1.1</strong></p>
<ul>
<li>http1.1是目前最为主流的http协议版本，从1997年发布至今，仍是主流的http协议版本。</li>
<li>引入了持久连接，或叫长连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</li>
<li>引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。</li>
<li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</li>
<li>http协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度。</li>
</ul>
</li>
<li><p><strong>HTTP/2.0（又名 HTTP-NG）</strong></p>
<ul>
<li>http/2发布于2015年，目前应用还比较少。</li>
<li>http/2是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</li>
<li>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了队头堵塞的问题,此双向的实时通信称为多工（ Multiplexing）。</li>
<li>HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li>
<li>引入头信息压缩机制（ header compression） ,头信息使用gzip或compress压缩后再发送。</li>
</ul>
</li>
</ul>
<h2 id="四、HTTPS"><a href="#四、HTTPS" class="headerlink" title="四、HTTPS"></a>四、HTTPS</h2><p>HTTP缺点：</p>
<ol>
<li>通信使用明文不对数据进行加密（内容容易被窃听）</li>
<li>不验证通信方身份（容易伪装）</li>
<li>无法确定报文完整性（内容易被篡改）</li>
</ol>
<p>因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL（安全套接层）协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p><strong>与 SSL（安全套接层）组合使用的 HTTP 就是 HTTPS</strong></p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedb27f3f29.jpg" alt=""></p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedb8848bf2.jpg" alt=""></p>
<h3 id="HTTP和HTTPS对比"><a href="#HTTP和HTTPS对比" class="headerlink" title="HTTP和HTTPS对比"></a>HTTP和HTTPS对比</h3><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<ol>
<li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ol>
<h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><p>主要的加密方法分为两种：一种是共享密钥加密（对称密钥加密），一种是公开密钥加密（非对称密钥加密）</p>
<h4 id="共享密钥加密-对称秘钥加密"><a href="#共享密钥加密-对称秘钥加密" class="headerlink" title="共享密钥加密(对称秘钥加密)"></a>共享密钥加密(对称秘钥加密)</h4><p>加密与解密使用同一个密钥，常见的对称加密算法：DES，AES，3DES等。</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedbd853fe2.jpg" alt=""></p>
<p>也就是说在加密的同时，也会把密钥发送给对方。在发送密钥过程中可能会造成密钥被窃取，那么如何解决这一问题呢？</p>
<h4 id="公开密钥（非对称密钥）"><a href="#公开密钥（非对称密钥）" class="headerlink" title="公开密钥（非对称密钥）"></a>公开密钥（非对称密钥）</h4><p>公开密钥使用一对非对称密钥。一把叫私有密钥，另一把叫公开密钥。私有密钥不让任何人知道，公有密钥随意发送。公钥加密的信息，只有私钥才能解密。常见的非对称加密算法：RSA，ECC等。</p>
<p>也就是说，发送密文方使用对方的公开密钥进行加密，对方接受到信息后，使用私有密钥进行解密。</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bede10f9420.jpg" alt=""></p>
<p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。</p>
<p>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。</p>
<p>为了解决这一问题，https采用对称加密与非对称加密的混合加密方式。</p>
<h3 id="SSL-TSL"><a href="#SSL-TSL" class="headerlink" title="SSL/TSL"></a>SSL/TSL</h3><p>SSL（Secure Sockets Layer），中文叫做“安全套接层”。它是在上世纪90年代中期，由网景公司设计的。</p>
<p>SSL 协议就是用来解决 HTTP 传输过程的不安全问题，到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。</p>
<p>很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。</p>
<p>SSL/TLS协议的基本思路是采用<a href="http://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>
<p>但是，这里有两个问题。</p>
<ul>
<li><p><strong>如何保证公钥不被篡改？</strong></p>
<p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p>
</li>
<li><p><strong>公钥加密计算量太大，如何减少耗用的时间？</strong></p>
<p>每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p>
</li>
</ul>
<p>因此，SSL/TLS协议的基本过程是这样的：</p>
<ol>
<li>服务端将非对称加密的公钥发送给客户端；</li>
<li>客户端拿着服务端发来的公钥，对对称加密的key做加密并发给服务端；</li>
<li>服务端拿着自己的私钥对发来的密文解密，从来获取到对称加密的key；</li>
<li>二者利用对称加密的key对需要传输的消息做加解密传输。</li>
</ol>
<p>HTTPS相比HTTP，在请求前多了一个「握手」的环节。</p>
<p>握手过程中确定了数据加密的密码。在握手过程中，网站会向浏览器发送 SSL 证书，SSL 证书和我们日常用的身份证类似，是一个支持 HTTPS 网站的身份证明，SSL 证书里面包含了网站的域名，证书有效期，证书的颁发机构以及用于加密传输密码的公钥等信息，由于公钥加密的密码只能被在申请证书时生成的私钥解密，因此浏览器在生成密码之前需要先核对当前访问的域名与证书上绑定的域名是否一致，同时还要对证书的颁发机构进行验证，如果验证失败浏览器会给出证书错误的提示。</p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedc063a776.jpg" alt=""></p>
<p>实际上，我们使用的证书分很多种类型，SSL证书只是其中的一种。证书的格式是由 X.509 标准定义。SSL 证书负责传输公钥，是一种PKI（Public Key Infrastructure，公钥基础结构）证书。</p>
<p>我们常见的证书根据用途不同大致有以下几种：</p>
<ol>
<li>SSL证书，用于加密HTTP协议，也就是HTTPS。</li>
<li>代码签名证书，用于签名二进制文件，比如Windows内核驱动，Firefox插件，Java代码签名等等。</li>
<li>客户端证书，用于加密邮件。</li>
<li>双因素证书，网银专业版使用的USB Key里面用的就是这种类型的证书。</li>
</ol>
<p>这些证书都是由受认证的证书颁发机构——我们称之为CA（Certificate Authority）机构来颁发，针对企业与个人的不同，可申请的证书的类型也不同，价格也不同。CA机构颁发的证书都是受信任的证书，对于 SSL 证书来说，如果访问的网站与证书绑定的网站一致就可以通过浏览器的验证而不会提示错误。</p>
<p><strong>为什么服务端要发送证书给客户端</strong></p>
<p>互联网有太多的服务需要使用证书来验证身份，以至于客户端(操作系统或浏览器等)无法内置所有证书，需要通过服务端将证书发送给客户端。</p>
<p><strong>客户端为什么要验证接收到的证书</strong></p>
<p>中间人攻击</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端&lt;------------攻击者&lt;------------服务端</span><br><span class="line">        伪造证书            拦截请求</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>客户端如何验证接收到的证书</strong></p>
<p>为了回答这个问题，需要引入数字签名(Digital Signature)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| A digital signature |</span><br><span class="line">|(not to be confused  |</span><br><span class="line">|with a digital       |</span><br><span class="line">|certificate)         |            +---------+              +--------+</span><br><span class="line">| is a mathematical   |----哈希---&gt;| 消息摘要  |---私钥加密---&gt;| 数字签名 |</span><br><span class="line">|technique used       |            +---------+              +--------+</span><br><span class="line">|to validate the      |</span><br><span class="line">|authenticity and     |</span><br><span class="line">|integrity of a       |</span><br><span class="line">|message, software    |</span><br><span class="line">|or digital document. |</span><br><span class="line">+---------------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>将一段文本通过哈希（hash）和私钥加密处理后生成数字签名。</p>
<p>假设消息传递在Bob，Susan和Pat三人之间发生。Susan将消息连同数字签名一起发送给Bob，Bob接收到消息后，可以这样验证接收到的消息就是Susan发送的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| A digital signature |</span><br><span class="line">|(not to be confused  |</span><br><span class="line">|with a digital       |</span><br><span class="line">|certificate)         |            +---------+</span><br><span class="line">| is a mathematical   |----哈希---&gt;|  消息摘要 |</span><br><span class="line">|technique used       |            +---------+</span><br><span class="line">|to validate the      |                 |</span><br><span class="line">|authenticity and     |                 |</span><br><span class="line">|integrity of a       |                 |</span><br><span class="line">|message, software    |                 对</span><br><span class="line">|or digital document. |                 比</span><br><span class="line">+---------------------+                 |</span><br><span class="line">                                        |</span><br><span class="line">                                        |</span><br><span class="line">          +--------+               +---------+</span><br><span class="line">          | 数字签名 |---公钥解密---&gt;|  消息摘要 |</span><br><span class="line">          +--------+               +---------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>当然，这个前提是Bob知道Susan的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Bob。此时就引入了<a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener">证书颁发机构</a>（Certificate Authority，简称CA），CA数量并不多，Bob客户端内置了所有受信任CA的证书。CA对Susan的公钥（和其他信息）数字签名后生成证书。</p>
<p>Susan将证书发送给Bob后，Bob通过CA证书的公钥验证证书签名。</p>
<p>Bob信任CA，CA信任Susan 使得 Bob信任Susan，<a href="https://en.wikipedia.org/wiki/Chain_of_trust" target="_blank" rel="noopener">信任链</a>（Chain Of Trust）就是这样形成的。</p>
<p>事实上，Bob客户端内置的是CA的根证书(Root Certificate)，HTTPS协议中服务器会发送证书链（Certificate Chain）给客户端。</p>
<h3 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h3><ol>
<li>Client 使用https的URL访问 Server，要求与 Server 建立 SSL 连接</li>
<li>Server 把事先配置好的公钥证书返回给客户端。</li>
<li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li>
<li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</li>
<li>Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</li>
<li>Server使用对称密钥加密“明文内容A”，发送给Client。</li>
<li>Client使用对称密钥解密响应的密文，得到“明文内容A”。</li>
<li>Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</li>
</ol>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedeeb2c715.jpg" alt=""></p>
<h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p>
<ol>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>
</ol>
<h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p>
<ol>
<li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li>
<li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li>
<li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li>
<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li>
<li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li>
</ol>
<h3 id="HTTP-切换到-HTTPS"><a href="#HTTP-切换到-HTTPS" class="headerlink" title="HTTP 切换到 HTTPS"></a>HTTP 切换到 HTTPS</h3><p>如果需要将网站从http切换到https到底该如何实现呢？</p>
<p>这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="http://www.baidu.com改为https://www.baidu.com" target="_blank" rel="noopener">www.baidu.com改为https://www.baidu.com</a></p>
<p>BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将 <a href="http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。" target="_blank" rel="noopener">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p>
<h3 id="什么是Cookie，Cookie的使用过程是怎么样的？"><a href="#什么是Cookie，Cookie的使用过程是怎么样的？" class="headerlink" title="什么是Cookie，Cookie的使用过程是怎么样的？"></a>什么是Cookie，Cookie的使用过程是怎么样的？</h3><p>由于 http 协议是无状态协议，如果客户通过浏览器访问 web 应用时没有一个保存用户访问状态的机制，那么将不能持续跟踪应用的操作。比如当用户往购物车中添加了商品，web 应用必须在用户浏览别的商品的时候仍保存购物车的状态，以便用户继续往购物车中添加商品。</p>
<p>cookie 是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。由于下面一题会讲到session，所以这里要强调cookie会将会话保存在客户端（session则是把会话保存在服务端）</p>
<p>这里以最常见的登陆案例讲解cookie的使用过程：</p>
<ol>
<li>首先用户在客户端浏览器向服务器发起登陆请求</li>
<li>登陆成功后，服务端会把登陆的用户信息设置 cookie 中，返回给客户端浏览器</li>
<li>客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）</li>
<li>以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了</li>
</ol>
<h3 id="什么是session，有哪些实现session的机制？"><a href="#什么是session，有哪些实现session的机制？" class="headerlink" title="什么是session，有哪些实现session的机制？"></a>什么是session，有哪些实现session的机制？</h3><p>session 是一种维持客户端与服务器端会话的机制。但是与 <strong>cookie 把会话信息保存在客户端本地不一样，session 把会话保留在浏览器端。</strong></p>
<p>我们同样以登陆案例为例子讲解 session 的使用过程：</p>
<ol>
<li>首先用户在客户端浏览器发起登陆请求</li>
<li>登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 session 标识给客户端浏览器。</li>
<li>客户端浏览器会把这个唯一的 session 标识保存在起来</li>
<li>以后再次访问 web 应用时，客户端浏览器会把这个唯一的 session 标识带上，这样服务端就能根据这个唯一标识找到用户信息。</li>
</ol>
<p>看到这里可能会引起疑问：把唯一的 session 标识返回给客户端浏览器，然后保存起来，以后访问时带上，这难道不是 cookie 吗？</p>
<p>没错，<strong>session 只是一种会话机制，在许多 web 应用中，session 机制就是通过 cookie 来实现的</strong>。也就是说它只是使用了 cookie 的功能，并不是使用 cookie 完成会话保存。与 cookie 在保存客户端保存会话的机制相反，session 通过 cookie 的功能把会话信息保存到了服务端。</p>
<p>进一步地说，session 是一种维持服务端与客户端之间会话的机制，它可以有不同的实现。以现在比较流行的小程序为例，阐述一个 session 的实现方案：</p>
<ol>
<li>首先用户登陆后，需要把用户登陆信息保存在服务端，这里我们可以采用 redis。比如说给用户生成一个 userToken，然后以 userId 作为键，以 userToken 作为值保存到 redis 中，并在返回时把 userToken 带回给小程序端。</li>
<li>小程序端接收到 userToken 后把它缓存起来，以后每当访问后端服务时就把 userToken 带上。</li>
<li>在后续的服务中服务端只要拿着小程序端带来的 userToken 和 redis 中的 userToken 进行比对，就能确定用户的登陆状态了。</li>
</ol>
<h3 id="session和cookie有什么区别"><a href="#session和cookie有什么区别" class="headerlink" title="session和cookie有什么区别"></a>session和cookie有什么区别</h3><p>经过上面两道题的阐述，这道题就很清晰了</p>
<ol>
<li>cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话</li>
<li>session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。</li>
<li>如果用 cookie 实现会话，那么会话会保存在客户端浏览器中</li>
<li>而 session 机制提供的会话是保存在服务端的。</li>
</ol>
<h2 id="Other-FAQ"><a href="#Other-FAQ" class="headerlink" title="Other FAQ     "></a>Other FAQ     </h2><h3 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程"></a>从输入网址到获得页面的过程</h3><ol>
<li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>
<li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li>
<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>
<li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li>
<li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
</ol>
<h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><p>XSS 是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</p>
<p>          </p>
<h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p>IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。</p>
<p>每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：</p>
<p>A类地址：以0开头，第一个字节范围：0~127；</p>
<p>B类地址：以10开头，第一个字节范围：128~191；</p>
<p>C类地址：以110开头，第一个字节范围：192~223；</p>
<p>D类地址：以1110开头，第一个字节范围为224~239；</p>
<p>E类地址：以1111开头，保留地址</p>
<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedf2021893.jpg" alt=""></p>
<h2 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h2><ul>
<li>《HTTP 权威指南》</li>
<li><a href="https://arch-long.cn/articles/network/OSI模型TCPIP协议栈.html" target="_blank" rel="noopener">arch-long.cn/articles/ne…</a></li>
<li><a href="https://blog.csdn.net/qq_32998153/article/details/79680704" target="_blank" rel="noopener">blog.csdn.net/qq_32998153…</a></li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Lupinus
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://yoursite.com/2020/06/22/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="[「直击面试」搞定计算机网络]">http://yoursite.com/2020/06/22/搞定计算机网络/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag"># 计算机网络</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/06/21/%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/" rel="prev" title="[缓存的使用和优化]">
      <i class="fa fa-chevron-left"></i> [缓存的使用和优化]
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/06/22/MySQL%E4%B8%89%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/" rel="next" title="[「直击面试」MySQL三万字精华总结]">
      [「直击面试」MySQL三万字精华总结] <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、计算机网络"><span class="nav-number">1.</span> <span class="nav-text">一、计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通信协议"><span class="nav-number">1.1.</span> <span class="nav-text">通信协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络模型"><span class="nav-number">1.2.</span> <span class="nav-text">网络模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、TCP-IP"><span class="nav-number">2.</span> <span class="nav-text">二、TCP&#x2F;IP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP-与-HTTP"><span class="nav-number">2.1.</span> <span class="nav-text">TCP&#x2F;IP 与 HTTP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-与-UDP"><span class="nav-number">2.2.</span> <span class="nav-text">TCP 与 UDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP连接的建立与终止"><span class="nav-number">2.3.</span> <span class="nav-text">TCP连接的建立与终止</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP报文首部"><span class="nav-number">2.3.1.</span> <span class="nav-text">TCP报文首部</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-三次握手"><span class="nav-number">2.3.2.</span> <span class="nav-text">TCP 三次握手</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-四次挥手"><span class="nav-number">2.3.3.</span> <span class="nav-text">TCP 四次挥手</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP协议如何来保证传输的可靠性"><span class="nav-number">2.4.</span> <span class="nav-text">TCP协议如何来保证传输的可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动窗口机制"><span class="nav-number">2.5.</span> <span class="nav-text">滑动窗口机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#流量控制"><span class="nav-number">2.5.1.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拥塞控制"><span class="nav-number">2.5.2.</span> <span class="nav-text">拥塞控制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP的拥塞处理"><span class="nav-number">2.6.</span> <span class="nav-text">TCP的拥塞处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器出现了大量CLOSE-WAIT状态如何解决"><span class="nav-number">2.7.</span> <span class="nav-text">服务器出现了大量CLOSE_WAIT状态如何解决</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#讲一讲SYN超时，洪泛攻击，以及解决策略"><span class="nav-number">2.8.</span> <span class="nav-text">讲一讲SYN超时，洪泛攻击，以及解决策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、HTTP"><span class="nav-number">3.</span> <span class="nav-text">三、HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#URI-和-URL"><span class="nav-number">3.1.</span> <span class="nav-text">URI 和 URL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP消息的结构"><span class="nav-number">3.2.</span> <span class="nav-text">HTTP消息的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP事务："><span class="nav-number">3.2.1.</span> <span class="nav-text">HTTP事务：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#报文："><span class="nav-number">3.2.2.</span> <span class="nav-text">报文：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-number">3.3.</span> <span class="nav-text">方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Get与POST的区别"><span class="nav-number">3.4.</span> <span class="nav-text">Get与POST的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#状态码"><span class="nav-number">3.5.</span> <span class="nav-text">状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协议版本"><span class="nav-number">3.6.</span> <span class="nav-text">协议版本</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、HTTPS"><span class="nav-number">4.</span> <span class="nav-text">四、HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP和HTTPS对比"><span class="nav-number">4.1.</span> <span class="nav-text">HTTP和HTTPS对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对称加密与非对称加密"><span class="nav-number">4.2.</span> <span class="nav-text">对称加密与非对称加密</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#共享密钥加密-对称秘钥加密"><span class="nav-number">4.2.1.</span> <span class="nav-text">共享密钥加密(对称秘钥加密)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#公开密钥（非对称密钥）"><span class="nav-number">4.2.2.</span> <span class="nav-text">公开密钥（非对称密钥）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSL-TSL"><span class="nav-number">4.3.</span> <span class="nav-text">SSL&#x2F;TSL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#证书"><span class="nav-number">4.4.</span> <span class="nav-text">证书</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS的工作原理"><span class="nav-number">4.5.</span> <span class="nav-text">HTTPS的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS的优点"><span class="nav-number">4.6.</span> <span class="nav-text">HTTPS的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTPS的缺点"><span class="nav-number">4.7.</span> <span class="nav-text">HTTPS的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-切换到-HTTPS"><span class="nav-number">4.8.</span> <span class="nav-text">HTTP 切换到 HTTPS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是Cookie，Cookie的使用过程是怎么样的？"><span class="nav-number">4.9.</span> <span class="nav-text">什么是Cookie，Cookie的使用过程是怎么样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是session，有哪些实现session的机制？"><span class="nav-number">4.10.</span> <span class="nav-text">什么是session，有哪些实现session的机制？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#session和cookie有什么区别"><span class="nav-number">4.11.</span> <span class="nav-text">session和cookie有什么区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Other-FAQ"><span class="nav-number">5.</span> <span class="nav-text">Other FAQ     </span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从输入网址到获得页面的过程"><span class="nav-number">5.1.</span> <span class="nav-text">从输入网址到获得页面的过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS-攻击"><span class="nav-number">5.2.</span> <span class="nav-text">XSS 攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP地址的分类"><span class="nav-number">5.3.</span> <span class="nav-text">IP地址的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考与感谢"><span class="nav-number">6.</span> <span class="nav-text">参考与感谢</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Lupinus"
      src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_devops/20160715144434_fZCsF.jpeg">
  <p class="site-author-name" itemprop="name">Lupinus</p>
  <div class="site-description" itemprop="description">Re：从零开始的go学习生活(｀・ω・´)</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/rogerXS80/roger" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rogerXS80&#x2F;roger" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/fastsword66@gmail.com" title="E-Mail → fastsword66@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/5896791111/home?wvr=5&sudaref=graph.qq.com" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;5896791111&#x2F;home?wvr&#x3D;5&amp;sudaref&#x3D;graph.qq.com" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>



      </div>

      
          <div class="links-of-blogroll motion-element links-of-blogroll-block">
            <div class="links-of-blogroll-title">
              <!-- 选择合适的icon -->
              <i class="fa fa-history fa-" aria-hidden="true"></i>
          <!-- 这里对应下文主题配置文件的recent_posts_title值 -->
              最近文章
            </div>
            <ul class="links-of-blogroll-list"> 
              <!-- 设置排序规格，此处我采用按照文章更新时间排序 -->
              
              <!-- 显示三条近期文章，请自信合理配置 -->
              
                <li>
                  <a href="/2021/01/21/Docker%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/" title="Docker通关手册" target="_blank">Docker通关手册</a>
                </li>
              
                <li>
                  <a href="/2020/07/27/IDEA%E6%80%BB%E7%BB%93/" title="[IDEA总结]" target="_blank">[IDEA总结]</a>
                </li>
              
                <li>
                  <a href="/2020/07/08/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" title="[用Hexo+Github搭建个人博客]" target="_blank">[用Hexo+Github搭建个人博客]</a>
                </li>
              
            </ul>
          </div>
      

      
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>




      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Roger</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div><!-- 文件位置：~/sourse/_data/footer.swig -->

<div class="weixin-box">
  <div class="weixin-menu">
    <div class="weixin-hover">
      <div class="weixin-description">微信扫一扫，订阅本博客</div>
    </div>
  </div>
</div>


        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="100" alpha="0.4" zIndex="-1" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-ribbon@1/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

    </div>

<!-- 鼠标点击特效 -->
<script type="text/javascript" src="/js/fireworks.js"></script>

<!-- 点击爱心 
<script type="text/javascript" src="/js/clicklove.js"></script>
-->

</body>
</html>
