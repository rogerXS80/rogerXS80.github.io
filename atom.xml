<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lupinus</title>
  
  <subtitle>Re：从零开始的go学习生活(｀・ω・´)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-27T00:01:26.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lupinus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[IDEA总结]</title>
    <link href="http://yoursite.com/2020/07/27/IDEA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/07/27/IDEA%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-27T00:01:25.000Z</published>
    <updated>2020-07-27T00:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>成长手册，<strong>GitHub</strong> <a href="https://github.com/rogerXS80/roger" target="_blank" rel="noopener">Lupinus</a> ，N线互联网开发必备技能兵器谱</p></blockquote><p>工欲善其事，必先利其器 ，当下有数不清的 Java 程序员将石器时代的 Eclipse 替换成了现代化的智能开发工具 InteliJ IDEA ，写代码的小日子过得不亦乐乎。</p><h2 id="InteliJ-IDEA-介绍"><a href="#InteliJ-IDEA-介绍" class="headerlink" title="InteliJ IDEA 介绍"></a>InteliJ IDEA 介绍</h2><p>IDEA，全称 IntelliJ IDEA，是 Java 语言的集成开发环境，IDEA 在业界被公认为是最好的 java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、创新的 GUI 设计等方面的功能可以说是超常的。</p><p>IDEA是 JetBrains 公司的产品，公司旗下还有其它产品，比如： WebStorm、DataGrip、GoLand…</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>强大的整合能力。比如：Git、Maven、Spring 等</li><li>提示功能的快速、便捷</li><li>提示功能的范围广</li><li>好用的快捷键和代码模板 private static final psf</li><li>精准搜索（ IDEA 会将您的源代码编入索引 ）</li><li>不需要频繁的Ctrl+S（自动保存）</li><li>自带反编译器，方便查看源码</li></ul><p>在 Eclipse 中我们有 Workspace（工作空间）和 Project（工程）的概念，在 IDEA 中只有 Project（工程）和 Module（模块）的概念 。Eclipse 中 workspace 相当于 IDEA 中的 Project ，Eclipse 中 Project 相当于 IDEA 中的 Module</p><p>IDEA 和 Eclipse 的术语对比</p><table><thead><tr><th>Eclipse</th><th>IntelliJ IDEA</th></tr></thead><tbody><tr><td>Workspace</td><td>Project</td></tr><tr><td>Project</td><td>Module</td></tr><tr><td>Facet</td><td>Facet</td></tr><tr><td>Library</td><td>Library</td></tr><tr><td>JRE</td><td>SDK</td></tr><tr><td>Classpath variable</td><td>Path variable</td></tr></tbody></table><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>实时代码模板 (Live Templates)</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/%E5%AE%9E%E6%97%B6%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF.gif" alt=""></p><p>它的原理就是配置一些常用代码字母缩写，在输入简写时可以出现你预定义的固 定模式的代码，使得开发效率大大提高，同时也可以增加个性化。最简单的例子 就是在 Java 中输入 sout 会出现 System.out.println();</p><p><strong>Editor – General – Postfix Completion</strong>  查看已经存在的模板（不可修改）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1.jpg" alt=""></p><p><strong>Editor — Live Templates</strong> 查看或自定义模板（可以添加方式注释、类注释）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d998044c7a7.jpg" alt=""></p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d998038a98f.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description:</span></span><br><span class="line"><span class="comment"> * @param $param$</span></span><br><span class="line"><span class="comment"> * @return $return$</span></span><br><span class="line"><span class="comment"> * @date $time$ $date$</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><p>类注释一般通过 <strong>File — Setting — Editor — Live Templates — File and Code Templates</strong> 设置</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d9980eb46b1.jpg" alt=""></p><h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><p>程序猿么，每天都在写bug，所以这个功能一定得用的溜</p><p>配置通用调试属性和行为 ： <strong>Settings/Preferences | Build, Execution, Deployment | Debugger</strong></p><h4 id="1-断点类型"><a href="#1-断点类型" class="headerlink" title="1. 断点类型"></a>1. 断点类型</h4><p>断点有四种类型：</p><ol><li>行断点（Line Breakpoints）：最经常用的方式， 可以设置在任何可执行的代码行上</li><li>方法断点（Method Breakpoints）： 在进入或退出指定的方法或其实现之一时挂起程序，允许您检查方法的进入/退出条件</li><li>字段断点（Field Watchpoints）： 当指定的字段被读取或写入时，挂起程序。需要注意的是，默认只有写才会停下，想要让读取时也停下，需要右击断点，在<strong>Watch</strong>的<strong>Field access</strong>上打勾才行</li><li>异常断点（Exception Breakpoints）： 当抛出Throwable或其子类时挂起程序 。可以在 *<em>Run — View Breakpoints *</em>中的 Java Exception Breakpoints 里添加异常的具体类型。这样的话，程序中一旦发生了这种异常马上就会停下来</li></ol><h4 id="2-设置断点"><a href="#2-设置断点" class="headerlink" title="2. 设置断点"></a>2. 设置断点</h4><p>左键点击行号栏（快捷键： <code>Ctrl+F8</code> ）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99ab8cc421.jpg" alt=""></p><h5 id="置异常断点"><a href="#置异常断点" class="headerlink" title="置异常断点"></a>置异常断点</h5><p>点击<strong>Debug</strong>工具窗口左侧的的 <strong>View Breakpoints</strong> <img src="https://gitee.com/wjxyzs/img/raw/master/img/small-1.jpg" alt=""> 或者快捷键 <code>Ctrl+Shift+F8</code> ，可以新建异常检测，或者检测所有异常（<strong>Any Exception</strong>） 情况，这样只要程序有相应异常，就会挂起</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99a91e3296.jpg" alt=""></p><h5 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h5><p>有时候我们在循环处理数据时候，可能只关心某个条件的数据，就可以在断点位置右键，设置<strong>断点条件</strong>，（下图，在i==6 的时候挂起程序）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99aceda1e2.jpg" alt=""></p><h5 id="多线程断点"><a href="#多线程断点" class="headerlink" title="多线程断点"></a>多线程断点</h5><p>在调试多线程代码时候，只能串行调试，因为IDEA在Debug时默认阻塞级别是ALL，会阻塞其它线程，只有在当前调试线程走完时才会走其它线程。如果像下图一样是lambda表达式的行，可以选择断点类型。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99a9b956a4.jpg" alt=""></p><p>可以在 View Breakpoints 里选择 Thread （右键断点），这样就可以Frames 切换线程debug了。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99adc603f0.jpg" alt=""></p><h4 id="3-逐步执行程序"><a href="#3-逐步执行程序" class="headerlink" title="3. 逐步执行程序"></a>3. 逐步执行程序</h4><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-2.jpg" alt=""></p><ul><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-3.jpg" alt=""> <strong>step over</strong> —— 步过，如果当前行断点是一个方法，则不进入当前方法体内</li><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-4.jpg" alt=""> <strong>step into</strong> —— 步入，如果当前行断点是一个方法，则进入当前方法体内，一般用于进入自定义方法内，不会进入官方类库的方法</li><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-5.jpg" alt=""> <strong>force step into</strong> <code>Shift+Alt+F7</code> ——  强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法</li><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-6.jpg" alt=""> <strong>step out</strong>  <code>Shift+F8</code> —— 步出， 从步入的方法内退出到方法调用处</li><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-7.jpg" alt=""> <strong>Drop frame</strong> —— 回退到上一步</li><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-8.jpg" alt=""> <strong>Run to cursor</strong>  <code>Alt+F9</code>  ——  运行到光标处，可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点</li></ul><p>断点这块有好多功能，可以分析JVM中堆对象、Java8的Stream操作，留个传送门。。。TODO</p><p>某大佬总结的： <strong><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html" target="_blank" rel="noopener">在Intellij IDEA中使用Debug</a></strong></p><p>官方教程： <strong><a href="https://www.jetbrains.com/help/idea/debugging-code.html" target="_blank" rel="noopener">www.jetbrains.com/help/idea/d…</a></strong></p><h2 id="配置Tomcat远程调试"><a href="#配置Tomcat远程调试" class="headerlink" title="配置Tomcat远程调试"></a>配置Tomcat远程调试</h2><p>有时候会有一些服务器差异问题导致的问题，不好排查，这个时候就想远程调试下服务器上的代码。</p><p>① 配置tomcat， 在tomcat/bin下的 catalina.sh 上边添加下边的一段设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xdebug -Xnoagent -Djava.compiler=NONE </span><br><span class="line">-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=<span class="number">9527</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99ee95d81b.jpg" alt=""></p><p>② IDEA设置</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99f2f33fe3.jpg" alt=""></p><p>③ 在IDEA上启动远程 tomcat后，就能debug了</p><p>还有一种复制Startup/Connection 中的内容到 JAVA_OPTS 中，没有尝试</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99f4b668a5.jpg" alt=""></p><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p>书签在翻看源码或者大佬代码的时候，可以方便记录代码的调用链路。</p><p>书签有匿名书签（可以有无数个）和标记书签（有数字或者字母助记符的书签）两种</p><p>操作书签：<strong>Navigate | Bookmarks</strong> 可以创建匿名书签 Toggle Bookmark。创建标技书签 Toggle Bookmark With Mnemonic，查看标签 Show Bookmarks</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99f588d675.jpg" alt=""></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li><p><strong>Lombok</strong> —— 开发神器，可以简化你的实体类</p></li><li><p><strong>Maven Helper</strong> ——  方便显示maven的依赖树，处理冲突的好帮手</p></li><li><p>.<strong>ignore</strong> —— 忽略不需要提交的文件</p></li><li><p><strong>FindBugs-IDEA</strong> ——  代码审查</p></li><li><p><strong>Alibaba Java Coding Guidelines</strong> ——  阿里的开发设计规范</p></li><li><p><strong>Alibaba Cloud Toolkit</strong> ——  帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器或云端；并且还内置了 Arthas 诊断、Dubbo工具、Terminal 终端、文件上传、函数计算和 MySQL 执行器等工具</p></li><li><p><strong>Easy Code</strong> ——  支持自定义模板的代码生成插件</p></li><li><p><strong>RestfulToolkit</strong> ——  RESTful 服务开发辅助工具集（安利，可以直接在右侧的RestServices查看，所有项目的restful接口，还可以通过 <code>Ctrl \</code> 全局搜索 ）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99f6f87218.jpg" alt=""></p></li></ul><p>IDEA 主题和插件排行榜： <strong><a href="https://plugins.jetbrains.com/search?orderBy=downloads&products=idea" target="_blank" rel="noopener">plugins.jetbrains.com/search?orde…</a></strong></p><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>仅供个人学习使用~~</p><ol><li><p>下载补丁文件 <strong><code>jetbrains-agent.jar</code></strong> 并将它放置到 Idea安装目录的bin目录下，<a href="https://pan.baidu.com/s/1Zy-vQGOdKoqDdB8sWIcQOg" target="_blank" rel="noopener"><strong>pan.baidu.com/s/1Zy-vQGOd…</strong></a></p></li><li><p>免费试用，进入IDEA, 点击最上面的菜单栏中的 *<em>Help - Edit Custom VM Options *</em>，在<code>idea.exw.vmoptionos</code>文件中加入<code>-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2019.2.4\bin\jetbrains-agent.jar</code>(换成你的jar包目录)，重启</p></li><li><p>重启IDEA 后，打开*<em>Help — Register *</em>，在License Server 填上， <a href="http://jetbrains-license-server/" target="_blank" rel="noopener">http://jetbrains-license-server</a> ，失败的话就输入下边的注册码</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">520E5894</span>E2-eyJsaWNlbnNlSWQiOiI1MjBFNTg5NEUyIiwibGljZW5zZWVOYW1lIjoicGlnNiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-DZ/oNHBfyho0XrrCJJvAOKg5Q1tLBgOdbCmzCKwkuM+Yryce0RoOi3OOmH6Ba/uTcCh/L37meyD0FJdJIprv59y4+n+k2kIeF/XKrKqg0dEsDUQRw0lUqqMt99ohqa+zmbJ44Yufdwwx/F1CtoRGvEQ2Mn0QjuqRoZJZ3wiT5Am22JiJW8MaNUl3wg9YPj+OPGARKKJUdUJ0NGUDQBcBAv5ds8LhbSbJSbPkbkwH/a1QMz4nEdn6lRDKI1aFIn43QhBSCFqvUq6TPJlbIJ0ZjE+PyZjHFBKCgkry0DHPXU2BbtIZPsksQnN3fx240a9K6sN7peZnLpEoMoq23FEz4g==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/<span class="number">1</span>nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+<span class="number">8</span>utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/<span class="number">40</span>BjpMUrDRCeKuiBahC0DCoU/<span class="number">4</span>+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>Help — About</strong>，搞定</li></ol><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d9a19720b1f.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>IntelliJ IDEA 2019.3官方指南 <strong><a href="https://www.jetbrains.com/help/idea/installation-guide.html" target="_blank" rel="noopener">www.jetbrains.com/help/idea/i…</a></strong></p><p>idea2019激活 <strong><a href="https://segmentfault.com/a/1190000021488264" target="_blank" rel="noopener">segmentfault.com/a/119000002…</a></strong></p>]]></content>
    
    <summary type="html">
    
      工欲善其事，必先利其器 ，当下有数不清的 Java 程序员将石器时代的 Eclipse 替换成了现代化的智能开发工具 InteliJ IDEA ，写代码的小日子过得不亦乐乎...
    
    </summary>
    
    
      <category term="技能get" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BDget/"/>
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>[用Hexo+Github搭建个人博客]</title>
    <link href="http://yoursite.com/2020/07/08/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/07/08/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-07-08T12:50:38.000Z</published>
    <updated>2020-07-10T12:50:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo框架搭建个人博客"><a href="#hexo框架搭建个人博客" class="headerlink" title="hexo框架搭建个人博客"></a>hexo框架搭建个人博客</h1><h2 id="1-github配置"><a href="#1-github配置" class="headerlink" title="1. github配置"></a>1. github配置</h2><h3 id="下载安装git"><a href="#下载安装git" class="headerlink" title="下载安装git"></a>下载安装git</h3><h3 id="https-git-scm-com"><a href="#https-git-scm-com" class="headerlink" title="https://git-scm.com/"></a><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></h3><h3 id="桌面右击打开Git-Bash-Here"><a href="#桌面右击打开Git-Bash-Here" class="headerlink" title="桌面右击打开Git Bash Here"></a>桌面右击打开Git Bash Here</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"用户名"</span></span><br><span class="line"></span><br><span class="line">$ git config --global user.email <span class="string">"邮箱"</span></span><br></pre></td></tr></table></figure><h3 id="登录github"><a href="#登录github" class="headerlink" title="登录github"></a>登录github</h3><p><img src="/images/github.png" alt="github.png"></p><h3 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h3><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041.png" alt="hexo%20b6a26e944b45432b84f717029640e041.png"></p><h3 id="仓库名是固定的，用户名-github-io，这边已经创建过，所以飘红"><a href="#仓库名是固定的，用户名-github-io，这边已经创建过，所以飘红" class="headerlink" title="仓库名是固定的，用户名+github.io，这边已经创建过，所以飘红"></a>仓库名是固定的，用户名+github.io，这边已经创建过，所以飘红</h3><p><img src="/images/2.png" alt="2.png"></p><h3 id="生成key，在到ssh-key位置"><a href="#生成key，在到ssh-key位置" class="headerlink" title="生成key，在到ssh-key位置"></a>生成key，在到ssh-key位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t -rsa -C <span class="string">"fastsword66@gmail.com"</span></span><br></pre></td></tr></table></figure><p><img src="/images/ssh-keygen.png" alt="ssh-keygen.png"></p><h3 id="找到ssh-keygen目录，复制id-rsa-pub中的内容"><a href="#找到ssh-keygen目录，复制id-rsa-pub中的内容" class="headerlink" title="找到ssh-keygen目录，复制id_rsa.pub中的内容"></a>找到ssh-keygen目录，复制id_rsa.pub中的内容</h3><p><img src="/images/ssh-keygen%201.png" alt="ssh-keygen%201.png"></p><h3 id="到github的settings中设置ssh-keys，把复制的内容copy进去"><a href="#到github的settings中设置ssh-keys，把复制的内容copy进去" class="headerlink" title="到github的settings中设置ssh-keys，把复制的内容copy进去"></a>到github的settings中设置ssh-keys，把复制的内容copy进去</h3><p><img src="/images/ssh.png" alt="ssh.png"></p><p><img src="/images/copy-key.png" alt="copy-key.png"></p><h3 id="确认key是否能够使用"><a href="#确认key是否能够使用" class="headerlink" title="确认key是否能够使用"></a>确认key是否能够使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><h2 id="2-hexo框架"><a href="#2-hexo框架" class="headerlink" title="2. hexo框架"></a>2. hexo框架</h2><h3 id="查看npm版本号"><a href="#查看npm版本号" class="headerlink" title="查看npm版本号"></a>查看npm版本号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><h3 id="如果有就通过npm安装hexo"><a href="#如果有就通过npm安装hexo" class="headerlink" title="如果有就通过npm安装hexo"></a>如果有就通过npm安装hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p><img src="/images/hexo.png" alt="hexo.png"></p><h3 id="选个位置创建个新文件夹myblog，在文件夹中右键打开Git-Bash-Here，初始化hexo"><a href="#选个位置创建个新文件夹myblog，在文件夹中右键打开Git-Bash-Here，初始化hexo" class="headerlink" title="选个位置创建个新文件夹myblog，在文件夹中右键打开Git Bash Here，初始化hexo"></a>选个位置创建个新文件夹myblog，在文件夹中右键打开Git Bash Here，初始化hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><h3 id="安装hexo-deploy-git，方便以后用hexo-deoloy去部署网站"><a href="#安装hexo-deploy-git，方便以后用hexo-deoloy去部署网站" class="headerlink" title="安装hexo-deploy-git，方便以后用hexo-deoloy去部署网站"></a>安装hexo-deploy-git，方便以后用hexo-deoloy去部署网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="本地测试是否能预览博客，复制地址"><a href="#本地测试是否能预览博客，复制地址" class="headerlink" title="本地测试是否能预览博客，复制地址"></a>本地测试是否能预览博客，复制地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041%201.png" alt="hexo%20b6a26e944b45432b84f717029640e041%201.png"></p><h3 id="打开-config设置deployment"><a href="#打开-config设置deployment" class="headerlink" title="打开_config设置deployment"></a>打开_config设置deployment</h3><p><img src="/images/deployment.png" alt="deployment.png"></p><h3 id="repository从你的仓库中copy"><a href="#repository从你的仓库中copy" class="headerlink" title="repository从你的仓库中copy"></a>repository从你的仓库中copy</h3><p><img src="/images/1593523025(1).png" alt="1593523025(1).png"></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctrl+c 退出server</span><br><span class="line"></span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h2 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3. 更换主题"></a>3. 更换主题</h2><h3 id="到hexo官网：-https-hexo-io-zh-cn"><a href="#到hexo官网：-https-hexo-io-zh-cn" class="headerlink" title="到hexo官网： https://hexo.io/zh-cn/"></a>到hexo官网： <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></h3><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041%202.png" alt="hexo%20b6a26e944b45432b84f717029640e041%202.png"></p><p><img src="/images/2%201.png" alt="2%201.png"></p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041%203.png" alt="hexo%20b6a26e944b45432b84f717029640e041%203.png"></p><h3 id="解压后放到myblog中的themes"><a href="#解压后放到myblog中的themes" class="headerlink" title="解压后放到myblog中的themes"></a>解压后放到myblog中的themes</h3><p><img src="/images/1593525431(1).png" alt="1593525431(1).png"></p><h3 id="打开-config设置主题，名称是主题文件夹名字，可以更改"><a href="#打开-config设置主题，名称是主题文件夹名字，可以更改" class="headerlink" title="打开_config设置主题，名称是主题文件夹名字，可以更改"></a>打开_config设置主题，名称是主题文件夹名字，可以更改</h3><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041%204.png" alt="hexo%20b6a26e944b45432b84f717029640e041%204.png"></p><h3 id="生成静态文件-1"><a href="#生成静态文件-1" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h3 id="部署发布"><a href="#部署发布" class="headerlink" title="部署发布"></a>部署发布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="完成，是不是非常简单"><a href="#完成，是不是非常简单" class="headerlink" title="完成，是不是非常简单"></a>完成，是不是非常简单</h3><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041%205.png" alt="hexo%20b6a26e944b45432b84f717029640e041%205.png"></p><h2 id="Ending…"><a href="#Ending…" class="headerlink" title="Ending…"></a>Ending…</h2>]]></content>
    
    <summary type="html">
    
      hexo框架搭建个人博客 1. github配置,下载安装git,桌面右击打开Git Bash Here 创建新仓库,仓库名是固定的，用户名+github.io，这边已经创建过，所以飘红...
    
    </summary>
    
    
      <category term="技能get" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BDget/"/>
    
    
      <category term="博客搭建" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>[用PicGo+Gitee（码云）搭建Markdown图床]</title>
    <link href="http://yoursite.com/2020/07/08/%E7%94%A8PicGo-Gitee%EF%BC%88%E7%A0%81%E4%BA%91%EF%BC%89%E6%90%AD%E5%BB%BAMarkdown%E5%9B%BE%E5%BA%8A/"/>
    <id>http://yoursite.com/2020/07/08/%E7%94%A8PicGo-Gitee%EF%BC%88%E7%A0%81%E4%BA%91%EF%BC%89%E6%90%AD%E5%BB%BAMarkdown%E5%9B%BE%E5%BA%8A/</id>
    <published>2020-07-08T12:50:38.000Z</published>
    <updated>2020-07-08T12:50:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用PicGo-Gitee（码云）搭建Markdown图床"><a href="#用PicGo-Gitee（码云）搭建Markdown图床" class="headerlink" title="用PicGo+Gitee（码云）搭建Markdown图床"></a>用PicGo+Gitee（码云）搭建Markdown图床</h1><h2 id="一：引言"><a href="#一：引言" class="headerlink" title="一：引言"></a>一：引言</h2><p>图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。</p><p>简单来说，图床就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 Electron-vue 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，<a href="http://sm.ms/" target="_blank" rel="noopener">SM.MS</a>，imgur 等8种常用图床，功能强大，简单易用，同时，它也支持Gitee（码云）。</p><h2 id="二：需要用到的软件"><a href="#二：需要用到的软件" class="headerlink" title="二：需要用到的软件"></a>二：需要用到的软件</h2><h3 id="1-Typora（Markdown文本编辑软件）"><a href="#1-Typora（Markdown文本编辑软件）" class="headerlink" title="1.Typora（Markdown文本编辑软件）"></a><strong>1.Typora（Markdown文本编辑软件）</strong></h3><h3 id="Typora-是一款支持实时预览的-Markdown-文本编辑器，并且完全免费。"><a href="#Typora-是一款支持实时预览的-Markdown-文本编辑器，并且完全免费。" class="headerlink" title="Typora 是一款支持实时预览的 Markdown 文本编辑器，并且完全免费。"></a><strong>Typora 是一款支持实时预览的 Markdown 文本编辑器，并且完全免费。</strong></h3><h3 id="下载地址：https-www-typora-io"><a href="#下载地址：https-www-typora-io" class="headerlink" title="下载地址：https://www.typora.io/"></a><strong>下载地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></strong></h3><h3 id="使用教程：https-www-cnblogs-com-xuexianqi-p-13260516-html"><a href="#使用教程：https-www-cnblogs-com-xuexianqi-p-13260516-html" class="headerlink" title="使用教程：https://www.cnblogs.com/xuexianqi/p/13260516.html"></a><strong>使用教程：<a href="https://www.cnblogs.com/xuexianqi/p/13260516.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuexianqi/p/13260516.html</a></strong></h3><h3 id="进入下载地址后，根据系统来选择安装包，下载完成后，直接无脑下一步即可，路径默认"><a href="#进入下载地址后，根据系统来选择安装包，下载完成后，直接无脑下一步即可，路径默认" class="headerlink" title="进入下载地址后，根据系统来选择安装包，下载完成后，直接无脑下一步即可，路径默认"></a><strong>进入下载地址后，根据系统来选择安装包，下载完成后，直接无脑下一步即可，路径默认</strong></h3><p><img src="/images/o_20070611481801.png" alt="o_20070611481801.png"></p><h3 id="2-PicGo（图床软件）"><a href="#2-PicGo（图床软件）" class="headerlink" title="2.PicGo（图床软件）"></a><strong>2.PicGo（图床软件）</strong></h3><h3 id="一个图床，一个用于快速上传图片并获取图片URL链接的工具，也完全免费。"><a href="#一个图床，一个用于快速上传图片并获取图片URL链接的工具，也完全免费。" class="headerlink" title="一个图床，一个用于快速上传图片并获取图片URL链接的工具，也完全免费。"></a><strong>一个图床，一个用于快速上传图片并获取图片URL链接的工具，也完全免费。</strong></h3><h3 id="官方指南：https-picgo-github-io-PicGo-Doc-zh-guide"><a href="#官方指南：https-picgo-github-io-PicGo-Doc-zh-guide" class="headerlink" title="官方指南：https://picgo.github.io/PicGo-Doc/zh/guide/"></a><strong>官方指南：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/" target="_blank" rel="noopener">https://picgo.github.io/PicGo-Doc/zh/guide/</a></strong></h3><h3 id="下载地址：https-github-com-Molunerfinn-PicGo-releases"><a href="#下载地址：https-github-com-Molunerfinn-PicGo-releases" class="headerlink" title="下载地址：https://github.com/Molunerfinn/PicGo/releases"></a><strong>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></strong></h3><h3 id="GitHub网站进不去的点这里：https-www-cnblogs-com-xuexianqi-p-13219719-html"><a href="#GitHub网站进不去的点这里：https-www-cnblogs-com-xuexianqi-p-13219719-html" class="headerlink" title="GitHub网站进不去的点这里：https://www.cnblogs.com/xuexianqi/p/13219719.html"></a><strong>GitHub网站进不去的点这里：<a href="https://www.cnblogs.com/xuexianqi/p/13219719.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuexianqi/p/13219719.html</a></strong></h3><h3 id="进入下载地址后，选择最新版本，Windows系统点击-exe文件进行下载，安装直接无脑下一步，路径默认即可（MacOS系统点击-dmg文件，Linux系统点击tar-gz下载）"><a href="#进入下载地址后，选择最新版本，Windows系统点击-exe文件进行下载，安装直接无脑下一步，路径默认即可（MacOS系统点击-dmg文件，Linux系统点击tar-gz下载）" class="headerlink" title="进入下载地址后，选择最新版本，Windows系统点击.exe文件进行下载，安装直接无脑下一步，路径默认即可（MacOS系统点击.dmg文件，Linux系统点击tar.gz下载）"></a><strong>进入下载地址后，选择最新版本，Windows系统点击.exe文件进行下载，安装直接无脑下一步，路径默认即可（MacOS系统点击.dmg文件，Linux系统点击tar.gz下载）</strong></h3><p><img src="/images/o_20070611482102.png" alt="o_20070611482102.png"></p><h3 id="3-Gitee（码云）"><a href="#3-Gitee（码云）" class="headerlink" title="3.Gitee（码云）"></a><strong>3.Gitee（码云）</strong></h3><h3 id="码云，一款基于-Git-的代码托管和研发协作平台官方，又称为国内的github。"><a href="#码云，一款基于-Git-的代码托管和研发协作平台官方，又称为国内的github。" class="headerlink" title="码云，一款基于 Git 的代码托管和研发协作平台官方，又称为国内的github。"></a><strong>码云，一款基于 Git 的代码托管和研发协作平台官方，又称为国内的github。</strong></h3><h3 id="官方网站：https-gitee-com"><a href="#官方网站：https-gitee-com" class="headerlink" title="官方网站：https://gitee.com/"></a><strong>官方网站：<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></strong></h3><h3 id="注册网址：https-gitee-com-signup"><a href="#注册网址：https-gitee-com-signup" class="headerlink" title="注册网址：https://gitee.com/signup"></a><strong>注册网址：<a href="http://www.baidu.com/link?url=Q9yIAdEvisuJfrmu8LQ_LZt3jRfQICY7Q4jyCEKyPdkDfh2x1FcKkIfyg-7bkdLc" target="_blank" rel="noopener">https://gitee.com/signup</a></strong></h3><h1 id="三：搭建教程"><a href="#三：搭建教程" class="headerlink" title="三：搭建教程"></a><strong>三：搭建教程</strong></h1><h3 id="1-创建好Gitee账号后，点击右上角加号-“-”，点击：新建仓库"><a href="#1-创建好Gitee账号后，点击右上角加号-“-”，点击：新建仓库" class="headerlink" title="1.创建好Gitee账号后，点击右上角加号 “+”，点击：新建仓库"></a>1.创建好Gitee账号后，点击右上角加号 “+”，点击：新建仓库</h3><h3 id="2-仓库名称（自定义）-路径（自定义）-公开-使用Readme文件初始化这个仓库-创建"><a href="#2-仓库名称（自定义）-路径（自定义）-公开-使用Readme文件初始化这个仓库-创建" class="headerlink" title="2.仓库名称（自定义） - 路径（自定义） - 公开 - 使用Readme文件初始化这个仓库 - 创建"></a>2.仓库名称（自定义） - 路径（自定义） - 公开 - 使用Readme文件初始化这个仓库 - 创建</h3><p><img src="/images/o_20070710300302.png" alt="o_20070710300302.png"></p><h3 id="3-点击右上角用户头像右边的下拉框，点击：设置"><a href="#3-点击右上角用户头像右边的下拉框，点击：设置" class="headerlink" title="3.点击右上角用户头像右边的下拉框，点击：设置"></a>3.点击右上角用户头像右边的下拉框，点击：设置</h3><h3 id="4-点击左侧-：私人令牌"><a href="#4-点击左侧-：私人令牌" class="headerlink" title="4.点击左侧 ：私人令牌"></a>4.点击左侧 ：私人令牌</h3><h3 id="5-点击：生成新令牌"><a href="#5-点击：生成新令牌" class="headerlink" title="5.点击：生成新令牌"></a>5.点击：生成新令牌</h3><h3 id="6-私人令牌描述（自定义）-选择-“peojects”-提交"><a href="#6-私人令牌描述（自定义）-选择-“peojects”-提交" class="headerlink" title="6.私人令牌描述（自定义） - 选择 “peojects” - 提交"></a>6.私人令牌描述（自定义） - 选择 “peojects” - 提交</h3><p><img src="/images/o_20070710303206.png" alt="o_20070710303206.png"></p><h3 id="7-Note-自定义一个名称，repo-打上-√"><a href="#7-Note-自定义一个名称，repo-打上-√" class="headerlink" title="7.Note 自定义一个名称，repo 打上 √"></a>7.Note 自定义一个名称，repo 打上 √</h3><h3 id="8-输入登录码云的密码，点击：验证"><a href="#8-输入登录码云的密码，点击：验证" class="headerlink" title="8.输入登录码云的密码，点击：验证"></a>8.输入登录码云的密码，点击：验证</h3><p><img src="/images/o_20070710303507.png" alt="o_20070710303507.png"></p><h3 id="9-现在生成的是一串Token，只会在现在显示一次，所以要妥善保管好，点击：复制-打勾“我已经了解…”-确认并关闭"><a href="#9-现在生成的是一串Token，只会在现在显示一次，所以要妥善保管好，点击：复制-打勾“我已经了解…”-确认并关闭" class="headerlink" title="9.现在生成的是一串Token，只会在现在显示一次，所以要妥善保管好，点击：复制 - 打勾“我已经了解…” - 确认并关闭"></a>9.现在生成的是一串Token，只会在现在显示一次，所以要妥善保管好，点击：复制 - 打勾“我已经了解…” - 确认并关闭</h3><p><img src="/images/o_20070710303808.png" alt="o_20070710303808.png"></p><h3 id="10-打开PicGo，点击左侧-插件设置-搜索框输入：gitee-点击右边的gitee-uploader：安装"><a href="#10-打开PicGo，点击左侧-插件设置-搜索框输入：gitee-点击右边的gitee-uploader：安装" class="headerlink" title="10.打开PicGo，点击左侧 - 插件设置 - 搜索框输入：gitee - 点击右边的gitee-uploader：安装"></a>10.打开PicGo，点击左侧 - 插件设置 - 搜索框输入：gitee - 点击右边的gitee-uploader：安装</h3><p><img src="/images/o_20070710304309.png" alt="o_20070710304309.png"></p><h3 id="11-点击左侧：图床设置-gitee，进行如下设置"><a href="#11-点击左侧：图床设置-gitee，进行如下设置" class="headerlink" title="11.点击左侧：图床设置 - gitee，进行如下设置"></a>11.点击左侧：图床设置 - gitee，进行如下设置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">repo：  填写用户名/仓库名</span><br><span class="line"></span><br><span class="line">branch：  填写：master</span><br><span class="line"></span><br><span class="line">token：  填写刚才生成的那一串token</span><br><span class="line"></span><br><span class="line">path：  填写：img</span><br><span class="line"></span><br><span class="line">customPath：  默认即可，不用填写</span><br><span class="line"></span><br><span class="line">customUrl：  默认即可，不用填写</span><br></pre></td></tr></table></figure><p><img src="/images/1594124775(1).png" alt="1594124775(1).png"></p><h2 id="四：图片上传至图库的方法1（推荐）"><a href="#四：图片上传至图库的方法1（推荐）" class="headerlink" title="四：图片上传至图库的方法1（推荐）"></a><strong>四：图片上传至图库的方法1（推荐）</strong></h2><h3 id="1-打开Typora，点击左上角：文件-偏好设置"><a href="#1-打开Typora，点击左上角：文件-偏好设置" class="headerlink" title="1.打开Typora，点击左上角：文件 - 偏好设置"></a><strong>1.打开Typora，点击左上角：文件 - 偏好设置</strong></h3><h3 id="2-点击：图像-插入图片时（下拉选择：上传图片）-对网络位置的图片应用上述规则（可选可不选，选中就是图片也会复制到本地）-允许根据YAML设置自动上传图片-上传服务：下拉后选择-PicGo（app）-选择PicGo路径"><a href="#2-点击：图像-插入图片时（下拉选择：上传图片）-对网络位置的图片应用上述规则（可选可不选，选中就是图片也会复制到本地）-允许根据YAML设置自动上传图片-上传服务：下拉后选择-PicGo（app）-选择PicGo路径" class="headerlink" title="2.点击：图像 - 插入图片时（下拉选择：上传图片） - 对网络位置的图片应用上述规则（可选可不选，选中就是图片也会复制到本地） - 允许根据YAML设置自动上传图片 - 上传服务：下拉后选择 PicGo（app） - 选择PicGo路径"></a>2.点击：图像 - 插入图片时（下拉选择：上传图片） - 对网络位置的图片应用上述规则（可选可不选，选中就是图片也会复制到本地） - 允许根据YAML设置自动上传图片 - 上传服务：下拉后选择 PicGo（app） - 选择PicGo路径</h3><p><img src="/images/o_20070612482223.png" alt="o_20070612482223.png"></p><h3 id="3-找到PicGo的安装路径，默认是C-Program-Files-PicGo点击：打开"><a href="#3-找到PicGo的安装路径，默认是C-Program-Files-PicGo点击：打开" class="headerlink" title="3.找到PicGo的安装路径，默认是C:\Program Files\PicGo点击：打开"></a>3.找到PicGo的安装路径，默认是C:\Program Files\PicGo点击：打开</h3><p><img src="/images/o_20070612104519.png" alt="o_20070612104519.png"></p><h3 id="4-点击：验证图片上传选项，显示绿色字-“成功上床图片并获得新的URL”，点击：OK"><a href="#4-点击：验证图片上传选项，显示绿色字-“成功上床图片并获得新的URL”，点击：OK" class="headerlink" title="4.点击：验证图片上传选项，显示绿色字 “成功上床图片并获得新的URL”，点击：OK"></a>4.点击：验证图片上传选项，显示绿色字 “成功上床图片并获得新的URL”，点击：OK</h3><p><img src="/images/20200707184938.png" alt="20200707184938.png"></p><h3 id="5-此时，截完图之后，直接按粘贴快捷键（Ctrl-V）即可将图片上传到图库"><a href="#5-此时，截完图之后，直接按粘贴快捷键（Ctrl-V）即可将图片上传到图库" class="headerlink" title="5.此时，截完图之后，直接按粘贴快捷键（Ctrl+V）即可将图片上传到图库"></a>5.此时，截完图之后，直接按粘贴快捷键（Ctrl+V）即可将图片上传到图库</h3><h3 id="6-也成功显示出来了"><a href="#6-也成功显示出来了" class="headerlink" title="6.也成功显示出来了"></a>6.也成功显示出来了</h3><p><img src="/images/20200707185045.png" alt="20200707185045.png"></p><h1 id="五：图片上传至图库的方法2"><a href="#五：图片上传至图库的方法2" class="headerlink" title="五：图片上传至图库的方法2"></a><strong>五：图片上传至图库的方法2</strong></h1><h3 id="1-设置快捷键"><a href="#1-设置快捷键" class="headerlink" title="1.设置快捷键"></a>1.设置快捷键</h3><p><img src="/images/o_20070611485712.png" alt="o_20070611485712.png"></p><h3 id="2-点击：编辑"><a href="#2-点击：编辑" class="headerlink" title="2.点击：编辑"></a>2.点击：编辑</h3><p><img src="/images/o_20070611490013.png" alt="o_20070611490013.png"></p><h3 id="3-同时按住Ctrl、Shift、V-组合键（当然，也可以自定义），点击：确定"><a href="#3-同时按住Ctrl、Shift、V-组合键（当然，也可以自定义），点击：确定" class="headerlink" title="3.同时按住Ctrl、Shift、V 组合键（当然，也可以自定义），点击：确定"></a>3.同时按住Ctrl、Shift、V 组合键（当然，也可以自定义），点击：确定</h3><p><img src="/images/o_20070611490414.png" alt="o_20070611490414.png"></p><h3 id="4-我们截完图之后，直接按下快捷键（Ctrl-Shift-V）就把截图上传到图库了，并且自动复制了图片的外链，然后我们直接按下快捷键（Ctr-V）就可以粘贴了"><a href="#4-我们截完图之后，直接按下快捷键（Ctrl-Shift-V）就把截图上传到图库了，并且自动复制了图片的外链，然后我们直接按下快捷键（Ctr-V）就可以粘贴了" class="headerlink" title="4.我们截完图之后，直接按下快捷键（Ctrl+Shift+V）就把截图上传到图库了，并且自动复制了图片的外链，然后我们直接按下快捷键（Ctr+V）就可以粘贴了"></a>4.我们截完图之后，直接按下快捷键（Ctrl+Shift+V）就把截图上传到图库了，并且自动复制了图片的外链，然后我们直接按下快捷键（Ctr+V）就可以粘贴了</h3><p><img src="/images/20200707185135.png" alt="20200707185135.png"></p><h3 id="5-单击图片即可看到图片的外链"><a href="#5-单击图片即可看到图片的外链" class="headerlink" title="5.单击图片即可看到图片的外链"></a>5.单击图片即可看到图片的外链</h3><p><img src="/images/20200707185144.png" alt="20200707185144.png"></p><h2 id="Ending…"><a href="#Ending…" class="headerlink" title="Ending…."></a>Ending….</h2>]]></content>
    
    <summary type="html">
    
      一：引言,图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种...
    
    </summary>
    
    
      <category term="技能get" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BDget/"/>
    
    
      <category term="图床制作" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BA%8A%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>[客户端使用]</title>
    <link href="http://yoursite.com/2020/06/22/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/22/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-22T06:23:33.000Z</published>
    <updated>2020-06-22T06:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Python客户端"><a href="#一-Python客户端" class="headerlink" title="一 Python客户端"></a>一 Python客户端</h2><h3 id="1-Python操作Redis之普通连接"><a href="#1-Python操作Redis之普通连接" class="headerlink" title="1 Python操作Redis之普通连接"></a>1 Python操作Redis之普通连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 pip3 install redis</span></span><br><span class="line"><span class="comment"># 简单使用</span></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="comment"># conn=Redis()</span></span><br><span class="line"><span class="comment"># 连接对象</span></span><br><span class="line">conn=Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line">ret=conn.get(<span class="string">'name'</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><h3 id="2-Python操作Redis之连接池"><a href="#2-Python操作Redis之连接池" class="headerlink" title="2 Python操作Redis之连接池"></a>2 Python操作Redis之连接池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># t_redis_pool.py</span></span><br><span class="line"><span class="comment"># redis连接池</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># pool必须是单例的</span></span><br><span class="line">POOL = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>,max_connections=<span class="number">100</span>)  <span class="comment"># 造一个池子,最多能放100个连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># t_redis_conn.py</span></span><br><span class="line"><span class="comment"># redis连接池</span></span><br><span class="line"><span class="comment"># import redis</span></span><br><span class="line"><span class="comment"># pool必须是单例的</span></span><br><span class="line"><span class="comment"># pool = redis.ConnectionPool(host='127.0.0.1', port=6379,max_connections=100)  # 造一个池子,最多能放100个连接</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># 包内的py文件，如果想右键运行，导包的时候不能带点</span></span><br><span class="line"><span class="keyword">from</span> t_redis_pool <span class="keyword">import</span> POOL  <span class="comment"># pycharm提示的错</span></span><br><span class="line">r = redis.Redis(connection_pool=POOL)  <span class="comment"># 只要执行这一句话，就是从池中拿出一个连接</span></span><br><span class="line">ret=r.get(<span class="string">'name'</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><h3 id="3-操作之String操作"><a href="#3-操作之String操作" class="headerlink" title="3 操作之String操作"></a>3 操作之String操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串操作</span></span><br><span class="line"><span class="comment"># 1 set的用法</span></span><br><span class="line"><span class="comment"># conn.set('height',180) #基本使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.set('height','190',nx=True)</span></span><br><span class="line"><span class="comment"># conn.set('height','190',xx=True)</span></span><br><span class="line"><span class="comment"># conn.set('height1','190',xx=True)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">ex，过期时间（秒）</span></span><br><span class="line"><span class="string">     px，过期时间（毫秒）</span></span><br><span class="line"><span class="string">     nx，如果设置为True，则只有name不存在时，当前set操作才执行,值存在，就修改不了，执行没效果</span></span><br><span class="line"><span class="string">     xx，如果设置为True，则只有name存在时，当前set操作才执行，值存在才能修改，值不存在，不会设置新值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># setnx(name, value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置值，只有name不存在时，执行设置操作（添加）,如果存在，不会修改</span></span><br><span class="line"><span class="comment"># setex(name, value, time)</span></span><br><span class="line"><span class="comment"># 设置值</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line"><span class="comment"># time，过期时间（数字秒 或 timedelta对象）</span></span><br><span class="line"><span class="comment"># psetex(name, time_ms, value)</span></span><br><span class="line"><span class="comment"># 设置值</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line"><span class="comment"># time_ms，过期时间（数字毫秒 或 timedelta对象）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mset</span></span><br><span class="line"><span class="comment"># conn.mset(&#123;'name1':'11','name3':'dasfd'&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.mget(['name1','name','name3'])</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.getset('name1', '999')</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.getrange('name1',0,0) # 前闭后闭区间</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.setrange('name1',1,88888)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.getbit('name1',9)</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#incr ：统计网站访问量，页面访问量，接口访问量</span></span><br><span class="line"><span class="comment"># conn.incr('name1')  # 只要一执行，数字加1</span></span><br><span class="line"><span class="comment"># conn.incr('name1')  # 只要一执行，数字加1</span></span><br><span class="line"><span class="comment"># conn.incr('name1')  # 只要一执行，数字加1</span></span><br><span class="line"><span class="comment"># conn.incr('name1')  # 只要一执行，数字加1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#decr</span></span><br><span class="line"><span class="comment"># conn.incr('name1',-2)</span></span><br><span class="line"><span class="comment"># conn.decr('name1',3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.append('name1','oo')</span></span><br><span class="line"><span class="comment"># conn.incr('name1')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##重点：</span></span><br><span class="line"><span class="comment">#set :很多参数</span></span><br><span class="line"><span class="comment">#get</span></span><br><span class="line"><span class="comment">#mset</span></span><br><span class="line"><span class="comment">#mget</span></span><br><span class="line"><span class="comment">#incr</span></span><br><span class="line"><span class="comment">#decr</span></span><br><span class="line"><span class="comment">#append</span></span><br></pre></td></tr></table></figure><h3 id="4-操作之Hash操作"><a href="#4-操作之Hash操作" class="headerlink" title="4 操作之Hash操作"></a>4 操作之Hash操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hash操作</span></span><br><span class="line"><span class="comment"># conn.hset('hash1','name','lqz')</span></span><br><span class="line"><span class="comment"># conn.hset('hash1','name2','lqz')</span></span><br><span class="line"><span class="comment"># conn.hset('hash1','name','lqz444')  # key不可以重复，</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.hget('hash1','name')  #只能取一个</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.hmset('hash2',&#123;'key1':'value1','key2':'value2'&#125;)</span></span><br><span class="line"><span class="comment"># ret=conn.hmget('hash1','name','name2')</span></span><br><span class="line"><span class="comment"># ret=conn.hmget('hash1',['name','name2'])</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.hgetall('hash1')  # 尽量少用</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.hlen('hash1')</span></span><br><span class="line"><span class="comment"># ret=conn.hkeys('hash1')</span></span><br><span class="line"><span class="comment"># ret=conn.hexists('hash1','name1')</span></span><br><span class="line"><span class="comment"># ret=conn.hdel('hash1','name')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.hset('hash1','name',12)</span></span><br><span class="line"><span class="comment"># ret=conn.hincrby('hash1','name')</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以后想取出hash类型内所有的数据，不建议用hgetall，建议用hscan_iter</span></span><br><span class="line"><span class="comment"># 一次性先取一部分回来（假设有1w条，先取回100条，把这100条做成了生成器）</span></span><br><span class="line"><span class="comment"># ret=conn.hscan_iter('hash1')</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"><span class="comment"># for i in ret:</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##重点掌握</span></span><br><span class="line"><span class="comment"># hset</span></span><br><span class="line"><span class="comment"># hget</span></span><br><span class="line"><span class="comment">#hmset</span></span><br><span class="line"><span class="comment">#hmget</span></span><br><span class="line"><span class="comment"># hincrby</span></span><br><span class="line"><span class="comment"># 区分hgetall和hscan_iter</span></span><br></pre></td></tr></table></figure><h3 id="5-操作之List操作"><a href="#5-操作之List操作" class="headerlink" title="5 操作之List操作"></a>5 操作之List操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 列表操作</span></span><br><span class="line"><span class="comment"># ret=conn.lpush('list1',1,2,3,4,5)</span></span><br><span class="line"><span class="comment"># ret=conn.rpush('list1',999)</span></span><br><span class="line"><span class="comment"># ret=conn.lpushx('list2',1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lpushx('list1',888)  # 必须有这个key才能放</span></span><br><span class="line"><span class="comment"># ret=conn.rpushx('list1',666)  # 我们猜，返回总长度</span></span><br><span class="line"><span class="comment"># ret=conn.llen('list1')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.linsert('list1','before','3','77777777')</span></span><br><span class="line"><span class="comment"># ret=conn.linsert('list1','after','3','66666666')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lset('list1',3,'22222')  #从0开始计数</span></span><br><span class="line"><span class="comment"># ret=conn.lset('list1',0,'11111')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lrem('list1',2,'5')  # 从前往后删除两个5</span></span><br><span class="line"><span class="comment"># ret=conn.lrem('list1',-1,'5') # 从后往前删除1个5</span></span><br><span class="line"><span class="comment"># ret=conn.lrem('list1',0,'5')   # 删除所有5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lpop('list1')</span></span><br><span class="line"><span class="comment"># ret=conn.rpop('list1')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lindex('list1',0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lrange('list1',0,2)  # 前闭后闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.ltrim('list1',1,2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重点block,阻塞,可以写一个超时时间</span></span><br><span class="line"><span class="comment"># ret=conn.blpop('list1',timeout=10)</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定制分批取列表的数据</span></span><br><span class="line"><span class="comment"># conn.lpush('test',*[1,2,3,4,45,5,6,7,7,8,43,5,6,768,89,9,65,4,23,54,6757,8,68])</span></span><br><span class="line"><span class="comment"># conn.flushall()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan_list</span><span class="params">(name,count=<span class="number">2</span>)</span>:</span></span><br><span class="line">    index=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data_list=conn.lrange(name,index,count+index<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data_list:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index+=count</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"><span class="comment"># print(conn.lrange('test',0,100))</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> scan_list(<span class="string">'test'</span>,<span class="number">5</span>):</span><br><span class="line">    print(<span class="string">'---'</span>)</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 重点</span></span><br><span class="line">lpush</span><br><span class="line">lpop</span><br><span class="line">blpop</span><br><span class="line">lrange</span><br><span class="line">llen</span><br></pre></td></tr></table></figure><h3 id="5-redsi的其他使用"><a href="#5-redsi的其他使用" class="headerlink" title="5 redsi的其他使用"></a>5 redsi的其他使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他操作</span></span><br><span class="line"><span class="comment"># conn.delete('list1')</span></span><br><span class="line"><span class="comment"># ret=conn.delete('hash1')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.exists('hash2')</span></span><br><span class="line"><span class="comment"># ret=conn.keys('cache*')  #查询以cache开头的所有key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.expire('hash2',2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.type('name3')</span></span><br><span class="line"><span class="comment"># ret=conn.type('test')</span></span><br><span class="line"><span class="comment"># ret=conn.type('test')</span></span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><h2 id="二-Go客户端"><a href="#二-Go客户端" class="headerlink" title="二 Go客户端"></a>二 Go客户端</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一-Python客户端&quot;&gt;&lt;a href=&quot;#一-Python客户端&quot; class=&quot;headerlink&quot; title=&quot;一 Python客户端&quot;&gt;&lt;/a&gt;一 Python客户端&lt;/h2&gt;&lt;h3 id=&quot;1-Python操作Redis之普通连接&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[缓存的使用和优化]</title>
    <link href="http://yoursite.com/2020/06/21/%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/21/%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/</id>
    <published>2020-06-21T01:12:43.000Z</published>
    <updated>2020-06-21T01:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-缓存的收益与成本"><a href="#一-缓存的收益与成本" class="headerlink" title="一 缓存的收益与成本"></a>一 缓存的收益与成本</h2><h3 id="1-1-受益"><a href="#1-1-受益" class="headerlink" title="1.1 受益"></a>1.1 受益</h3><blockquote><p>1 加速读写</p><p>2 降低后端负载：后端服务器通过前端缓存降低负载，业务端使用redis降低后端mysql负载</p></blockquote><h3 id="1-2-成本"><a href="#1-2-成本" class="headerlink" title="1.2 成本"></a>1.2 成本</h3><blockquote><p>1 数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</p><p>2 代码维护成本：多了一层缓存逻辑</p><p>3 运维成本：比如使用了Redis Cluster</p></blockquote><h3 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a>1.3 使用场景</h3><blockquote><p>1 降低后端负载：对高消耗的sql，join结果集/分组统计的结果做缓存</p><p>2 加速请求响应：利用redis优化io响应时间</p><p>3 大量写合并为批量写：如计数器先redis累加再批量写入db</p></blockquote><h2 id="二-缓存更新策略"><a href="#二-缓存更新策略" class="headerlink" title="二 缓存更新策略"></a>二 缓存更新策略</h2><blockquote><p>1 LRU/LFU/FIFO算法剔除：例如maxmemory-policy(到了最大内存，对应的应对策略)</p><p>​        LRU -Least Recently Used,没有被使用时间最长的</p><p>​        LFU -Least Frequenty User,一定时间段内使用次数最少的</p><p>​        FIFO -First In First Out</p><p>​        LIRS (Low Inter-reference Recency  Set)是一个页替换算法，相比于LRU(Least Recently  Used)和很多其他的替换算法，LIRS具有较高的性能。这是通过使用两次访问同一页之间的距离（本距离指中间被访问了多少非重复块）作为一种尺度去动态地将访问页排序，从而去做一个替换的选择</p><p>配置文件中设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment"># LRU配置</span></span><br><span class="line">&gt;maxmemory-policy:volatile-lru</span><br><span class="line">&gt;（<span class="number">1</span>）noeviction: 如果内存使用达到了maxmemory，client还要继续写入数据，那么就直接报错给客户端</span><br><span class="line">&gt;（<span class="number">2</span>）allkeys-lru: 就是我们常说的LRU算法，移除掉最近最少使用的那些keys对应的数据，ps最长用的策略</span><br><span class="line">&gt;（<span class="number">3</span>）volatile-lru: 也是采取LRU算法，但是仅仅针对那些设置了指定存活时间（TTL）的key才会清理掉</span><br><span class="line">&gt;（<span class="number">4</span>）allkeys-random: 随机选择一些key来删除掉</span><br><span class="line">&gt;（<span class="number">5</span>）volatile-random: 随机选择一些设置了TTL的key来删除掉</span><br><span class="line">&gt;（<span class="number">6</span>）volatile-ttl: 移除掉部分keys，选择那些TTL时间比较短的keys</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment"># LFU配置 Redis4.0之后为maxmemory_policy淘汰策略添加了两个LFU模式：</span></span><br><span class="line">&gt;volatile-lfu：对有过期时间的key采用LFU淘汰算法</span><br><span class="line">&gt;allkeys-lfu：对全部key采用LFU淘汰算法</span><br><span class="line">&gt;<span class="comment"># 还有2个配置可以调整LFU算法：</span></span><br><span class="line">&gt;lfu-log-factor <span class="number">10</span></span><br><span class="line">&gt;lfu-decay-time <span class="number">1</span></span><br><span class="line">&gt;<span class="comment"># lfu-log-factor可以调整计数器counter的增长速度，lfu-log-factor越大，counter增长的越慢。</span></span><br><span class="line">&gt;<span class="comment"># lfu-decay-time是一个以分钟为单位的数值，可以调整counter的减少速度</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>2 超时剔除：例如expire，设置过期时间</p><p>3 主动更新：开发控制生命周期</p></blockquote><table><thead><tr><th>策略</th><th>一致性</th><th>维护成本</th></tr></thead><tbody><tr><td>LRU/LIRS算法剔除</td><td>最差</td><td>低</td></tr><tr><td>超时剔除</td><td>较差</td><td>低</td></tr><tr><td>主动更新</td><td>强</td><td>高</td></tr></tbody></table><p>1 低一致性：最大内存和淘汰策略</p><p>2 高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底</p><h2 id="三-缓存粒度控制"><a href="#三-缓存粒度控制" class="headerlink" title="三 缓存粒度控制"></a>三 缓存粒度控制</h2><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gduwyfg8mgj30bm0dsjt6.jpg" alt="image-20200416002406930" style="zoom:50%;" /><blockquote><p>1 从mysql获取用户信息：select * from user where id=100</p><p>2 设置用户信息缓存：set user:100 <code>select * from user where id=100</code></p><p>3 缓存粒度：</p><p>​    缓存全部属性</p><p>​    缓存部分重要属性</p></blockquote><p>1 通用性：全量属性更好</p><p>2 占用空间：部分属性更好</p><p>3 代码维护：表面上全量属性更好</p><h2 id="四-缓存穿透，缓存击穿，缓存雪崩"><a href="#四-缓存穿透，缓存击穿，缓存雪崩" class="headerlink" title="四 缓存穿透，缓存击穿，缓存雪崩"></a>四 缓存穿透，缓存击穿，缓存雪崩</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">###  缓存穿透</span></span><br><span class="line"><span class="comment">#描述：</span></span><br><span class="line">缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“<span class="number">-1</span>”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</span><br><span class="line"><span class="comment">#解决方案：</span></span><br><span class="line"><span class="number">1</span> 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=<span class="number">0</span>的直接拦截；</span><br><span class="line"><span class="number">2</span> 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如<span class="number">30</span>秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</span><br><span class="line"><span class="number">3</span> 通过布隆过滤器实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 缓存击穿</span></span><br><span class="line"><span class="comment">#描述：</span></span><br><span class="line">缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</span><br><span class="line"><span class="comment">#解决方案：</span></span><br><span class="line">设置热点数据永远不过期。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">### 缓存雪崩</span></span><br><span class="line"><span class="comment">#描述：</span></span><br><span class="line">缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</span><br><span class="line"><span class="comment"># 解决方案：</span></span><br><span class="line"><span class="number">1</span> 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</span><br><span class="line"><span class="number">2</span> 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</span><br><span class="line"><span class="number">3</span> 设置热点数据永远不过期。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      缓存的收益与成本,加速读写,降低后端负载：后端服务器通过前端缓存降低负载，业务端使用redis降低后端mysql负载...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[Sentinel]</title>
    <link href="http://yoursite.com/2020/06/21/Sentinel/"/>
    <id>http://yoursite.com/2020/06/21/Sentinel/</id>
    <published>2020-06-21T00:58:43.000Z</published>
    <updated>2020-06-21T00:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-主从复制高可用"><a href="#一-主从复制高可用" class="headerlink" title="一 主从复制高可用"></a>一 主从复制高可用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主从复制存在的问题：</span></span><br><span class="line"><span class="comment">#1 主从复制，主节点发生故障，需要做故障转移，可以手动转移：让其中一个slave变成master</span></span><br><span class="line"><span class="comment">#2 主从复制，只能主写数据，所以写能力和存储能力有限</span></span><br></pre></td></tr></table></figure><h2 id="二-架构说明"><a href="#二-架构说明" class="headerlink" title="二 架构说明"></a>二 架构说明</h2><p>可以做故障判断，故障转移，通知客户端（其实是一个进程），客户端直接连接sentinel的地址</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadzuhodicj30oe0dc0y9.jpg" alt="image-20191229230823911" style="zoom:50%;" /><p>1 多个sentinel发现并确认master有问题</p><p>2 选举触一个sentinel作为领导</p><p>3 选取一个slave作为新的master</p><p>4 通知其余slave成为新的master的slave</p><p>5 通知客户端主从变化</p><p>6 等待老的master复活成为新master的slave</p><h2 id="三-安装配置"><a href="#三-安装配置" class="headerlink" title="三 安装配置"></a>三 安装配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 配置开启主从节点</span><br><span class="line"><span class="number">2</span> 配置开启sentinel监控主节点（sentinel是特殊的redis）</span><br><span class="line"><span class="number">3</span> 应该是多台机器</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置开启sentinel监控主节点</span></span><br><span class="line">mkdir -p redis4/conf redis4/data redis5/conf redis5/data redis6/data redis6/conf</span><br><span class="line"></span><br><span class="line">vi sentinel.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">port <span class="number">26379</span></span><br><span class="line">daemonize yes</span><br><span class="line">dir data</span><br><span class="line">protected-mode no</span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">logfile <span class="string">"redis_sentinel.log"</span></span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -p <span class="number">26379</span>:<span class="number">26379</span> --name redis_26379 -v /home/redis4/conf/sentinel.conf:/etc/redis/sentinel.conf -v /home/redis4/data:/data -d redis redis-sentinel /etc/redis/sentinel.conf</span><br><span class="line"></span><br><span class="line">docker run -p <span class="number">26378</span>:<span class="number">26379</span> --name redis_26378 -v /home/redis5/conf/sentinel.conf:/etc/redis/sentinel.conf -v /home/redis5/data:/data -d redis redis-sentinel /etc/redis/sentinel.conf</span><br><span class="line"></span><br><span class="line">docker run -p <span class="number">26377</span>:<span class="number">26379</span> --name redis_26377 -v /home/redis6/conf/sentinel.conf:/etc/redis/sentinel.conf -v /home/redis6/data:/data -d redis redis-sentinel /etc/redis/sentinel.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis-sentinel sentinel.conf</span><br><span class="line"></span><br><span class="line">info</span><br><span class="line">配置会重写，自动发现slave</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span></span><br><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line">告诉sentinel去监听地址为ip:port的一个master，这里的master-name可以自定义，quorum是一个数字，指明当有多少个sentinel认为一个master失效时，master才算真正失效</span><br><span class="line"></span><br><span class="line">sentinel auth-<span class="keyword">pass</span> &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">设置连接master和slave时的密码，注意的是sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同。</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </span><br><span class="line">这个配置项指定了需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的。 单位是毫秒，默认为<span class="number">30</span>秒</span><br><span class="line"></span><br><span class="line">sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; </span><br><span class="line">这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 <span class="number">1</span> 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"></span><br><span class="line">sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">failover-timeout 可以用在以下这些方面：     </span><br><span class="line"><span class="number">1.</span> 同一个sentinel对同一个master两次failover之间的间隔时间。   </span><br><span class="line"><span class="number">2.</span> 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。    </span><br><span class="line"><span class="number">3.</span>当想要取消一个正在进行的failover所需要的时间。    </span><br><span class="line"><span class="number">4.</span>当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 搭一个一主两从</span><br><span class="line"><span class="comment">#创建三个配置文件：</span></span><br><span class="line"><span class="comment">#第一个是主配置文件</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line">port <span class="number">6379</span></span><br><span class="line">dir <span class="string">"/opt/soft/redis/data"</span></span><br><span class="line">logfile “<span class="number">6379.l</span>og”</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二个是从配置文件</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis2.pid</span><br><span class="line">port <span class="number">6378</span></span><br><span class="line">dir <span class="string">"/opt/soft/redis/data2"</span></span><br><span class="line">logfile “<span class="number">6378.l</span>og”</span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"><span class="comment">#第三个是从配置文件</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis3.pid</span><br><span class="line">port <span class="number">6377</span></span><br><span class="line">dir <span class="string">"/opt/soft/redis/data3"</span></span><br><span class="line">logfile “<span class="number">6377.l</span>og”</span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#把三个redis服务都启动起来</span></span><br><span class="line">./src/redis-server redis_6379.conf</span><br><span class="line">./src/redis-server redis_6378.conf</span><br><span class="line">./src/redis-server redis_6377.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 搭建哨兵</span><br><span class="line"><span class="comment"># sentinel.conf这个文件</span></span><br><span class="line"><span class="comment"># 把哨兵也当成一个redis服务器</span></span><br><span class="line">创建三个配置文件分别叫sentinel_26379.conf sentinel_26378.conf  sentinel_26377.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前路径下创建 data1 data2 data3 个文件夹</span></span><br><span class="line"><span class="comment">#内容如下(需要修改端口，文件地址日志文件名字)</span></span><br><span class="line">port <span class="number">26379</span></span><br><span class="line">daemonize yes</span><br><span class="line">dir ./data3</span><br><span class="line">protected-mode no</span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">logfile <span class="string">"redis_sentinel3.log"</span></span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动三个哨兵</span></span><br><span class="line">./src/redis-sentinel sentinel_26379.conf</span><br><span class="line">./src/redis-sentinel sentinel_26378.conf</span><br><span class="line">./src/redis-sentinel sentinel_26377.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆哨兵</span></span><br><span class="line">./src/redis-cli -p <span class="number">26377</span></span><br><span class="line"><span class="comment"># 输入 info</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看哨兵的配置文件被修改了，自动生成的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主动停掉主redis 6379，哨兵会自动选择一个从库作为主库</span></span><br><span class="line">redis-cli -p <span class="number">6379</span></span><br><span class="line">shutdown</span><br><span class="line"><span class="comment">#等待原来的主库启动，该主库会变成从库</span></span><br></pre></td></tr></table></figure><h2 id="四-客户端连接"><a href="#四-客户端连接" class="headerlink" title="四 客户端连接"></a>四 客户端连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> redis.sentinel <span class="keyword">import</span> Sentinel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接哨兵服务器(主机名也可以用域名)</span></span><br><span class="line"><span class="comment"># 10.0.0.101:26379</span></span><br><span class="line">sentinel = Sentinel([(<span class="string">'10.0.0.101'</span>, <span class="number">26379</span>),</span><br><span class="line">                     (<span class="string">'10.0.0.101'</span>, <span class="number">26378</span>),</span><br><span class="line">                     (<span class="string">'10.0.0.101'</span>, <span class="number">26377</span>)</span><br><span class="line">     ],</span><br><span class="line">                    socket_timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(sentinel)</span><br><span class="line"><span class="comment"># 获取主服务器地址</span></span><br><span class="line">master = sentinel.discover_master(<span class="string">'mymaster'</span>)</span><br><span class="line">print(master)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取从服务器地址</span></span><br><span class="line">slave = sentinel.discover_slaves(<span class="string">'mymaster'</span>)</span><br><span class="line">print(slave)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取主服务器进行写入</span></span><br><span class="line"><span class="comment"># master = sentinel.master_for('mymaster', socket_timeout=0.5)</span></span><br><span class="line"><span class="comment"># w_ret = master.set('foo', 'bar')</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># slave = sentinel.slave_for('mymaster', socket_timeout=0.5)</span></span><br><span class="line"><span class="comment"># r_ret = slave.get('foo')</span></span><br><span class="line"><span class="comment"># print(r_ret)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      主从复制存在的问题：主从复制，主节点发生故障，需要做故障转移，可以手动转移：让其中一个slave变成master,主从复制，只能主写数据，所以写能力和存储能力有限...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[主从复制原理与优化]</title>
    <link href="http://yoursite.com/2020/06/21/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/21/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2020-06-21T00:55:43.000Z</published>
    <updated>2020-06-21T00:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-什么是主从复制"><a href="#一-什么是主从复制" class="headerlink" title="一 什么是主从复制"></a>一 什么是主从复制</h2><p>机器故障；容量瓶颈；QPS瓶颈</p><p>一主一从，一主多从</p><p>做读写分离</p><p>做数据副本</p><p>扩展数据性能</p><p>一个maskter可以有多个slave</p><p>一个slave只能有一个master</p><p>数据流向是单向的，从master到slave</p><h2 id="二-复制的-配置"><a href="#二-复制的-配置" class="headerlink" title="二 复制的 配置"></a>二 复制的 配置</h2><h3 id="2-1-slave-命令"><a href="#2-1-slave-命令" class="headerlink" title="2.1 slave 命令"></a>2.1 slave 命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6380</span>是从，<span class="number">6379</span>是主</span><br><span class="line"></span><br><span class="line">在<span class="number">6380</span>上执行（去从库配置，配置主库）</span><br><span class="line"></span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="comment">#异步</span></span><br><span class="line">slaveof no one <span class="comment">#取消复制，不会把之前的数据清除</span></span><br></pre></td></tr></table></figure><h3 id="2-2-配置文件"><a href="#2-2-配置文件" class="headerlink" title="2.2 配置文件"></a>2.2 配置文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">slaveof ip port <span class="comment">#配置从节点ip和端口</span></span><br><span class="line">slave-read-only yes <span class="comment">#从节点只读，因为可读可写，数据会乱</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">mkdir -p redis1/conf redis1/data redis2/conf redis2/data redis3/conf redis3/data</span></span><br><span class="line"><span class="string">vim redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">daemonize no</span></span><br><span class="line"><span class="string">pidfile redis.pid</span></span><br><span class="line"><span class="string">bind 0.0.0.0</span></span><br><span class="line"><span class="string">protected-mode no</span></span><br><span class="line"><span class="string">port 6379</span></span><br><span class="line"><span class="string">timeout 0</span></span><br><span class="line"><span class="string">logfile redis.log</span></span><br><span class="line"><span class="string">dbfilename dump.rdb</span></span><br><span class="line"><span class="string">dir /data</span></span><br><span class="line"><span class="string">slaveof 10.0.0.101 6379</span></span><br><span class="line"><span class="string">slave-read-only yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cp redis.conf /home/redis2/conf/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker run -p 6379:6379 --name redis_6379 -v /home/redis1/conf/redis.conf:/etc/redis/redis.conf -v /home/redis1/data:/data -d redis redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker run -p 6378:6379 --name redis_6378 -v /home/redis2/conf/redis.conf:/etc/redis/redis.conf -v /home/redis2/data:/data -d redis redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker run -p 6377:6379 --name redis_6377 -v /home/redis3/conf/redis.conf:/etc/redis/redis.conf -v /home/redis3/data:/data -d redis redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">info replication</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="四-故障处理"><a href="#四-故障处理" class="headerlink" title="四 故障处理"></a>四 故障处理</h2><p>slave故障</p><p>master故障</p><h2 id="五-复制常见问题"><a href="#五-复制常见问题" class="headerlink" title="五 复制常见问题"></a>五 复制常见问题</h2><p>1 读写分离</p><p>读流量分摊到从节点</p><p>可能遇到问题：复制数据延迟，读到过期数据，从节点故障</p><p>2 主从配置不一致</p><p>maxmemory不一致：丢失数据</p><p>数据结构优化参数：主节点做了优化，从节点没有设置优化，会出现一些问题</p><p>3 规避全量复制</p><p>第一次全量复制，不可避免：小主节点，低峰(夜间)</p><p>节点运行id不匹配：主节点重启(运行id变化)</p><p>复制挤压缓冲区不足：增大复制缓冲区大小，rel_backlog_size</p><p>4 规避复制风暴</p><p>单主节点复制风暴，主节点重启，所有从节点复制</p>]]></content>
    
    <summary type="html">
    
      什么是主从复制,一主一从，一主多从,做读写分离做数据副本,扩展数据性能,一个maskter可以有多个slave,一个slave只能有一个master,数据流向是单向的...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[使用常见问题]</title>
    <link href="http://yoursite.com/2020/06/21/%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/06/21/%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-20T23:55:43.000Z</published>
    <updated>2020-06-20T23:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-子进程开销和优化"><a href="#一-子进程开销和优化" class="headerlink" title="一 子进程开销和优化"></a>一 子进程开销和优化</h2><p>1 cpu</p><p>开销：rdb和aof文件生成，属于cpu密集型</p><p>优化：不做cpu绑定，不和cpu密集型的服务一起部署</p><p>2 内存</p><p>开销：fork内存开销，copy-on-write，</p><p>优化：单机部署尽量少重写</p><p> 3 硬盘</p><p>开销：aof和rdb写入，可以结合分析工具使用</p><p>优化：</p><p>1 不要和高硬盘负载的服务部署在一起：存储服务，消息队列</p><p>2 在aof重写期间，不要对aof进行追加：no-appendfsync-on-rewrite=yes</p><p>3 根据写入量决定磁盘类型：例如ssd</p><p>4 单机多实例持久化考虑分盘</p><h2 id="二-fork操作"><a href="#二-fork操作" class="headerlink" title="二 fork操作"></a>二 fork操作</h2><p>1 fork是同步操作</p><p>2 与内存量嘻嘻相关：内存越大，耗时越长，跟机型也有关系</p><p>3 info：latest_fok_usec:查看持久化执行时间</p><p>改善fork</p><p>1 有限使用无机或高效支持fork操作的虚拟化技术</p><p>2 控制redis实例最大可用内存：maxmemory</p><p>3 合理配置linux内存分配策略</p><p>4 降低fork频率，例如放宽aof重写自动触发时机，不必要的全量复制</p><h2 id="三-aof追加阻塞"><a href="#三-aof追加阻塞" class="headerlink" title="三 aof追加阻塞"></a>三 aof追加阻塞</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadtfor4exj30hu0ke434.jpg" alt="image-20191229192629198"></p><p>aof阻塞：看日志定位</p><p>info Persistence：每次阻塞一次就会+1</p>]]></content>
    
    <summary type="html">
    
      子进程开销和优化,cpu开销：rdb和aof文件生成，属于cpu密集型,cpu优化：不做cpu绑定，不和cpu密集型的服务一起部署...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[持久化]</title>
    <link href="http://yoursite.com/2020/06/21/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/21/%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-06-20T23:52:23.000Z</published>
    <updated>2020-06-20T23:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-持久化的作用"><a href="#一-持久化的作用" class="headerlink" title="一 持久化的作用"></a>一 持久化的作用</h2><h3 id="1-1-什么是持久化"><a href="#1-1-什么是持久化" class="headerlink" title="1.1 什么是持久化"></a>1.1 什么是持久化</h3><p>redis的所有数据保存在内存中，对数据的更新将异步的保存到硬盘上</p><h3 id="1-2-持久化的实现方式"><a href="#1-2-持久化的实现方式" class="headerlink" title="1.2 持久化的实现方式"></a>1.2 持久化的实现方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">快照：某时某刻数据的一个完成备份，</span><br><span class="line">-mysql的Dump</span><br><span class="line">    -redis的RDB</span><br><span class="line">写日志：任何操作记录日志，要恢复数据，只要把日志重新走一遍即可</span><br><span class="line">-mysql的 Binlog</span><br><span class="line">    -Hhase的 HLog</span><br><span class="line">    -Redis的 AOF</span><br></pre></td></tr></table></figure><h2 id="二-RDB"><a href="#二-RDB" class="headerlink" title="二 RDB"></a>二 RDB</h2><h3 id="2-1-什么是RDB"><a href="#2-1-什么是RDB" class="headerlink" title="2.1 什么是RDB"></a>2.1 什么是RDB</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga9zt9svljj30oo0d644s.jpg" alt="image-20191226120500154"></p><h3 id="2-2-触发机制-主要三种方式"><a href="#2-2-触发机制-主要三种方式" class="headerlink" title="2.2 触发机制-主要三种方式"></a>2.2 触发机制-主要三种方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">save(同步)</span></span><br><span class="line"><span class="string">1 客户端执行save命令----》redis服务端----》同步创建RDB二进制文件</span></span><br><span class="line"><span class="string">2 会造成redis的阻塞（数据量非常大的时候）</span></span><br><span class="line"><span class="string">3 文件策略：如果老的RDB存在，会替换老的</span></span><br><span class="line"><span class="string">4 复杂度 o(n)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bgsave(异步，Backgroud saving started)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1 客户端执行save命令----》redis服务端----》异步创建RDB二进制文件（fork函数生成一个子进程（fork会阻塞reids），执行createRDB，执行成功，返回给reids消息）</span></span><br><span class="line"><span class="string">2 此时访问redis，会正常响应客户端</span></span><br><span class="line"><span class="string">3 文件策略：跟save相同，如果老的RDB存在，会替换老的</span></span><br><span class="line"><span class="string">4 复杂度 o(n)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">自动（通过配置）</span></span><br><span class="line"><span class="string">配置   seconds   changes</span></span><br><span class="line"><span class="string">save   900        1</span></span><br><span class="line"><span class="string">save   300        10</span></span><br><span class="line"><span class="string">save   60         10000</span></span><br><span class="line"><span class="string">如果60s中改变了1w条数据，自动生成rdb</span></span><br><span class="line"><span class="string">如果300s中改变了10条数据，自动生成rdb</span></span><br><span class="line"><span class="string">如果900s中改变了1条数据，自动生成rdb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">以上三条符合任意一条，就自动生成rdb，内部使用bgsave</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置：</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span> <span class="comment">#配置一条</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span> <span class="comment">#配置一条</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span> <span class="comment">#配置一条</span></span><br><span class="line">dbfilename dump.rdb  <span class="comment">#rdb文件的名字，默认为dump.rdb</span></span><br><span class="line">dir ./ <span class="comment">#rdb文件存在当前目录</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#如果bgsave出现错误，是否停止写入，默认为yes</span></span><br><span class="line">rdbcompression yes <span class="comment">#采用压缩格式</span></span><br><span class="line">rdbchecksum yes <span class="comment">#是否对rdb文件进行校验和检验</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最佳配置</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span> </span><br><span class="line">save <span class="number">300</span> <span class="number">10</span> </span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span> </span><br><span class="line">dbfilename dump-$&#123;port&#125;.rdb  <span class="comment">#以端口号作为文件名，可能一台机器上很多reids，不会乱</span></span><br><span class="line">dir /bigdiskpath <span class="comment">#保存路径放到一个大硬盘位置目录</span></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#出现错误停止</span></span><br><span class="line">rdbcompression yes <span class="comment">#压缩</span></span><br><span class="line">rdbchecksum yes <span class="comment">#校验</span></span><br></pre></td></tr></table></figure><h3 id="2-3-触发机制-不容忽略的方式"><a href="#2-3-触发机制-不容忽略的方式" class="headerlink" title="2.3 触发机制-不容忽略的方式"></a>2.3 触发机制-不容忽略的方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 全量复制 <span class="comment">#没有执行save和bgsave没有添加rdb策略，还会生成rdb文件，如果开启主从复制，主会自动生成rdb</span></span><br><span class="line"><span class="number">2</span> debug reload <span class="comment">#debug级别的重启，不会将内存中的数据清空</span></span><br><span class="line"><span class="number">3</span> shutdown save<span class="comment">#关闭会出发rdb的生成</span></span><br></pre></td></tr></table></figure><h3 id="2-4-试验"><a href="#2-4-试验" class="headerlink" title="2.4 试验"></a>2.4 试验</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三-AOF"><a href="#三-AOF" class="headerlink" title="三 AOF"></a>三 AOF</h3><h3 id="3-1-RDB问题"><a href="#3-1-RDB问题" class="headerlink" title="3.1 RDB问题"></a>3.1 RDB问题</h3><p>耗时，耗性能：</p><p>不可控，可能会丢失数据</p><h3 id="3-2-AOF介绍"><a href="#3-2-AOF介绍" class="headerlink" title="3.2 AOF介绍"></a>3.2 AOF介绍</h3><p>客户端每写入一条命令，都记录一条日志，放到日志文件中，如果出现宕机，可以将数据完全恢复</p><h3 id="3-3-AOF的三种策略"><a href="#3-3-AOF的三种策略" class="headerlink" title="3.3 AOF的三种策略"></a>3.3 AOF的三种策略</h3><p>日志不是直接写到硬盘上，而是先放在缓冲区，缓冲区根据一些策略，写到硬盘上</p><p>always：redis–》写命令刷新的缓冲区—》每条命令fsync到硬盘—》AOF文件</p><p>everysec（默认值）：redis——》写命令刷新的缓冲区—》每秒把缓冲区fsync到硬盘–》AOF文件</p><p>no:redis——》写命令刷新的缓冲区—》操作系统决定，缓冲区fsync到硬盘–》AOF文件</p><table><thead><tr><th>命令</th><th>always</th><th>everysec</th><th>no</th></tr></thead><tbody><tr><td>优点</td><td>不丢失数据</td><td>每秒一次fsync，丢失1秒数据</td><td>不用管</td></tr><tr><td>缺点</td><td>IO开销大，一般的sata盘只有几百TPS</td><td>丢1秒数据</td><td>不可控</td></tr></tbody></table><h3 id="3-4-AOF-重写"><a href="#3-4-AOF-重写" class="headerlink" title="3.4 AOF 重写"></a>3.4 AOF 重写</h3><p>随着命令的逐步写入，并发量的变大， AOF文件会越来越大，通过AOF重写来解决该问题</p><table><thead><tr><th>原生AOF</th><th>AOF重写</th></tr></thead><tbody><tr><td>set hello world<br/>set hello java<br/>set hello hehe<br/>incr counter<br/>incr counter<br/>rpush mylist a<br/>rpush mylist b<br/>rpush mylist c<br/>过期数据</td><td>set hello hehe<br/>set counter 2<br/>rpush mylist a b c</td></tr></tbody></table><p>本质就是把过期的，无用的，重复的，可以优化的命令，来优化</p><p>这样可以减少磁盘占用量，加速恢复速度</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>bgrewriteaof：</p><p>客户端向服务端发送bgrewriteaof命令，服务端会起一个fork进程，完成AOF重写</p><h4 id="AOF重写配置："><a href="#AOF重写配置：" class="headerlink" title="AOF重写配置："></a>AOF重写配置：</h4><table><thead><tr><th>配置名</th><th>含义</th></tr></thead><tbody><tr><td>auto-aof-rewrite-min-size</td><td>AOF文件重写需要尺寸</td></tr><tr><td>auto-aof-rewrite-percentage</td><td>AOF文件增长率</td></tr></tbody></table><table><thead><tr><th>统计名</th><th>含义</th></tr></thead><tbody><tr><td>aof_current_size</td><td>AOF当前尺寸（单位：字节）</td></tr><tr><td>aof_base_size</td><td>AOF上次启动和重写的尺寸（单位：字节）</td></tr></tbody></table><p>自动触发时机（两个条件同时满足）：</p><p>aof_current_size&gt;auto-aof-rewrite-min-size：当前尺寸大于重写需要尺寸</p><p>(aof_current_size-aof_base_size)/aof_base_size&gt;auto-aof-rewrite-percentage:（增长率）当前尺寸减去上次重写的尺寸，除以上次重写的尺寸如果大于配置中的增长率</p><h4 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadsmknx2sj30fy0hw78l.jpg" alt="image-20191229185839519"></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes <span class="comment">#将该选项设置为yes，打开</span></span><br><span class="line">appendfilename <span class="string">"appendonly-$&#123;port&#125;.aof"</span> <span class="comment">#文件保存的名字</span></span><br><span class="line">appendfsync everysec <span class="comment">#采用第二种策略</span></span><br><span class="line">dir /bigdiskpath <span class="comment">#存放的路径</span></span><br><span class="line">no-appendfsync-on-rewrite yes <span class="comment">#在aof重写的时候，是否要做aof的append操作，因为aof重写消耗性能，磁盘消耗，正常aof写磁盘有一定的冲突，这段期间的数据，允许丢失</span></span><br></pre></td></tr></table></figure><h3 id="3-5-AOF-重写演示"><a href="#3-5-AOF-重写演示" class="headerlink" title="3.5 AOF 重写演示"></a>3.5 AOF 重写演示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四-RDB和AOF的选择"><a href="#四-RDB和AOF的选择" class="headerlink" title="四 RDB和AOF的选择"></a>四 RDB和AOF的选择</h2><h3 id="4-1-rdb和aof的比较"><a href="#4-1-rdb和aof的比较" class="headerlink" title="4.1 rdb和aof的比较"></a>4.1 rdb和aof的比较</h3><table><thead><tr><th>命令</th><th>rdb</th><th>aof</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高(挂掉重启，会加载aof的数据)</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table><h3 id="4-2-rdb最佳策略"><a href="#4-2-rdb最佳策略" class="headerlink" title="4.2  rdb最佳策略"></a>4.2  rdb最佳策略</h3><p>rdb关掉，主从操作时</p><p>集中管理：按天，按小时备份数据</p><p>主从配置，从节点打开</p><h3 id="4-3-aof最佳策略"><a href="#4-3-aof最佳策略" class="headerlink" title="4.3 aof最佳策略"></a>4.3 aof最佳策略</h3><p>开：缓存和存储，大部分情况都打开，</p><p>aof重写集中管理</p><p>everysec：通过每秒刷新的策略</p><h3 id="4-4-最佳策略"><a href="#4-4-最佳策略" class="headerlink" title="4.4 最佳策略"></a>4.4 最佳策略</h3><p>小分片：每个redis的最大内存为4g</p><p>缓存或存储：根据特性，使用不通策略</p><p>时时监控硬盘，内存，负载网络等</p><p>有足够内存</p>]]></content>
    
    <summary type="html">
    
      什么是持久化,redis的所有数据保存在内存中，对数据的更新将异步的保存到硬盘上,持久化的实现方式,快照：某时某刻数据的一个完成备份...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[高级用法]</title>
    <link href="http://yoursite.com/2020/06/21/%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/21/%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</id>
    <published>2020-06-20T23:45:33.000Z</published>
    <updated>2020-06-20T23:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-慢查询"><a href="#一-慢查询" class="headerlink" title="一 慢查询"></a>一 慢查询</h2><h3 id="1-1-生命周期"><a href="#1-1-生命周期" class="headerlink" title="1.1 生命周期"></a>1.1 生命周期</h3><p>我们配置一个时间，如果查询时间超过了我们设置的时间，我们就认为这是一个慢查询.</p><p>慢查询发生在第三阶段</p><p>客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga8r6p7tpej30z80k2afq.jpg" alt="image-20191225102102218"></p><h3 id="1-2-两个配置"><a href="#1-2-两个配置" class="headerlink" title="1.2 两个配置"></a>1.2 两个配置</h3><h4 id="1-2-1-slowlog-max-len"><a href="#1-2-1-slowlog-max-len" class="headerlink" title="1.2.1 slowlog-max-len"></a>1.2.1 slowlog-max-len</h4><p>慢查询是一个先进先出的队列</p><p>固定长度</p><p>保存在内存中</p><h4 id="1-2-2-slowlog-max-len"><a href="#1-2-2-slowlog-max-len" class="headerlink" title="1.2.2 slowlog-max-len"></a>1.2.2 slowlog-max-len</h4><p>慢查询阈值（单位：微秒）</p><p>slowlog-log-slower-than=0，记录所有命令</p><p>slowlog-log-slower-than &lt;0,不记录任何命令</p><h4 id="1-2-3-配置方法"><a href="#1-2-3-配置方法" class="headerlink" title="1.2.3 配置方法"></a>1.2.3 配置方法</h4><p><strong>1 默认配置</strong></p><p>config get slowlog-max-len=128</p><p>Config get slowly-log-slower-than=10000</p><p><strong>2 修改配置文件重启</strong></p><p><strong>3 动态配置</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置记录所有命令</span></span><br><span class="line">config set slowlog-log-slower-than <span class="number">0</span></span><br><span class="line"><span class="comment"># 最多记录100条</span></span><br><span class="line">config set slowlog-max-len <span class="number">100</span></span><br><span class="line"><span class="comment"># 持久化到本地配置文件</span></span><br><span class="line">config rewrite</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">config set slowlog-max-len 1000</span></span><br><span class="line"><span class="string">config set slowlog-log-slower-than 1000</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="1-3-三个命令"><a href="#1-3-三个命令" class="headerlink" title="1.3 三个命令"></a>1.3 三个命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">slowlog get [n]  <span class="comment">#获取慢查询队列</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">日志由4个属性组成：</span></span><br><span class="line"><span class="string">1）日志的标识id</span></span><br><span class="line"><span class="string">2）发生的时间戳</span></span><br><span class="line"><span class="string">3）命令耗时</span></span><br><span class="line"><span class="string">4）执行的命令和参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">slowlog len <span class="comment">#获取慢查询队列长度</span></span><br><span class="line"></span><br><span class="line">slowlog reset <span class="comment">#清空慢查询队列</span></span><br></pre></td></tr></table></figure><h3 id="1-4-经验"><a href="#1-4-经验" class="headerlink" title="1.4 经验"></a>1.4 经验</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> slowlog-max-len 不要设置过大，默认<span class="number">10</span>ms，通常设置<span class="number">1</span>ms</span><br><span class="line"><span class="number">2</span> slowlog-log-slower-than不要设置过小，通常设置<span class="number">1000</span>左右</span><br><span class="line"><span class="number">3</span> 理解命令生命周期</span><br><span class="line"><span class="number">4</span> 定期持久化慢查询</span><br></pre></td></tr></table></figure><h2 id="二-pipeline"><a href="#二-pipeline" class="headerlink" title="二 pipeline"></a>二 pipeline</h2><h3 id="2-1-什么是pipeline-管道"><a href="#2-1-什么是pipeline-管道" class="headerlink" title="2.1 什么是pipeline(管道)"></a>2.1 什么是pipeline(管道)</h3><p>Redis的pipeline(管道)功能在命令行中没有，但redis是支持pipeline的，而且在各个语言版的client中都有相应的实现</p><p>将一批命令，批量打包，在redis服务端批量计算(执行)，然后把结果批量返回</p><p>1次pipeline(n条命令)=1次网络时间+n次命令时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline期间将“独占”链接，此期间将不能进行非“管道”类型的其他操作，直到pipeline关闭；如果你的pipeline的指令集很庞大，为了不干扰链接中的其他操作，你可以为pipeline操作新建Client链接，让pipeline和其他正常操作分离在<span class="number">2</span>个client中。不过pipeline事实上所能容忍的操作个数，和socket-output缓冲区大小/返回结果的数据尺寸都有很大的关系；同时也意味着每个redis-server同时所能支撑的pipeline链接的个数，也是有限的，这将受限于server的物理内存或网络接口的缓冲能力</span><br></pre></td></tr></table></figure><h3 id="2-2-客户端实现"><a href="#2-2-客户端实现" class="headerlink" title="2.2 客户端实现"></a>2.2 客户端实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'10.211.55.4'</span>, port=<span class="number">6379</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"><span class="comment"># pipe = r.pipeline(transaction=False)</span></span><br><span class="line"><span class="comment">#创建pipeline</span></span><br><span class="line">pipe = r.pipeline(transaction=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#开启事务</span></span><br><span class="line">pipe.multi()</span><br><span class="line">pipe.set(<span class="string">'name'</span>, <span class="string">'lqz'</span>)</span><br><span class="line"><span class="comment">#其他代码，可能出异常</span></span><br><span class="line"></span><br><span class="line">pipe.set(<span class="string">'role'</span>, <span class="string">'nb'</span>)</span><br><span class="line"> </span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure><h3 id="2-3-与原生操作对比"><a href="#2-3-与原生操作对比" class="headerlink" title="2.3 与原生操作对比"></a>2.3 与原生操作对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过pipeline提交的多次命令，在服务端执行的时候，可能会被拆成多次执行，而mget等操作，是一次性执行的，所以，pipeline执行的命令并非原子性的</span><br></pre></td></tr></table></figure><h3 id="2-4-使用建议"><a href="#2-4-使用建议" class="headerlink" title="2.4 使用建议"></a>2.4 使用建议</h3><p>1 注意每次pipeline携带的数据量</p><p>2 pipeline每次只能作用在一个Redis的节点上</p><p>3 M(mset，mget….)操作和pipeline的区别</p><h2 id="三-发布订阅"><a href="#三-发布订阅" class="headerlink" title="三 发布订阅"></a>三 发布订阅</h2><h3 id="3-1-角色"><a href="#3-1-角色" class="headerlink" title="3.1 角色"></a>3.1 角色</h3><p><strong>发布者/订阅者/频道</strong></p><p>发布者发布了消息，所有的订阅者都可以收到，就是生产者消费者模型（后订阅了，无法获取历史消息）</p><h3 id="3-2-模型"><a href="#3-2-模型" class="headerlink" title="3.2 模型"></a>3.2 模型</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga923qyr2uj31xp0u0jwt.jpg" alt="image-20191225163659941"></p><h3 id="3-3-API"><a href="#3-3-API" class="headerlink" title="3.3 API"></a>3.3 API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">publish channel message <span class="comment">#发布命令</span></span><br><span class="line">publish souhu:tv <span class="string">"hello world"</span> <span class="comment">#在souhu:tv频道发布一条hello world  返回订阅者个数</span></span><br><span class="line"></span><br><span class="line">subscribe [channel] <span class="comment">#订阅命令，可以订阅一个或多个</span></span><br><span class="line">subscribe souhu:tv  <span class="comment">#订阅sohu:tv频道</span></span><br><span class="line"></span><br><span class="line">unsubscribe [channel] <span class="comment">#取消订阅一个或多个频道</span></span><br><span class="line">unsubscribe sohu:tv  <span class="comment">#取消订阅sohu:tv频道</span></span><br><span class="line">    </span><br><span class="line">psubscribe [pattern...] <span class="comment">#订阅模式匹配</span></span><br><span class="line">psubscribe c*  <span class="comment">#订阅以c开头的频道</span></span><br><span class="line"></span><br><span class="line">unpsubscribe [pattern...] <span class="comment">#按模式退订指定频道</span></span><br><span class="line"></span><br><span class="line">pubsub channels <span class="comment">#列出至少有一个订阅者的频道,列出活跃的频道</span></span><br><span class="line"></span><br><span class="line">pubsub numsub [channel...] <span class="comment">#列出给定频道的订阅者数量</span></span><br><span class="line"></span><br><span class="line">pubsub numpat <span class="comment">#列出被订阅模式的数量</span></span><br></pre></td></tr></table></figure><h3 id="3-4-发布订阅和消息队列"><a href="#3-4-发布订阅和消息队列" class="headerlink" title="3.4 发布订阅和消息队列"></a>3.4 发布订阅和消息队列</h3><p>发布订阅数全收到，消息队列有个抢的过程，只有一个抢到</p><h2 id="四-Bitmap位图"><a href="#四-Bitmap位图" class="headerlink" title="四 Bitmap位图"></a>四 Bitmap位图</h2><h3 id="4-1-位图是什么"><a href="#4-1-位图是什么" class="headerlink" title="4.1 位图是什么"></a>4.1 位图是什么</h3><p>下面是字符串big对应的二进制（b是98）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga93bk259dj313y0isajp.jpg" alt="image-20191225172053447"></p><h3 id="4-2-相关命令"><a href="#4-2-相关命令" class="headerlink" title="4.2 相关命令"></a>4.2 相关命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">set hello big <span class="comment">#放入key位hello 值为big的字符串</span></span><br><span class="line">getbit hello <span class="number">0</span> <span class="comment">#取位图的第0个位置，返回0</span></span><br><span class="line">getbit hello <span class="number">1</span> <span class="comment">#取位图的第1个位置，返回1 如上图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##我们可以直接操纵位</span></span><br><span class="line">setbit key offset value <span class="comment">#给位图指定索引设置值</span></span><br><span class="line">setbit hello <span class="number">7</span> <span class="number">1</span> <span class="comment">#把hello的第7个位置设为1 这样，big就变成了cig</span></span><br><span class="line"></span><br><span class="line">setbit test <span class="number">50</span> <span class="number">1</span> <span class="comment">#test不存在，在key为test的value的第50位设为1，那其他位都以0补</span></span><br><span class="line"></span><br><span class="line">bitcount key [start end] <span class="comment">#获取位图指定范围(start到end,单位为字节,注意按字节一个字节8个bit为，如果不指定就是获取全部)位值为1的个数</span></span><br><span class="line"></span><br><span class="line">bitop op destkey key [key...] <span class="comment">#做多个Bitmap的and(交集)/or(并集)/not(非)/xor(异或)，操作并将结果保存在destkey中 </span></span><br><span class="line">bitop <span class="keyword">and</span> after_lqz lqz lqz2 <span class="comment">#把lqz和lqz2按位与操作，放到after_lqz中</span></span><br><span class="line"></span><br><span class="line">bitpos key targetBit start end <span class="comment">#计算位图指定范围(start到end，单位为字节，如果不指定是获取全部)第一个偏移量对应的值等于targetBit的位置</span></span><br><span class="line">bitpos lqz <span class="number">1</span> <span class="comment">#big 对应位图中第一个1的位置，在第二个位置上，由于从0开始返回1</span></span><br><span class="line">bitpos lqz <span class="number">0</span> <span class="comment">#big 对应位图中第一个0的位置，在第一个位置上，由于从0开始返回0</span></span><br><span class="line">bitpos lqz <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="comment">#返回9：返回从第一个字节到第二个字节之间 第一个1的位置，看上图，为9</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga93gnif6ej310q0iuwpy.jpg" alt="image-20191225172547661"></p><h3 id="4-3-独立用户统计"><a href="#4-3-独立用户统计" class="headerlink" title="4.3 独立用户统计"></a>4.3 独立用户统计</h3><p>1 使用set和Bitmap对比</p><p>2 1亿用户，5千万独立（1亿用户量，约5千万人访问，统计活跃用户数量）</p><table><thead><tr><th>数据类型</th><th>每个userid占用空间</th><th>需要存储用户量</th><th>全部内存量</th></tr></thead><tbody><tr><td>set</td><td>32位(假设userid是整形，占32位)</td><td>5千万</td><td>32位*5千万=200MB</td></tr><tr><td>bitmap</td><td>1位</td><td>1亿</td><td>1位*1亿=12.5MB</td></tr></tbody></table><p>假设有10万独立用户，使用位图还是占用12.5mb，使用set需要32位*1万=4MB</p><h3 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5 总结"></a>4.5 总结</h3><p>1 位图类型是string类型，最大512M</p><p>2 使用setbit时偏移量如果过大，会有较大消耗</p><p>3 位图不是绝对好用，需要合理使用</p><h2 id="五-HyperLogLog"><a href="#五-HyperLogLog" class="headerlink" title="五 HyperLogLog"></a>五 HyperLogLog</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><p>基于HyperLogLog算法：极小的空间完成独立数量统计</p><p>本质还是字符串</p><h3 id="5-2-三个命令"><a href="#5-2-三个命令" class="headerlink" title="5.2 三个命令"></a>5.2 三个命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element <span class="comment">#向hyperloglog添加元素,可以同时添加多个</span></span><br><span class="line">pfcount key <span class="comment">#计算hyperloglog的独立总数</span></span><br><span class="line">pfmerge destroy sourcekey1 sourcekey2<span class="comment">#合并多个hyperloglog，把sourcekey1和sourcekey2合并为destroy</span></span><br><span class="line"></span><br><span class="line">pfadd uuids <span class="string">"uuid1"</span> <span class="string">"uuid2"</span> <span class="string">"uuid3"</span> <span class="string">"uuid4"</span> <span class="comment">#向uuids中添加4个uuid</span></span><br><span class="line">pfcount uuids <span class="comment">#返回4</span></span><br><span class="line">pfadd uuids <span class="string">"uuid1"</span> <span class="string">"uuid5"</span><span class="comment">#有一个之前存在了，其实只把uuid5添加了</span></span><br><span class="line">pfcount uuids <span class="comment">#返回5</span></span><br><span class="line"></span><br><span class="line">pfadd uuids1 <span class="string">"uuid1"</span> <span class="string">"uuid2"</span> <span class="string">"uuid3"</span> <span class="string">"uuid4"</span></span><br><span class="line">pfadd uuids2 <span class="string">"uuid3"</span> <span class="string">"uuid4"</span> <span class="string">"uuid5"</span> <span class="string">"uuid6"</span></span><br><span class="line">pfmerge uuidsall uuids1 uuids2 <span class="comment">#合并</span></span><br><span class="line">pfcount uuidsall <span class="comment">#统计个数 返回6</span></span><br></pre></td></tr></table></figure><h3 id="5-3-内存消耗-amp-总结"><a href="#5-3-内存消耗-amp-总结" class="headerlink" title="5.3 内存消耗&amp;总结"></a>5.3 内存消耗&amp;总结</h3><p>百万级别独立用户统计，百万条数据只占15k</p><p>错误率 0.81%</p><p>无法取出单条数据，只能统计个数</p><h2 id="六-GEO"><a href="#六-GEO" class="headerlink" title="六 GEO"></a>六 GEO</h2><h3 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h3><p>GEO（地理信息定位）：存储经纬度，计算两地距离，范围等</p><p>北京：116.28，39.55</p><p>天津：117.12，39.08</p><p>可以计算天津到北京的距离，天津周围50km的城市，外卖等</p><h3 id="6-2-5个城市纬度"><a href="#6-2-5个城市纬度" class="headerlink" title="6.2 5个城市纬度"></a>6.2 5个城市纬度</h3><table><thead><tr><th>城市</th><th>经度</th><th>纬度</th><th>简称</th></tr></thead><tbody><tr><td>北京</td><td>116.28</td><td>39.55</td><td>beijing</td></tr><tr><td>天津</td><td>117.12</td><td>39.08</td><td>tianjin</td></tr><tr><td>石家庄</td><td>114.29</td><td>38.02</td><td>shijiazhuang</td></tr><tr><td>唐山</td><td>118.01</td><td>39.38</td><td>tangshan</td></tr><tr><td>保定</td><td>115.29</td><td>38.51</td><td>baoding</td></tr></tbody></table><h3 id="6-3-相关命令"><a href="#6-3-相关命令" class="headerlink" title="6.3 相关命令"></a>6.3 相关命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member <span class="comment">#增加地理位置信息</span></span><br><span class="line">geoadd cities:locations <span class="number">116.28</span> <span class="number">39.55</span> beijing <span class="comment">#把北京地理信息天津到cities:locations中</span></span><br><span class="line">geoadd cities:locations <span class="number">117.12</span> <span class="number">39.08</span> tianjin</span><br><span class="line">geoadd cities:locations <span class="number">114.29</span> <span class="number">38.02</span> shijiazhuang</span><br><span class="line">geoadd cities:locations <span class="number">118.01</span> <span class="number">39.38</span> tangshan</span><br><span class="line">geoadd cities:locations <span class="number">115.29</span> <span class="number">38.51</span> baoding</span><br><span class="line">    </span><br><span class="line">geopos key member <span class="comment">#获取地理位置信息</span></span><br><span class="line">geopos cities:locations beijing <span class="comment">#获取北京地理信息</span></span><br><span class="line"></span><br><span class="line">geodist key member1 member2 [unit]<span class="comment">#获取两个地理位置的距离 unit:m(米) km(千米) mi(英里) ft(尺)</span></span><br><span class="line">geodist cities:locations beijing tianjin km <span class="comment">#北京到天津的距离，89公里</span></span><br><span class="line"></span><br><span class="line">georadius key logitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line"></span><br><span class="line">georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line"><span class="comment">#获取指定位置范围内的地理位置信息集合</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">withcoord:返回结果中包含经纬度</span></span><br><span class="line"><span class="string">withdist：返回结果中包含距离中心节点位置</span></span><br><span class="line"><span class="string">withhash：返回解雇中包含geohash</span></span><br><span class="line"><span class="string">COUNT count：指定返回结果的数量</span></span><br><span class="line"><span class="string">asc|desc：返回结果按照距离中心店的距离做升序/降序排列</span></span><br><span class="line"><span class="string">store key：将返回结果的地理位置信息保存到指定键</span></span><br><span class="line"><span class="string">storedist key：将返回结果距离中心点的距离保存到指定键</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">georadiusbymember cities:locations beijing <span class="number">150</span> km</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1) "beijing"</span></span><br><span class="line"><span class="string">2) "tianjin"</span></span><br><span class="line"><span class="string">3) "tangshan"</span></span><br><span class="line"><span class="string">4) "baoding"</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>3.2以后版本才有</p><p>geo本质时zset类型</p><p>可以使用zset的删除，删除指定member：zrem </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member #增加地理位置信息</span><br><span class="line">geoadd cities:locations 116.28 39.55 beijing #把北京地理信息天津到cities:locations中</span><br><span class="line">geoadd cities:locations 117.12 39.08 tianjin</span><br><span class="line">geoadd cities:locations 114.29 38.02 shijiazhuang</span><br><span class="line">geoadd cities:locations 118.01 39.38 tangshan</span><br><span class="line">geoadd cities:locations 115.29 38.51 baoding</span><br><span class="line">    </span><br><span class="line">geopos key member #获取地理位置信息</span><br><span class="line">geopos cities:locations beijing #获取北京地理信息</span><br><span class="line"></span><br><span class="line">geodist key member1 member2 [unit]#获取两个地理位置的距离 unit:m(米) km(千米) mi(英里) ft(尺)</span><br><span class="line">geodist cities:locations beijing tianjin km #北京到天津的距离，89公里</span><br><span class="line"></span><br><span class="line">georadius key logitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line"></span><br><span class="line">georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line">#获取指定位置范围内的地理位置信息集合</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">withcoord:返回结果中包含经纬度</span><br><span class="line">withdist：返回结果中包含距离中心节点位置</span><br><span class="line">withhash：返回解雇中包含geohash</span><br><span class="line">COUNT count：指定返回结果的数量</span><br><span class="line">asc|desc：返回结果按照距离中心店的距离做升序&#x2F;降序排列</span><br><span class="line">store key：将返回结果的地理位置信息保存到指定键</span><br><span class="line">storedist key：将返回结果距离中心点的距离保存到指定键</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">georadiusbymember cities:locations beijing 150 km</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">1) &quot;beijing&quot;</span><br><span class="line">2) &quot;tianjin&quot;</span><br><span class="line">3) &quot;tangshan&quot;</span><br><span class="line">4) &quot;baoding&quot;</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure><h3 id="6-4-总结-1"><a href="#6-4-总结-1" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>3.2以后版本才有</p><p>geo本质时zset类型</p><p>可以使用zset的删除，删除指定member：zrem </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member #增加地理位置信息</span><br><span class="line">geoadd cities:locations 116.28 39.55 beijing #把北京地理信息天津到cities:locations中</span><br><span class="line">geoadd cities:locations 117.12 39.08 tianjin</span><br><span class="line">geoadd cities:locations 114.29 38.02 shijiazhuang</span><br><span class="line">geoadd cities:locations 118.01 39.38 tangshan</span><br><span class="line">geoadd cities:locations 115.29 38.51 baoding</span><br><span class="line">    </span><br><span class="line">geopos key member #获取地理位置信息</span><br><span class="line">geopos cities:locations beijing #获取北京地理信息</span><br><span class="line"></span><br><span class="line">geodist key member1 member2 [unit]#获取两个地理位置的距离 unit:m(米) km(千米) mi(英里) ft(尺)</span><br><span class="line">geodist cities:locations beijing tianjin km #北京到天津的距离，89公里</span><br><span class="line"></span><br><span class="line">georadius key logitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line"></span><br><span class="line">georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line">#获取指定位置范围内的地理位置信息集合</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">withcoord:返回结果中包含经纬度</span><br><span class="line">withdist：返回结果中包含距离中心节点位置</span><br><span class="line">withhash：返回解雇中包含geohash</span><br><span class="line">COUNT count：指定返回结果的数量</span><br><span class="line">asc|desc：返回结果按照距离中心店的距离做升序&#x2F;降序排列</span><br><span class="line">store key：将返回结果的地理位置信息保存到指定键</span><br><span class="line">storedist key：将返回结果距离中心点的距离保存到指定键</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">georadiusbymember cities:locations beijing 150 km</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">1) &quot;beijing&quot;</span><br><span class="line">2) &quot;tianjin&quot;</span><br><span class="line">3) &quot;tangshan&quot;</span><br><span class="line">4) &quot;baoding&quot;</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure><h3 id="6-4-总结-2"><a href="#6-4-总结-2" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>3.2以后版本才有</p><p>geo本质时zset类型</p><p>可以使用zset的删除，删除指定member：zrem cities:locations beijing</p>]]></content>
    
    <summary type="html">
    
      生命周期,我们配置一个时间，如果查询时间超过了我们设置的时间，我们就认为这是一个慢查询,慢查询发生在第三阶段,客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[API的使用]</title>
    <link href="http://yoursite.com/2020/06/21/API%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/21/API%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-20T23:42:33.000Z</published>
    <updated>2020-06-20T23:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-通用命令"><a href="#一-通用命令" class="headerlink" title="一 通用命令"></a>一 通用命令</h2><h3 id="1-1-通用命令"><a href="#1-1-通用命令" class="headerlink" title="1.1 通用命令"></a>1.1 通用命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####1-keys </span></span><br><span class="line"><span class="comment">#打印出所有key</span></span><br><span class="line">keys * </span><br><span class="line"><span class="comment">#打印出所有以he开头的key</span></span><br><span class="line">keys he*</span><br><span class="line"><span class="comment">#打印出所有以he开头，第三个字母是h到l的范围</span></span><br><span class="line">keys he[h-l]</span><br><span class="line"><span class="comment">#三位长度，以he开头，？表示任意一位</span></span><br><span class="line">keys he？</span><br><span class="line"><span class="comment">#keys命令一般不在生产环境中使用，生产环境key很多，时间复杂度为o(n),用scan命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####2-dbsize   计算key的总数</span></span><br><span class="line">dbsize <span class="comment">#redis内置了计数器，插入删除值该计数器会更改，所以可以在生产环境使用，时间复杂度是o(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###3-exists key 时间复杂度o(1)</span></span><br><span class="line"><span class="comment">#设置a</span></span><br><span class="line">set a b</span><br><span class="line"><span class="comment">#查看a是否存在</span></span><br><span class="line">exists a</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="comment">#存在返回1 不存在返回0</span></span><br><span class="line"><span class="comment">###4-del key  时间复杂度o(1)</span></span><br><span class="line">删除成功返回<span class="number">1</span>，key不存在返回<span class="number">0</span></span><br><span class="line"><span class="comment">###5-expire key seconds  时间复杂度o(1)</span></span><br><span class="line">expire name <span class="number">3</span> <span class="comment">#3s 过期</span></span><br><span class="line">ttl name  <span class="comment">#查看name还有多长时间过期</span></span><br><span class="line">persist name <span class="comment">#去掉name的过期时间</span></span><br><span class="line"><span class="comment">###6-type key  时间复杂度o(1)</span></span><br><span class="line">type name <span class="comment">#查看name类型，返回string</span></span><br></pre></td></tr></table></figure><h3 id="1-2-数据结构和内部编码"><a href="#1-2-数据结构和内部编码" class="headerlink" title="1.2 数据结构和内部编码"></a>1.2 数据结构和内部编码</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga7mt5tzjnj30q20pgn5n.jpg" alt="image-20191224110401405"></p><h3 id="1-3-单线程架构"><a href="#1-3-单线程架构" class="headerlink" title="1.3 单线程架构"></a>1.3 单线程架构</h3><h4 id="1-3-1-单线程架构，"><a href="#1-3-1-单线程架构，" class="headerlink" title="1.3.1 单线程架构，"></a>1.3.1 单线程架构，</h4><p>一个瞬间只会执行一条命令</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga7mzj7rpoj30wu0egq5t.jpg" alt="image-20191224111010657"></p><h4 id="1-3-2-单线程为什么这么快"><a href="#1-3-2-单线程为什么这么快" class="headerlink" title="1.3.2 单线程为什么这么快"></a>1.3.2 单线程为什么这么快</h4><p>1 纯内存</p><p>2 非阻塞IO （epoll），自身实现了事件处理，不在网络io上浪费过多时间</p><p>3 避免线程间切换和竞态消耗</p><h4 id="1-3-3-注意"><a href="#1-3-3-注意" class="headerlink" title="1.3.3 注意"></a>1.3.3 注意</h4><p>1 一次只运行一条命令</p><p>2 拒绝长慢命令</p><p>​    -keys，flushall,flushdb,慢的lua脚本，mutil/exec，operate，big value</p><p>3 其实不是单线程（在做持久化是另外的线程）</p><p>​    -fysnc file descriptor</p><p>​    -close file descriptor</p><h2 id="二-字符串类型"><a href="#二-字符串类型" class="headerlink" title="二 字符串类型"></a>二 字符串类型</h2><h3 id="2-1-字符串键值结构"><a href="#2-1-字符串键值结构" class="headerlink" title="2.1 字符串键值结构"></a>2.1 字符串键值结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">key          value</span><br><span class="line">hello        world      可以很复杂，如json格式字符串</span><br><span class="line">counter      <span class="number">1</span>          数字类型</span><br><span class="line">bits         <span class="number">10101010</span>   二进制（位图）</span><br><span class="line"><span class="comment">#字符串value不能大于512m，一般建议100k以内</span></span><br><span class="line"><span class="comment">#用于缓存，计数器，分布式锁...</span></span><br></pre></td></tr></table></figure><h3 id="2-2-常用命令"><a href="#2-2-常用命令" class="headerlink" title="2.2 常用命令"></a>2.2 常用命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###1---基本使用get，set，del</span></span><br><span class="line">get name       <span class="comment">#时间复杂度 o(1)</span></span><br><span class="line">set name lqz   <span class="comment">#时间复杂度 o(1)</span></span><br><span class="line"><span class="keyword">del</span> name       <span class="comment">#时间复杂度 o(1)</span></span><br><span class="line"><span class="comment">###2---其他使用incr,decr,incrby,decrby</span></span><br><span class="line">incr age  <span class="comment">#对age这个key的value值自增1</span></span><br><span class="line">decr age  <span class="comment">#对age这个key的value值自减1</span></span><br><span class="line">incrby age <span class="number">10</span>  <span class="comment">#对age这个key的value值增加10</span></span><br><span class="line">decrby age <span class="number">10</span>  <span class="comment">#对age这个key的value值减10</span></span><br><span class="line"><span class="comment">#统计网站访问量（单线程无竞争，天然适合做计数器）</span></span><br><span class="line"><span class="comment">#缓存mysql的信息（json格式）</span></span><br><span class="line"><span class="comment">#分布式id生成（多个机器同时并发着生成，不会重复）</span></span><br><span class="line"><span class="comment">###3---set，setnx，setxx</span></span><br><span class="line">set name lqz  <span class="comment">#不管key是否存在，都设置 </span></span><br><span class="line">setnx name lqz <span class="comment">#key不存在时才设置（新增操作）</span></span><br><span class="line">set name lqz nx <span class="comment">#同上</span></span><br><span class="line">set name lqz xx <span class="comment">#key存在，才设置（更新操作）</span></span><br><span class="line"><span class="comment">###4---mget mset</span></span><br><span class="line">mget key1 key2 key3     <span class="comment">#批量获取key1，key2.。。时间复杂度o(n)</span></span><br><span class="line">mset key1 value1 key2 value2 key3 value3    <span class="comment">#批量设置时间复杂度o(n)</span></span><br><span class="line"><span class="comment">#n次get和mget的区别</span></span><br><span class="line"><span class="comment">#n次get时间=n次命令时间+n次网络时间</span></span><br><span class="line"><span class="comment">#mget时间=1次网络时间+n次命令时间</span></span><br><span class="line"><span class="comment">###5---其他：getset，append，strlen</span></span><br><span class="line">getset name lqznb <span class="comment">#设置新值并返回旧值 时间复杂度o(1)</span></span><br><span class="line">append name <span class="number">666</span> <span class="comment">#将value追加到旧的value 时间复杂度o(1)</span></span><br><span class="line">strlen name  <span class="comment">#计算字符串长度(注意中文)  时间复杂度o(1)</span></span><br><span class="line"><span class="comment">###6---其他：incrybyfloat,getrange,setrange</span></span><br><span class="line">increbyfloat age <span class="number">3.5</span>  <span class="comment">#为age自增3.5，传负值表示自减 时间复杂度o(1)</span></span><br><span class="line">getrange key start end <span class="comment">#获取字符串制定下标所有的值  时间复杂度o(1)</span></span><br><span class="line">setrange key index value <span class="comment">#从指定index开始设置value值  时间复杂度o(1)</span></span><br></pre></td></tr></table></figure><h2 id="三-哈希类型"><a href="#三-哈希类型" class="headerlink" title="三 哈希类型"></a>三 哈希类型</h2><p>###3.1 哈希值结构</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga7otagi3lj30p00f2q8l.jpg" alt="image-20191224121323414"></p><h3 id="3-2-重要api"><a href="#3-2-重要api" class="headerlink" title="3.2 重要api"></a>3.2 重要api</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###1---hget,hset,hdel</span></span><br><span class="line">hget key field  <span class="comment">#获取hash key对应的field的value 时间复杂度为 o(1)</span></span><br><span class="line">hset key field value <span class="comment">#设置hash key对应的field的value值 时间复杂度为 o(1)</span></span><br><span class="line">hdel key field <span class="comment">#删除hash key对应的field的值 时间复杂度为 o(1)</span></span><br><span class="line"><span class="comment">#测试</span></span><br><span class="line">hset user:<span class="number">1</span>:info age <span class="number">23</span></span><br><span class="line">hget user:<span class="number">1</span>:info ag</span><br><span class="line">hset user:<span class="number">1</span>:info name lqz</span><br><span class="line">hgetall user:<span class="number">1</span>:info</span><br><span class="line">hdel user:<span class="number">1</span>:info age</span><br><span class="line"><span class="comment">###2---hexists,hlen</span></span><br><span class="line">hexists key field  <span class="comment">#判断hash key 是否存在field 时间复杂度为 o(1)</span></span><br><span class="line">hlen key   <span class="comment">#获取hash key field的数量  时间复杂度为 o(1)</span></span><br><span class="line">hexists user:<span class="number">1</span>:info name</span><br><span class="line">hlen user:<span class="number">1</span>:info  <span class="comment">#返回数量</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">###3---hmget，hmset</span></span><br><span class="line">hmget key field1 field2 ...fieldN  <span class="comment">#批量获取hash key 的一批field对应的值  时间复杂度是o(n)</span></span><br><span class="line">hmset key field1 value1 field2 value2  <span class="comment">#批量设置hash key的一批field value 时间复杂度是o(n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###4--hgetall,hvals，hkeys</span></span><br><span class="line">hgetall key  <span class="comment">#返回hash key 对应的所有field和value  时间复杂度是o(n)</span></span><br><span class="line">hvals key   <span class="comment">#返回hash key 对应的所有field的value  时间复杂度是o(n)</span></span><br><span class="line">hkeys key   <span class="comment">#返回hash key对应的所有field  时间复杂度是o(n)</span></span><br><span class="line"><span class="comment">###小心使用hgetall</span></span><br><span class="line"><span class="comment">##1 计算网站每个用户主页的访问量</span></span><br><span class="line">hincrby user:<span class="number">1</span>:info pageview count</span><br><span class="line"><span class="comment">##2 缓存mysql的信息，直接设置hash格式</span></span><br></pre></td></tr></table></figure><h3 id="3-3-hash-vs-string"><a href="#3-3-hash-vs-string" class="headerlink" title="3.3 hash vs string"></a>3.3 hash vs string</h3><h4 id="3-3-1相似的api"><a href="#3-3-1相似的api" class="headerlink" title="3.3.1相似的api"></a>3.3.1相似的api</h4><table><thead><tr><th>get</th><th>hget</th></tr></thead><tbody><tr><td>set /sentnx</td><td>hset  hsetnx</td></tr><tr><td>del</td><td>hdel</td></tr><tr><td>incr incrby dear decrby</td><td>hincrby</td></tr><tr><td>mset</td><td>hmset</td></tr><tr><td>mget</td><td>hmget</td></tr></tbody></table><h4 id="3-3-2-缓存三种方案"><a href="#3-3-2-缓存三种方案" class="headerlink" title="3.3.2 缓存三种方案"></a>3.3.2 缓存三种方案</h4><p>直接json格式字符串</p><p>每个字段一个key</p><p>使用hash操作</p><h3 id="3-4-其他操作"><a href="#3-4-其他操作" class="headerlink" title="3.4 其他操作"></a>3.4 其他操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##其他操作 hsetnx，hincrby，hincrbyfloat</span></span><br><span class="line">hsetnx key field value <span class="comment">#设置hash key对应field的value（如果field已存在，则失败），时间复杂度o(1)</span></span><br><span class="line">hincrby key field intCounter <span class="comment">#hash key 对英的field的value自增intCounter 时间复杂度o(1)</span></span><br><span class="line">hincrbyfloat key field floatCounter <span class="comment">#hincrby 浮点数 时间复杂度o(1)</span></span><br></pre></td></tr></table></figure><h2 id="四-列表类型"><a href="#四-列表类型" class="headerlink" title="四 列表类型"></a>四 列表类型</h2><h3 id="4-1-列表特点"><a href="#4-1-列表特点" class="headerlink" title="4.1 列表特点"></a>4.1 列表特点</h3><p>有序队列，可以从左侧添加，右侧添加，可以重复，可以从左右两边弹出</p><h4 id="4-2-API操作"><a href="#4-2-API操作" class="headerlink" title="4.2 API操作"></a>4.2 API操作</h4><h5 id="4-2-1-插入操作"><a href="#4-2-1-插入操作" class="headerlink" title="4.2.1 插入操作"></a>4.2.1 插入操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rpush 从右侧插入</span></span><br><span class="line">rpush key value1 value2 ...valueN  <span class="comment">#时间复杂度为o(1~n)</span></span><br><span class="line"><span class="comment">#lpush 从左侧插入</span></span><br><span class="line"><span class="comment">#linsert</span></span><br><span class="line">linsert key before|after value newValue   <span class="comment">#从元素value的前或后插入newValue 时间复杂度o(n) ，需要遍历列表</span></span><br><span class="line">linsert listkey before b java</span><br><span class="line">linsert listkey after b php</span><br></pre></td></tr></table></figure><h5 id="4-2-2-删除操作"><a href="#4-2-2-删除操作" class="headerlink" title="4.2.2 删除操作"></a>4.2.2 删除操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lpop key <span class="comment">#从列表左侧弹出一个item 时间复杂度o(1)</span></span><br><span class="line"></span><br><span class="line">rpop key <span class="comment">#从列表右侧弹出一个item 时间复杂度o(1)</span></span><br><span class="line"></span><br><span class="line">lrem key count value</span><br><span class="line"><span class="comment">#根据count值，从列表中删除所有value相同的项 时间复杂度o(n)</span></span><br><span class="line"><span class="number">1</span> count&gt;<span class="number">0</span> 从左到右，删除最多count个value相等的项</span><br><span class="line"><span class="number">2</span> count&lt;<span class="number">0</span> 从右向左，删除最多 Math.abs(count)个value相等的项</span><br><span class="line"><span class="number">3</span> count=<span class="number">0</span> 删除所有value相等的项</span><br><span class="line">lrem listkey <span class="number">0</span> a <span class="comment">#删除列表中所有值a</span></span><br><span class="line">lrem listkey <span class="number">-1</span> c <span class="comment">#从右侧删除1个c</span></span><br><span class="line"></span><br><span class="line">ltrim key start end <span class="comment">#按照索引范围修剪列表 o(n)</span></span><br><span class="line">ltrim listkey <span class="number">1</span> <span class="number">4</span> <span class="comment">#只保留下表1--4的元素</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-查询操作"><a href="#4-2-3-查询操作" class="headerlink" title="4.2.3 查询操作"></a>4.2.3 查询操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lrange key start end <span class="comment">#包含end获取列表指定索引范围所有item  o(n)</span></span><br><span class="line">lrange listkey <span class="number">0</span> <span class="number">2</span></span><br><span class="line">lrange listkey <span class="number">1</span> <span class="number">-1</span> <span class="comment">#获取第一个位置到倒数第一个位置的元素</span></span><br><span class="line"></span><br><span class="line">lindex key index <span class="comment">#获取列表指定索引的item  o(n)</span></span><br><span class="line">lindex listkey <span class="number">0</span></span><br><span class="line">lindex listkey <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">llen key <span class="comment">#获取列表长度</span></span><br></pre></td></tr></table></figure><h4 id="4-2-3-修改操作"><a href="#4-2-3-修改操作" class="headerlink" title="4.2.3 修改操作"></a>4.2.3 修改操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lset key index newValue <span class="comment">#设置列表指定索引值为newValue o(n)</span></span><br><span class="line">lset listkey <span class="number">2</span> ppp <span class="comment">#把第二个位置设为ppp</span></span><br></pre></td></tr></table></figure><h3 id="4-3-实战"><a href="#4-3-实战" class="headerlink" title="4.3 实战"></a>4.3 实战</h3><p>实现timeLine功能，时间轴，微博关注的人，按时间轴排列，在列表中放入关注人的微博的即可</p><h3 id="4-4-其他操作"><a href="#4-4-其他操作" class="headerlink" title="4.4 其他操作"></a>4.4 其他操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">blpop key timeout <span class="comment">#lpop的阻塞版，timeout是阻塞超时时间，timeout=0为拥有不阻塞 o(1)</span></span><br><span class="line">brpop key timeout <span class="comment">#rpop的阻塞版，timeout是阻塞超时时间，timeout=0为拥有不阻塞 o(1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要实现栈的功能</span></span><br><span class="line">lpush+lpop</span><br><span class="line"><span class="comment">#实现队列功能</span></span><br><span class="line">lpush+rpop</span><br><span class="line"><span class="comment">#固定大小的列表</span></span><br><span class="line">lpush+ltrim</span><br><span class="line"><span class="comment">#消息队列</span></span><br><span class="line">lpush+brpop</span><br></pre></td></tr></table></figure><h2 id="五-集合类型"><a href="#五-集合类型" class="headerlink" title="五 集合类型"></a>五 集合类型</h2><h3 id="5-1-特点"><a href="#5-1-特点" class="headerlink" title="5.1 特点"></a>5.1 特点</h3><p>无序，无重复，集合间操作（交叉并补） </p><h3 id="5-2-API操作"><a href="#5-2-API操作" class="headerlink" title="5.2 API操作"></a>5.2 API操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sadd key element <span class="comment">#向集合key添加element（如果element存在，添加失败） o(1)</span></span><br><span class="line"></span><br><span class="line">srem key element <span class="comment">#从集合中的element移除掉 o(1)</span></span><br><span class="line"></span><br><span class="line">scard key <span class="comment">#计算集合大小</span></span><br><span class="line"></span><br><span class="line">sismember key element <span class="comment">#判断element是否在集合中</span></span><br><span class="line"></span><br><span class="line">srandmember key count <span class="comment">#从集合中随机取出count个元素，不会破坏集合中的元素</span></span><br><span class="line"></span><br><span class="line">spop key <span class="comment">#从集合中随机弹出一个元素</span></span><br><span class="line"></span><br><span class="line">smembers key <span class="comment">#获取集合中所有元素 ，无序，小心使用，会阻塞住 </span></span><br><span class="line"></span><br><span class="line">sdiff user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow  <span class="comment">#计算user:1:follow和user:2:follow的差集</span></span><br><span class="line"></span><br><span class="line">sinter user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow  <span class="comment">#计算user:1:follow和user:2:follow的交集</span></span><br><span class="line">          </span><br><span class="line">sunion user:<span class="number">1</span>:follow user:<span class="number">2</span>:follow  <span class="comment">#计算user:1:follow和user:2:follow的并集</span></span><br><span class="line">                </span><br><span class="line">sdiff|sinter|suion + store destkey... <span class="comment">#将差集，交集，并集结果保存在destkey集合中</span></span><br></pre></td></tr></table></figure><h3 id="5-3-实战"><a href="#5-3-实战" class="headerlink" title="5.3 实战"></a>5.3 实战</h3><p>抽奖系统 ：通过spop来弹出用户的id，活动取消，直接删除</p><p>点赞，点踩，喜欢等，用户如果点了赞，就把用户id放到该条记录的集合中</p><p>标签：给用户/文章等添加标签，sadd user:1:tags 标签1 标签2 标签3</p><p>给标签添加用户，关注该标签的人有哪些</p><p>共同好友：集合间的操作</p><h4 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h4><p>sadd:可以做标签相关</p><p>spop/srandmember:可以做随机数相关</p><p>sadd/sinter：社交相关</p><h2 id="六-有序集合类型"><a href="#六-有序集合类型" class="headerlink" title="六 有序集合类型"></a>六 有序集合类型</h2><h3 id="6-1-特点"><a href="#6-1-特点" class="headerlink" title="6.1 特点"></a>6.1 特点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#有一个分值字段，来保证顺序</span></span><br><span class="line">key                  score                value</span><br><span class="line">user:ranking           <span class="number">1</span>                   lqz</span><br><span class="line">user:ranking           <span class="number">99</span>                  lqz2</span><br><span class="line">user:ranking           <span class="number">88</span>                  lqz3</span><br><span class="line"><span class="comment">#集合有序集合</span></span><br><span class="line">集合：无重复元素，无序，element</span><br><span class="line">有序集合：无重复元素，有序，element+score</span><br><span class="line"><span class="comment">#列表和有序集合</span></span><br><span class="line">列表：可以重复，有序，element</span><br><span class="line">有序集合：无重复元素，有序，element+score</span><br></pre></td></tr></table></figure><h3 id="6-2-API使用"><a href="#6-2-API使用" class="headerlink" title="6.2 API使用"></a>6.2 API使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">zadd key score element <span class="comment">#score可以重复，可以多个同时添加，element不能重复 o(logN) </span></span><br><span class="line"></span><br><span class="line">zrem key element <span class="comment">#删除元素，可以多个同时删除 o(1)</span></span><br><span class="line"></span><br><span class="line">zscore key element <span class="comment">#获取元素的分数 o(1)</span></span><br><span class="line"></span><br><span class="line">zincrby key increScore element <span class="comment">#增加或减少元素的分数  o(1)</span></span><br><span class="line"></span><br><span class="line">zcard key <span class="comment">#返回元素总个数 o(1)</span></span><br><span class="line"></span><br><span class="line">zrank key element <span class="comment">#返回element元素的排名（从小到大排）</span></span><br><span class="line"></span><br><span class="line">zrange key <span class="number">0</span> <span class="number">-1</span> <span class="comment">#返回排名，不带分数  o(log(n)+m) n是元素个数，m是要获取的值</span></span><br><span class="line">zrange player:rank <span class="number">0</span> <span class="number">-1</span> withscores <span class="comment">#返回排名，带分数</span></span><br><span class="line"></span><br><span class="line">zrangebyscore key minScore maxScore <span class="comment">#返回指定分数范围内的升序元素 o(log(n)+m) n是元素个数，m是要获取的值</span></span><br><span class="line">zrangebyscore user:<span class="number">1</span>:ranking <span class="number">90</span> <span class="number">210</span> withscores <span class="comment">#获取90分到210分的元素</span></span><br><span class="line"></span><br><span class="line">zcount key minScore maxScore <span class="comment">#返回有序集合内在指定分数范围内的个数 o(log(n)+m)</span></span><br><span class="line"></span><br><span class="line">zremrangebyrank key start end <span class="comment">#删除指定排名内的升序元素 o(log(n)+m)</span></span><br><span class="line">zremrangebyrank user:<span class="number">1</span>:rangking <span class="number">1</span> <span class="number">2</span> <span class="comment">#删除升序排名中1到2的元素</span></span><br><span class="line">        </span><br><span class="line">zremrangebyscore key minScore maxScore <span class="comment">#删除指定分数内的升序元素 o(log(n)+m)</span></span><br><span class="line">zremrangebyscore user:<span class="number">1</span>:ranking <span class="number">90</span> <span class="number">210</span> <span class="comment">#删除分数90到210之间的元素</span></span><br></pre></td></tr></table></figure><h3 id="6-3-实战"><a href="#6-3-实战" class="headerlink" title="6.3 实战"></a>6.3 实战</h3><p>排行榜：音乐排行榜，销售榜，关注榜，游戏排行榜</p><h3 id="6-4-其他操作"><a href="#6-4-其他操作" class="headerlink" title="6.4 其他操作"></a>6.4 其他操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">zrevrank <span class="comment">#从高到低排序</span></span><br><span class="line">zrevrange <span class="comment">#从高到低排序取一定范围</span></span><br><span class="line">zrevrangebyscore <span class="comment">#返回指定分数范围内的降序元素</span></span><br><span class="line">zinterstore <span class="comment">#对两个有序集合交集</span></span><br><span class="line">zunionstore <span class="comment">#对两个有序集合求并集</span></span><br></pre></td></tr></table></figure><h3 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h3><table><thead><tr><th>操作类型</th><th>命令</th></tr></thead><tbody><tr><td>基本操作</td><td>zadd/  zrem/  zcard/  zincrby/  zscore</td></tr><tr><td>范围操作</td><td>zrange/  zrangebyscore/  zcount/  zremrangebyrank</td></tr><tr><td>集合操作</td><td>zunionstore/  zinterstore</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      通用命令,keys he,keys命令一般不在生产环境中使用，生产环境key很多，时间复杂度为o(n),用scan命令,dbsize,redis内置了计数器，插入删除值该计数器会更改，所以可以在生产环...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[Redis初识]</title>
    <link href="http://yoursite.com/2020/06/21/Redis%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2020/06/21/Redis%E5%88%9D%E8%AF%86/</id>
    <published>2020-06-20T23:31:33.000Z</published>
    <updated>2020-06-20T23:32:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-Redis初识"><a href="#第一章-Redis初识" class="headerlink" title="第一章 Redis初识"></a>第一章 Redis初识</h2><h3 id="1-1-Redis是什么"><a href="#1-1-Redis是什么" class="headerlink" title="1.1 Redis是什么"></a>1.1 Redis是什么</h3><p><strong>介绍</strong></p><p>开源：早起版本2w3千行</p><p>基于键值对的存储系统：字典形式 </p><p>多种数据结构：字符串，hash，列表，集合，有序集合</p><p>高性能，功能丰富</p><p><strong>那些公司在用</strong></p><p>github，twitter，stackoverflow，阿里，百度，微博，美团，搜狐</p><h3 id="1-2-Redis特性（8个）"><a href="#1-2-Redis特性（8个）" class="headerlink" title="1.2 Redis特性（8个）"></a>1.2 Redis特性（8个）</h3><p><strong>速度快</strong>：10w ops（每秒10w读写），数据存在内存中，c语言实现，单线程模型</p><p><strong>持久化</strong>：rdb和aof</p><p><strong>多种数据结构</strong>：</p><p>5大数据结构 </p><p>BitMaps位图：布隆过滤器   本质是 字符串</p><p>HyperLogLog：超小内存唯一值计数，12kb  HyperLogLog  本质是 字符串</p><p>GEO：地理信息定位  本质是有序集合</p><p><strong>支持多种编程语言</strong>：基于tcp通信协议，各大编程语言都支持</p><p><strong>功能丰富</strong>：发布订阅（消息） Lua脚本，事务（pipeline）</p><p><strong>简单</strong>：源代码几万行，不依赖外部库</p><p><strong>主从复制</strong>：主服务器和从服务器，主服务器可以同步到从服务器中</p><p><strong>高可用和分布式</strong>：</p><p>​    2.8版本以后使用redis-sentinel支持高可用</p><p>​    3.0版本以后支持分布式</p><h3 id="1-3-Redis单机安装"><a href="#1-3-Redis单机安装" class="headerlink" title="1.3 Redis单机安装"></a>1.3 Redis单机安装</h3><h4 id="1-3-1下载安装"><a href="#1-3-1下载安装" class="headerlink" title="1.3.1下载安装"></a>1.3.1下载安装</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">wget http://download.redis.io/releases/redis<span class="number">-5.0</span><span class="number">.7</span>.tar.gz</span><br><span class="line"><span class="comment">#解压</span></span><br><span class="line">tar -xzf redis<span class="number">-5.0</span><span class="number">.7</span>.tar.gz</span><br><span class="line"><span class="comment">#建立软连接</span></span><br><span class="line">ln -s redis<span class="number">-5.0</span><span class="number">.7</span> redis</span><br><span class="line">cd redis</span><br><span class="line">make&amp;&amp;make install</span><br><span class="line"><span class="comment">#在src目录下可以看到</span></span><br><span class="line"><span class="comment">#redis-server---&gt;redis服务器</span></span><br><span class="line"><span class="comment">#redis-cli---》redis命令行客户端</span></span><br><span class="line"><span class="comment">#redis-benchmark---》redis性能测试工具</span></span><br><span class="line"><span class="comment">#redis-check-aof---&gt;aof文件修复工具</span></span><br><span class="line"><span class="comment">#redis-check-dump---》rdb文件检查工具</span></span><br><span class="line"><span class="comment">#redis-sentinel---》sentinel服务器，哨兵</span></span><br><span class="line"><span class="comment">#redis作者对windows维护不好，window自己有安装包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####卸载redis</span></span><br><span class="line"><span class="comment"># 1、查看redis进程；</span></span><br><span class="line">ps aux|grep redis</span><br><span class="line"><span class="comment"># 2、kill掉进程；</span></span><br><span class="line">kill 进程id</span><br><span class="line"><span class="comment"># 3、进入到redis目录</span></span><br><span class="line">cd /usr/local/</span><br><span class="line"><span class="comment"># 4、删除redis对应的文件</span></span><br><span class="line">rm -f /usr/local/redis/bin/redis*</span><br><span class="line">rm -f /usr/local/bin/redis*</span><br><span class="line"><span class="comment"># 5、删除对应的文件</span></span><br><span class="line">rm -rf redis</span><br></pre></td></tr></table></figure><h4 id="1-3-2三种启动方式"><a href="#1-3-2三种启动方式" class="headerlink" title="1.3.2三种启动方式"></a>1.3.2三种启动方式</h4><h5 id="1-3-2-1-最简启动"><a href="#1-3-2-1-最简启动" class="headerlink" title="1.3.2.1 最简启动"></a>1.3.2.1 最简启动</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#最简启动</span></span><br><span class="line">redis-server</span><br><span class="line">ps -ef|grep redis  <span class="comment">#查看进程</span></span><br><span class="line">netstat -antpl|grep redis <span class="comment">#查看端口</span></span><br><span class="line">redis-cli -h ip -p port ping <span class="comment">#命令查看</span></span><br></pre></td></tr></table></figure><h5 id="1-3-2-2-动态参数启动"><a href="#1-3-2-2-动态参数启动" class="headerlink" title="1.3.2.2 动态参数启动"></a>1.3.2.2 动态参数启动</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#动态参数启动</span></span><br><span class="line">redis-serve --port <span class="number">6380</span> <span class="comment">#启动，监听6380端口</span></span><br></pre></td></tr></table></figure><h5 id="1-3-2-2-配置文件启动"><a href="#1-3-2-2-配置文件启动" class="headerlink" title="1.3.2.2 配置文件启动"></a>1.3.2.2 配置文件启动</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置文件启动（6379对应手机按键MERZ，意大利女歌手Alessia Merz的名字）</span></span><br><span class="line"><span class="comment">#####通过redis-cli连接，输入config get * 可以获得默认配置</span></span><br><span class="line"><span class="comment">#在redis目录下创建config目录，copy一个redis.conf文件</span></span><br><span class="line"><span class="comment">#daemonize--》是否是守护进程启动（no|yes）</span></span><br><span class="line"><span class="comment">#port---》端口号</span></span><br><span class="line"><span class="comment">#logfile--》redis系统日志</span></span><br><span class="line"><span class="comment">#dir--》redis工作目录</span></span><br></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看一下默认注释，把#和空格去掉</span></span><br><span class="line">cat redis.conf|grep -v <span class="string">"#"</span> |grep -v <span class="string">"^$"</span></span><br><span class="line"><span class="comment">#重定向到另一个文件</span></span><br><span class="line">cat redis.conf|grep -v <span class="string">"#"</span> |grep -v <span class="string">"^$"</span> &gt;redis<span class="number">-6382.</span>conf</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">daemonize yes #是否以守护进程启动</span></span><br><span class="line"><span class="string">pidfile /var/run/redis.pid   #进程号的位置，删除</span></span><br><span class="line"><span class="string">port 6379    #端口号</span></span><br><span class="line"><span class="string">dir "/opt/soft/redis/data"  #工作目录</span></span><br><span class="line"><span class="string">logfile “6379.log” #日志位置  </span></span><br><span class="line"><span class="string">#其他全删掉</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#在redis目录下新建data目录，用来存放书籍</span></span><br><span class="line"><span class="comment">#启动redis</span></span><br><span class="line">redis-server config/redis.conf</span><br><span class="line"><span class="comment">#查看进程</span></span><br><span class="line">ps -ef |grep redis-server |grep <span class="number">6379</span></span><br><span class="line"><span class="comment">#查看日志</span></span><br><span class="line">cd data</span><br><span class="line">cat <span class="number">6379.l</span>og</span><br></pre></td></tr></table></figure><h4 id="1-3-3-客户端连接"><a href="#1-3-3-客户端连接" class="headerlink" title="1.3.3 客户端连接"></a>1.3.3 客户端连接</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">###客户端连接###</span></span><br><span class="line">redis-cli -h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> -p <span class="number">6379</span></span><br><span class="line">ping <span class="comment">#返回PONG</span></span><br></pre></td></tr></table></figure><h4 id="1-3-4-redis返回值"><a href="#1-3-4-redis返回值" class="headerlink" title="1.3.4 redis返回值"></a>1.3.4 redis返回值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">####redis返回值</span></span><br><span class="line">状态回复：ping---》PONG</span><br><span class="line">错误回复：hget hello field ---》(error)WRONGTYPE Operation against</span><br><span class="line">整数回复：incr hello---》(integer) <span class="number">1</span></span><br><span class="line">字符串回复：get hello---》<span class="string">"world"</span></span><br><span class="line">多行字符串回复：mget hello foo---》<span class="string">"world"</span> <span class="string">"bar"</span></span><br></pre></td></tr></table></figure><h3 id="1-4-Redis典型使用场景"><a href="#1-4-Redis典型使用场景" class="headerlink" title="1.4 Redis典型使用场景"></a>1.4 Redis典型使用场景</h3><p>缓存系统：使用最广泛的就是缓存</p><p>计数器：网站访问量，转发量，评论数（文章转发，商品销量，单线程模型，不会出现并发问题）</p><p>消息队列：发布订阅，阻塞队列实现（简单的分布式，blpop：阻塞队列，生产者消费者）</p><p>排行榜：有序集合（阅读排行，点赞排行，推荐（销量高的，推荐））</p><p>社交网络：很多特效跟社交网络匹配，粉丝数，关注数</p><p>实时系统：垃圾邮件处理系统，布隆过滤器</p>]]></content>
    
    <summary type="html">
    
      Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[Redis搭建]</title>
    <link href="http://yoursite.com/2020/06/21/Redis%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/06/21/Redis%E6%90%AD%E5%BB%BA/</id>
    <published>2020-06-20T23:28:32.000Z</published>
    <updated>2020-06-20T23:28:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-redis"><a href="#3-redis" class="headerlink" title="3. redis"></a>3. redis</h1><p>window系统的redis是微软团队根据官方的linux版本高仿的</p><p>官方原版: <a href="https://redis.io/" target="_blank" rel="noopener">https://redis.io/</a></p><p>中文官网: <a href="http://www.redis.cn" target="_blank" rel="noopener">http://www.redis.cn</a></p><h2 id="3-1-redis下载和安装"><a href="#3-1-redis下载和安装" class="headerlink" title="3.1 redis下载和安装"></a>3.1 redis下载和安装</h2><p>下载地址： <a href="https://github.com/MicrosoftArchive/redis/releases" target="_blank" rel="noopener">https://github.com/MicrosoftArchive/redis/releases</a></p><p><img src="/images/867021-20190120213315530-199992307.png" alt=""></p><p><img src="/images/867021-20190120213337245-1919434508.png" alt=""></p><p><img src="/images/867021-20190120213351947-466120029.png" alt=""></p><p><img src="/images/867021-20190120213613576-1092651557.png" alt=""></p><p><img src="/images/867021-20190120213732137-1070050780.png" alt=""></p><p><img src="/images/867021-20190120213836094-663215847.png" alt=""></p><p><img src="/images/867021-20190120213850621-1280736381.png" alt=""></p><p><img src="/images/867021-20190120214101037-1456534345.png" alt=""></p><p><img src="/images/867021-20190120214000974-189830387.png" alt=""></p><p>使用以下命令启动redis服务端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server C:/tool/redis/redis.windows.conf</span><br></pre></td></tr></table></figure><p><img src="/images/1553244955947.png" alt=""></p><p>关闭上面这个cmd窗口就关闭redis服务器服务了。</p><p><strong>redis作为windows服务启动方式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server --service-install redis.windows.conf</span><br></pre></td></tr></table></figure><p>启动服务：redis-server –service-start 停止服务：redis-server –service-stop</p><p>启动内置客户端连接redis服务：</p><p><img src="/images/867021-20190120215300667-1673204066.png" alt=""></p><h2 id="3-2-redis的配置"><a href="#3-2-redis的配置" class="headerlink" title="3.2 redis的配置"></a>3.2 redis的配置</h2><p>redis 安装成功以后,window下的配置文件保存在软件 安装目录下,如果是mac或者linux,则默认安装/etc/redis/redis.conf</p><h3 id="3-2-1-redis的核心配置选项"><a href="#3-2-1-redis的核心配置选项" class="headerlink" title="3.2.1 redis的核心配置选项"></a>3.2.1 redis的核心配置选项</h3><ul><li><p>绑定ip：如果需要远程访问，可将此⾏注释，或绑定⼀个真实ip</p><blockquote><p>bind 127.0.0.1</p></blockquote></li><li><p>端⼝，默认为6379</p><blockquote><p>port 6379</p></blockquote></li><li><p>是否以守护进程运⾏[这里的配置主要是linux和mac下面需要配置的]</p><ul><li>如果以守护进程运⾏，则不会在命令⾏阻塞，类似于服务</li><li>如果以⾮守护进程运⾏，则当前终端被阻塞</li><li>设置为yes表示守护进程，设置为no表示⾮守护进程</li><li>推荐设置为yes</li></ul><blockquote><p>daemonize yes</p></blockquote></li><li><p>数据⽂件</p><blockquote><p>dbfilename dump.rdb</p></blockquote></li><li><p>数据⽂件存储路径</p><blockquote><p>dir .</p></blockquote></li><li><p>⽇志⽂件</p><blockquote><p>logfile “C:/tool/redis/redis-server.log”</p></blockquote></li><li><p>数据库，默认有16个</p><blockquote><p>database 16</p></blockquote></li><li><p>主从复制，类似于双机备份。</p><blockquote><p>slaveof</p></blockquote></li></ul><h3 id="3-2-2-Redis的使用"><a href="#3-2-2-Redis的使用" class="headerlink" title="3.2.2 Redis的使用"></a>3.2.2 Redis的使用</h3><p>Redis 是一个高性能的key-value数据格式的内存缓存，NoSQL数据库。</p><p>NOSQL：not only sql，泛指非关系型数据库。</p><p>关系型数据库: (mysql, oracle, sql server, sqlite)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 数据存放在表中，表之间有关系。</span><br><span class="line">2. 通用的SQL操作语言。</span><br><span class="line">3. 大部分支持事务。</span><br></pre></td></tr></table></figure><p>非关系型数据库[ redis，hadoop，mangoDB]:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 没有数据表的概念，不同的nosql数据库存放数据位置不同。</span><br><span class="line">2. nosql数据库没有通用的操作语言。</span><br><span class="line">3. 基本不支持事务。   redis支持简单事务</span><br></pre></td></tr></table></figure><p>redis： 内存型(数据存放在内存中)的非关系型(nosql)key-value(键值存储)数据库， 支持数据的持久化(注: 数据持久化时将数据存放到文件中，每次启动redis之后会先将文 件中数据加载到内存)，经常用来做缓存(用来缓存一些经常用到的数据，提高读写速度)。</p><p>redis是一款基于CS架构的数据库，所以redis有客户端，也有服务端。</p><p>其中，客户端可以使用python等编程语言，也可以终端命令行工具</p><p><img src="/images/1553246999266.png" alt=""></p><p>redis客户端连接服务器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h &#96;redis服务器ip&#96; -p &#96;redis服务器port&#96;</span><br></pre></td></tr></table></figure><h2 id="3-3-redis数据类型"><a href="#3-3-redis数据类型" class="headerlink" title="3.3 redis数据类型"></a>3.3 redis数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">1. string类型:</span><br><span class="line">    字符串类型是 Redis 中最为基础的数据存储类型，它在 Redis 中是二进制安全的，也就是byte类型</span><br><span class="line">    最大容量是512M。</span><br><span class="line">2. hash类型:</span><br><span class="line">        hash用于存储对象，对象的结构为属性、值，值的类型为string。</span><br><span class="line">        key:&#123;</span><br><span class="line">            域:值[这里的值只能是字符串]，</span><br><span class="line">            域:值，            </span><br><span class="line">            域:值，</span><br><span class="line">            域:值，</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">3. list类型:</span><br><span class="line">        列表的元素类型为string。</span><br><span class="line">        key:[ 值1，值2,值3..... ]</span><br><span class="line">4. set类型:</span><br><span class="line">    无序集合，元素为string类型，元素唯一不重复，没有修改操作。</span><br><span class="line">    &#123;值1,值4,值3,值5&#125;</span><br><span class="line">5. zset类型:</span><br><span class="line">    有序集合，元素为string类型，元素唯一不重复，没有修改操作。</span><br></pre></td></tr></table></figure><h3 id="3-4-string"><a href="#3-4-string" class="headerlink" title="3.4 string"></a>3.4 string</h3><p>如果设置的键不存在则为添加，如果设置的键已经存在则修改</p><ul><li><p>设置键值</p><blockquote><p>set key value</p></blockquote></li><li><p>例1：设置键为<code>name</code>值为<code>xiaoming</code>的数据</p><blockquote><p>set name xiaoming</p></blockquote></li></ul><p><img src="/images/1553478355927.png" alt=""></p><ul><li><p>设置键值及过期时间，以秒为单位</p><blockquote><p>setex key seconds value</p></blockquote></li><li><p>例2：设置键为<code>aa</code>值为<code>aa</code>过期时间为3秒的数据</p><blockquote><p>setex name 20 xiaoming</p></blockquote></li></ul><p>关于设置保存数据的有效期</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># setex 添加保存数据到redis，同时设置有效期</span><br><span class="line">格式：</span><br><span class="line">    setex key time value</span><br><span class="line"># expire 给已有的数据重新设置有效期</span><br><span class="line">格式：</span><br><span class="line">    expire key time</span><br></pre></td></tr></table></figure><ul><li><p>设置多个键值</p><blockquote><p>mset key1 value1 key2 value2 …</p></blockquote></li><li><p>例3：设置键为<code>a1</code>值为<code>python</code>、键为<code>a2</code>值为<code>java</code>、键为<code>a3</code>值为<code>c</code></p><blockquote><p>mset a1 python a2 java a3 c</p></blockquote></li><li><p>追加值</p><blockquote><p>append key value</p></blockquote></li><li><p>例4：向键为<code>a1</code>中追加值<code>haha</code></p><blockquote><p>append a1 haha</p></blockquote></li><li><p>获取：根据键获取值，如果不存在此键则返回<code>nil</code></p><blockquote><p>get key</p></blockquote></li><li><p>例5：获取键<code>name</code>的值</p><blockquote><p>get name</p></blockquote></li><li><p>根据多个键获取多个值</p><blockquote><p>mget key1 key2 …</p></blockquote></li><li><p>例6：获取键<code>a1、a2、a3</code>的值</p><blockquote><p>mget a1 a2 a3</p></blockquote></li></ul><h3 id="3-5-键操作"><a href="#3-5-键操作" class="headerlink" title="3.5 键操作"></a>3.5 键操作</h3><ul><li><p>查找键，参数⽀持正则表达式</p><blockquote><p>keys pattern</p></blockquote></li><li><p>例1：查看所有键</p><blockquote><p>keys *</p></blockquote></li><li><p>例2：查看名称中包含<code>a</code>的键</p><blockquote><p>keys a*</p></blockquote></li><li><p>判断键是否存在，如果存在返回<code>1</code>，不存在返回<code>0</code></p><blockquote><p>exists key1</p></blockquote></li><li><p>例3：判断键<code>a1</code>是否存在</p><blockquote><p>exists a1</p></blockquote></li><li><p>查看键对应的<code>value</code>的类型</p><blockquote><p>type key</p></blockquote></li><li><p>例4：查看键<code>a1</code>的值类型，为redis⽀持的五种类型中的⼀种</p><blockquote><p>type a1</p></blockquote></li><li><p>删除键及对应的值</p><blockquote><p>del key1 key2 …</p></blockquote></li><li><p>例5：删除键<code>a2、a3</code></p><blockquote><p>del a2 a3</p></blockquote></li><li><p>查看有效时间，以秒为单位</p><blockquote><p>ttl key</p></blockquote></li><li><p>例7：查看键<code>bb</code>的有效时间</p><blockquote><p>ttl bb</p></blockquote></li></ul><h3 id="3-6-hash"><a href="#3-6-hash" class="headerlink" title="3.6 hash"></a>3.6 hash</h3><p>结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">键key:&#123;</span><br><span class="line">    域field:值value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>设置单个属性</p><blockquote><p>hset key field value</p></blockquote></li><li><p>例1：设置键 <code>user</code>的属性<code>name</code>为<code>xiaohong</code></p><blockquote><p>hset user name xiaohong</p></blockquote></li><li><p>设置多个属性</p><blockquote><p>hmset key field1 value1 field2 value2 …</p></blockquote></li><li><p>例2：设置键<code>u2</code>的属性<code>name</code>为<code>xiaohong</code>、属性<code>age</code>为<code>11</code></p><blockquote><p>hmset u2 name xiaohongage 11</p></blockquote></li><li><p>获取指定键所有的属性</p><blockquote><p>hkeys key</p></blockquote></li><li><p>例3：获取键u2的所有属性</p><blockquote><p>hkeys u2</p></blockquote></li><li><p>获取⼀个属性的值</p><blockquote><p>hget key field</p></blockquote></li><li><p>例4：获取键<code>u2</code>属性<code>name</code>的值</p><blockquote><p>hget u2 name</p></blockquote></li><li><p>获取多个属性的值</p><blockquote><p>hmget key field1 field2 …</p></blockquote></li><li><p>例5：获取键<code>u2</code>属性<code>name</code>、<code>age</code>的值</p><blockquote><p>hmget u2 name age</p></blockquote></li><li><p>获取所有属性的值</p><blockquote><p>hvals key</p></blockquote></li><li><p>例6：获取键<code>u2</code>所有属性的值</p><blockquote><p>hvals u2</p></blockquote></li><li><p>删除属性，属性对应的值会被⼀起删除</p><blockquote><p>hdel key field1 field2 …</p></blockquote></li><li><p>例7：删除键<code>u2</code>的属性<code>age</code></p><blockquote><p>hdel u2 age</p></blockquote></li></ul><h3 id="3-7-list"><a href="#3-7-list" class="headerlink" title="3.7 list"></a>3.7 list</h3><p>列表的元素类型为string</p><p>按照插⼊顺序排序</p><ul><li><p>在左侧插⼊数据</p><blockquote><p>lpush key value1 value2 …</p></blockquote></li><li><p>例1：从键为<code>a1</code>的列表左侧加⼊数据<code>a 、 b 、c</code></p><blockquote><p>lpush a1 a b c</p></blockquote></li><li><p>在右侧插⼊数据</p><blockquote><p>rpush key value1 value2 …</p></blockquote></li><li><p>例2：从键为<code>a1</code>的列表右侧加⼊数据<code>0、1</code></p><blockquote><p>rpush a1 0 1</p></blockquote></li><li><p>在指定元素的前或后插⼊新元素</p><blockquote><p>linsert key before或after 现有元素 新元素</p></blockquote></li><li><p>例3：在键为<code>a1</code>的列表中元素<code>b</code>前加⼊<code>3</code></p><blockquote><p>linsert a1 before b 3</p></blockquote></li></ul><p>设置指定索引位置的元素值</p><ul><li><p>索引从左侧开始，第⼀个元素为0</p></li><li><p>索引可以是负数，表示尾部开始计数，如<code>-1</code>表示最后⼀个元素</p><blockquote><p>lset key index value</p></blockquote></li><li><p>例5：修改键为<code>a1</code>的列表中下标为<code>1</code>的元素值为<code>z</code></p><blockquote><p>lset a 1 z</p></blockquote></li><li><p>删除指定元素</p><ul><li>将列表中前<code>count</code>次出现的值为<code>value</code>的元素移除</li><li>count &gt; 0: 从头往尾移除</li><li>count &lt; 0: 从尾往头移除</li><li>count = 0: 移除所有</li></ul><blockquote><p>lrem key count value</p></blockquote><p><img src="/images/1553479815621.png" alt=""></p></li><li><p>例6.1：向列表<code>a2</code>中加⼊元素<code>a、b、a、b、a、b</code></p><blockquote><p>lpush a2 a b a b a b</p></blockquote></li><li><p>例6.2：从<code>a2</code>列表右侧开始删除2个<code>b</code></p><blockquote><p>lrem a2 -2 b</p></blockquote></li><li><p>例6.3：查看列表<code>a2</code>的所有元素</p><blockquote><p>lrange a2 0 -1</p></blockquote></li></ul><h3 id="3-8-set"><a href="#3-8-set" class="headerlink" title="3.8 set"></a>3.8 set</h3><ul><li><p>添加元素</p><blockquote><p>sadd key member1 member2 …</p></blockquote></li><li><p>例1：向键<code>a3</code>的集合中添加元素<code>zhangsan</code>、<code>lisi</code>、<code>wangwu</code></p><blockquote><p>sadd a3 zhangsan sili wangwu</p></blockquote></li><li><p>返回所有的元素</p><blockquote><p>smembers key</p></blockquote></li><li><p>例2：获取键<code>a3</code>的集合中所有元素</p><blockquote><p>smembers a3</p></blockquote></li><li><p>删除指定元素</p><blockquote><p>srem key value</p></blockquote></li><li><p>例3：删除键<code>a3</code>的集合中元素<code>wangwu</code></p><blockquote><p>srem a3 wangwu</p></blockquote></li></ul><h3 id="3-9-redis的几个站点地址"><a href="#3-9-redis的几个站点地址" class="headerlink" title="3.9 redis的几个站点地址"></a>3.9 redis的几个站点地址</h3><p>中文官网： <a href="http://www.redis.cn/" target="_blank" rel="noopener">http://www.redis.cn/</a></p><p>英文官网：<a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a></p><p>参考命令：<a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a></p><h3 id="针对redis中的内容扩展"><a href="#针对redis中的内容扩展" class="headerlink" title="针对redis中的内容扩展"></a>针对redis中的内容扩展</h3><p>flushall 清空数据库中的所有数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">针对各种数据类型它们的特性，使用场景如下:</span><br><span class="line">字符串string: 用于保存一些项目中的普通数据，只要键值对的都可以保存，例如，保存 session,定时记录状态</span><br><span class="line">哈希hash：用于保存项目中的一些字典数据，但是不能保存多维的字典，例如，商城的购物车</span><br><span class="line">列表list：用于保存项目中的列表数据，但是也不能保存多维的列表，例如，队列，秒杀，医院的挂号</span><br><span class="line">无序集合set:用于保存项目中的一些不能重复的数据，可以用于过滤，例如，投票海选的时候，过滤候选人</span><br><span class="line">有序集合zset：用于保存项目中一些不能重复，但是需要进行排序的数据，分数排行榜.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      window系统的redis是微软团队根据官方的linux版本高仿的...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[Redis系列]</title>
    <link href="http://yoursite.com/2020/06/21/Redis%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2020/06/21/Redis%E7%B3%BB%E5%88%97/</id>
    <published>2020-06-20T23:23:33.000Z</published>
    <updated>2020-06-20T23:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis系列"><a href="#Redis系列" class="headerlink" title="Redis系列"></a>Redis系列</h2><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API…</p><p>[1.Redis介绍安装配置]<a href="https://rogerxs80.github.io/2020/06/21/Redis%E5%88%9D%E8%AF%86/" target="_blank" rel="noopener">https://rogerxs80.github.io/2020/06/21/Redis%E5%88%9D%E8%AF%86/</a>)</p><p><a href="https://rogerxs80.github.io/2020/06/21/API%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">2.API的使用</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">3.客户端使用</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">4.高级用法</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E6%8C%81%E4%B9%85%E5%8C%96/" target="_blank" rel="noopener">5.持久化</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">6.使用常见问题</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">7.主从复制原理与优化</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/Sentinel/" target="_blank" rel="noopener">8.Sentinel</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">9.缓存的使用和优化</a></p>]]></content>
    
    <summary type="html">
    
      Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[Git安装与介绍]</title>
    <link href="http://yoursite.com/2020/05/21/Git%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2020/05/21/Git%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BB%8B%E7%BB%8D/</id>
    <published>2020-05-20T23:18:13.000Z</published>
    <updated>2020-05-20T23:19:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何多人协同开发同一个项目？"><a href="#如何多人协同开发同一个项目？" class="headerlink" title="如何多人协同开发同一个项目？"></a>如何多人协同开发同一个项目？</h1><p>使用代码版本控制[version control]软件,</p><p>目前市面上比较流行的代码版本控制器有: git,svn,csv</p><p>澄清一个问题：</p><blockquote><p>github，gitee和git之间的关系github和gitee是一个网站，git是一个代码版本控制软件。git是当初Linux系统的作者【林纳斯·托瓦兹】为了开发Linux代码所开发的一个开软软件。github是全球知名的一个开源源码托管平台，之所以叫github是因为他支持通过git上传和下载代码，同时因为git比较出名，所以借助了他的名气而已。他们之间的关系类似，张三和张三丰。gitee是一个国内知名的开源源码托管平台，和github出现的原因类似。</p></blockquote><h1 id="1-使用git管理代码版本"><a href="#1-使用git管理代码版本" class="headerlink" title="1. 使用git管理代码版本"></a>1. 使用git管理代码版本</h1><p>本项目使用git管理项目代码，代码库放在gitee码云平台。（注意，公司中通常放在gitlab私有服务器中）</p><h2 id="1-1-Git-的诞生"><a href="#1-1-Git-的诞生" class="headerlink" title="1.1 Git 的诞生"></a>1.1 Git 的诞生</h2><p>2005 年 4 月3 日，Git 是目前世界上最先进的分布式版本控制系统（没有之一）</p><p>作用：源代码管理</p><p><strong>为什么要进行源代码管理?</strong></p><ul><li>方便多人协同开发[防止代码冲突，相互覆盖]</li><li>方便版本控制[利于以后的开发人员快速了解项目的开发过程，利于需求变更的时候进行代码回滚]</li></ul><h2 id="1-2-git与svn区别"><a href="#1-2-git与svn区别" class="headerlink" title="1.2 git与svn区别"></a>1.2 git与svn区别</h2><p>SVN 都是集中控制管理的，也就是有一个中央服务器，大家都把代码提交到中央服务器，而 git 是分布式的版本控制工具，也就是说没有中央服务器，每个节点的地位平等。</p><p>SVN</p><p><img src="/image/1553208721216.png" alt=""></p><p>Git</p><p><img src="/image/1553208738888.png" alt=""></p><h2 id="Git的windows下安装"><a href="#Git的windows下安装" class="headerlink" title="Git的windows下安装"></a>Git的windows下安装</h2><p>官网地址：<a href="https://git-scm.com/download" target="_blank" rel="noopener">https://git-scm.com/download</a></p><p><img src="/image/1553220095452.png" alt=""></p><p><img src="/image/1553208779674.png" alt=""></p><p>下载到本地磁盘</p><p><img src="/image/1553208790623.png" alt=""></p><p>安装</p><p><img src="/image/1553208801316.png" alt=""></p><p>一路【next】就可以了</p><p><img src="/image/1553220218170.png" alt=""></p><p><img src="/image/1553220208875.png" alt=""></p><p><img src="/image/1553220240618.png" alt=""></p><p>注意：<strong>openssl 一定选它</strong></p><p>安装完成后，右击菜单栏，有如下菜单，表示安装完成</p><p><img src="/image/1553220425466.png" alt=""></p><p>进入git bash选项</p><p><img src="/image/1553220553963.png" alt=""></p><p>Git工作区、暂存区和版本库</p><p><img src="/image/1593749346903.png" alt=""></p><h2 id="1、工作区介绍"><a href="#1、工作区介绍" class="headerlink" title="1、工作区介绍"></a>1、工作区介绍</h2><p>就是在你本要电脑磁盘上能看到的目录。</p><h2 id="2、暂存区介绍"><a href="#2、暂存区介绍" class="headerlink" title="2、暂存区介绍"></a>2、暂存区介绍</h2><p>一般存放在【.git】目录下的index文件(.git/index) 中，所以我们把暂存区有时也叫作索引。</p><h2 id="3、版本库介绍"><a href="#3、版本库介绍" class="headerlink" title="3、版本库介绍"></a>3、版本库介绍</h2><p>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。git中的head/master是分支，是版本库。</p><h3 id="git项目仓库的本地搭建"><a href="#git项目仓库的本地搭建" class="headerlink" title="git项目仓库的本地搭建"></a>git项目仓库的本地搭建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>进入到自己希望存储代码的目录路径，并创建本地仓库.git</span><br><span class="line">新创建的本地仓库.git是个空仓库</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cd</span> 目录路径</span><br><span class="line">  git init gitdemo  <span class="comment"># 如果没有声明目录,则自动把当前目录作为git仓库</span></span><br></pre></td></tr></table></figure><p>创建仓库</p><p><img src="/image/1553222861995.png" alt=""></p><h3 id="仓库目录的结构"><a href="#仓库目录的结构" class="headerlink" title="仓库目录的结构"></a>仓库目录的结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">branches&#x2F;   分支管理目录config      </span><br><span class="line">当前项目仓木的配置信息description </span><br><span class="line">当前项目的描述HEAD        </span><br><span class="line">当前项目仓库的当前版本信息hooks       </span><br><span class="line">当前项目仓库的钩子目录[可以利用这个目录下面的文件实现自己拉去代码到服务器]info        </span><br><span class="line">仓库相关信息objects     </span><br><span class="line">仓库版本信息refs        </span><br><span class="line">引用信息</span><br></pre></td></tr></table></figure><h3 id="配置用户名和邮箱"><a href="#配置用户名和邮箱" class="headerlink" title="配置用户名和邮箱"></a>配置用户名和邮箱</h3><blockquote><p>–global表示全局配置，配置信息默认保存到当前操作系统的用户家目录中的.gitconfig文件，可以通过命令cat ~/.gitconfig查看全局配置如果不加上这个参数，则默认配置信息保存到.git/config文件中，可以通过命令 cat 项目/.git/config查看仓库配置</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">'lisi'</span></span><br><span class="line">git config --global user.email <span class="string">'lisi@163.com'</span></span><br></pre></td></tr></table></figure><p><img src="/image/1553209118220.png" alt=""></p><h3 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h3><p>所以的仓库状态指代的就是开发者每次对于项目的文件/目录都会进行增删查改操作。每次对于文件/目录进行操作时，仓库的状态都会记录下来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">git status –s 简约显示</span><br></pre></td></tr></table></figure><ul><li>红色表示新建文件或者新修改的文件,都在工作区.</li><li>绿色表示文件在暂存区</li><li>新建的<code>login.py</code>文件在工作区，需要添加到暂存区并提交到仓库区</li></ul><p><img src="/image/1553209157268.png" alt=""></p><p>上图表示： 暂时没有新文件需要提交到暂存区</p><h3 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加项目中所有文件</span></span><br><span class="line">git add .</span><br><span class="line">或者</span><br><span class="line"><span class="comment"># 添加指定文件</span></span><br><span class="line">git add login.py</span><br></pre></td></tr></table></figure><p>例如： 创建3个文件 ，并查看状态.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch 1.htmltouch 2.html 3.htmlgit statusgit add 1.html 2.html 3.html <span class="comment"># 或 git add .git status</span></span><br></pre></td></tr></table></figure><p>效果：</p><p><img src="/image/1593749524017.png" alt=""></p><p>如果要测试1.html，2.html的暂存状态，则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 1.html 2.html</span><br></pre></td></tr></table></figure><p>结果就是只有3.html是被保留在了暂存区</p><p><img src="/image/1593749620435.png" alt=""></p><h3 id="提交到版本库"><a href="#提交到版本库" class="headerlink" title="提交到版本库"></a>提交到版本库</h3><p>要把文件/目录提交到版本库必须先把文件/目录添加到暂存库才可以。所以上述的3.html可以提交，1.html和2.html是不能被提交的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"版本描述"</span></span><br></pre></td></tr></table></figure><h3 id="手动删除文件"><a href="#手动删除文件" class="headerlink" title="手动删除文件"></a>手动删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">手动操作删除 或者 在命令行下 使用 rm 文件名 删除 都是表示在工作区删除.</span><br><span class="line">对于这种删除,如果还原,则可以使用 git reset --hard HEAD</span><br></pre></td></tr></table></figure><p><img src="/image/1553221937786.png" alt=""></p><h3 id="查看历史版本-查看日志"><a href="#查看历史版本-查看日志" class="headerlink" title="查看历史版本[查看日志]"></a>查看历史版本[查看日志]</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span>      <span class="comment"># 查看详细日志列表</span></span><br><span class="line">git reflog   <span class="comment"># 查看简单日志列表</span></span><br><span class="line"> </span><br><span class="line">过滤查看日志</span><br><span class="line">  git <span class="built_in">log</span> –p </span><br><span class="line">  退出按【q】键</span><br><span class="line">  ctrl+f 向下分页</span><br><span class="line">  ctrl+b 向上分页</span><br><span class="line"></span><br><span class="line">显示指定日期之后的日志   git <span class="built_in">log</span> --after  <span class="string">'2018-11-6'</span></span><br><span class="line">显示指定日期之前的日志   git <span class="built_in">log</span> --before <span class="string">'2018-11-6'</span></span><br><span class="line"></span><br><span class="line">指定显示指定开发者的日志  git <span class="built_in">log</span> --author <span class="string">'lisi'</span></span><br></pre></td></tr></table></figure><p><strong>回退版本</strong></p><ul><li><p><strong>方案一：</strong></p><ul><li><p><code>HEAD</code>表示当前最新版本</p></li><li><p><code>HEAD^</code>表示当前最新版本的前一个版本</p></li><li><p><code>HEAD^^</code>表示当前最新版本的前两个版本，<strong>以此类推…</strong></p></li><li><p><code>HEAD~1</code>表示当前最新版本的前一个版本</p></li><li><p><code>HEAD~10</code>表示当前最新版本的前10个版本，<strong>以此类推…</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>方案二：当版本非常多时可选择的方案</strong></p><ul><li><p>通过每个版本的版本号回退到指定版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h2><p><strong>针对与文件所处的不同分区，文件所处的状态:</strong></p><p>(1)未追踪, 文件第一次出现在工作区, 版本库还没有存储该文件的状态</p><p>(2)已追踪, 只要第一次,git add了文件, 文件就是已追踪</p><p>(3)未修改, 文件在工作区未被编辑</p><p>(4)已修改, 文件在工作区被修改</p><p>(5)未暂存, 文件已修改, 但是没有add到暂存区</p><p>(6)已暂存, 已经将修改的文件add到暂存区</p><p>(7)未提交, 已暂存的文件, 没有commit提交. 处于暂存区</p><p>(8)已提交, 提交到版本库的文件修改,只有commit以后才会有仓库的版本号生成</p><p>注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">公司一般使用git管理项目,往往会搭建一个gitlab自己内部管理代码,也有公司选择使用码云的企业版仓库来管理</span><br><span class="line"></span><br><span class="line">使用git开发项目时，有时候不一定通过https协议提交代码的。也有的公司是通过ssh协议提交,此时需要生成ssh公钥和提交公钥给仓库。[码云这些官网都会有详细的提示说明]</span><br><span class="line"></span><br><span class="line">生成SSH公钥【必须安装git bash才可以使用这个命令，而且还要把git bash添加到系统变量里面】</span><br><span class="line">  ssh-keygen -t rsa -C &quot;源码托管平台的账号&quot;</span><br><span class="line"></span><br><span class="line">参考：https:&#x2F;&#x2F;gitee.com&#x2F;help&#x2F;articles&#x2F;4180</span><br></pre></td></tr></table></figure><h1 id="2-在git平台创建工程"><a href="#2-在git平台创建工程" class="headerlink" title="2. 在git平台创建工程"></a>2. 在git平台创建工程</h1><p>1） 创建私有项目库</p><p><img src="/image/1553225634429.png" alt=""></p><p><img src="/image/1553225730511.png" alt=""></p><p>创建私有空仓库以后的界面:</p><p><img src="/image/1553225968558.png" alt=""></p><p>2）克隆项目到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址</span><br><span class="line">注意，如果当前目录下出现git仓库同名目录时，会克隆失败。</span><br></pre></td></tr></table></figure><p><img src="/image/1553227023342.png" alt=""></p><p>3）创建并切换分支到dev</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分支管理的命令</span></span><br><span class="line">git branch            <span class="comment"># 查看当前项目的所有分支列表</span></span><br><span class="line">git bracn 分支名称     <span class="comment"># 新建一个分支</span></span><br><span class="line">git checkout 分支名称  <span class="comment"># 切换分支，让当前目录下显示对应分支里面的内容</span></span><br><span class="line">git checkout -d  分支名称  <span class="comment"># 删除指定名称的分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git branch dev      # 创建本地分支dev,dev是自定义</span></span><br><span class="line"><span class="comment"># git checkout dev    # 切换本地分支代码</span></span><br><span class="line">git checkout -b dev   <span class="comment"># 这里是上面两句代码的简写</span></span><br></pre></td></tr></table></figure><p>git提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add 代码目录</span><br><span class="line">git status</span><br><span class="line">git commit -m <span class="string">'添加项目代码'</span></span><br></pre></td></tr></table></figure><p>推送到远端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git push origin 本地分支名称:线上分支名称</span></span><br><span class="line"><span class="comment"># 如果本地分支和线上分支名称一致，则可以简写 git push origin 分支名称</span></span><br><span class="line"><span class="comment"># 如果有的本地分支名称，但是线上没有，则代码推送时，线上会自动创建</span></span><br><span class="line">git push origin dev:dev</span><br></pre></td></tr></table></figure><p>如果推送代码,出现以下提示: git pull ….,则表示当前本地的代码和线上的代码版本不同.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 把线上的代码执行以下命令,拉取到本地,进行同步</span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line">2. 根据提示,移除多余的冲突的文件,也可以删除.</span><br><span class="line">完成这些步骤以后,再次add,commit,push,通知其他同事git pull即可.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      github，gitee和git之间的关系github和gitee是一个网站，git是一个代码版本控制软件。git是当初Linux系统的作者[林纳斯·托瓦兹]为了开发Linux代码所开发的一个开软软件。github是全球知名...
    
    </summary>
    
    
      <category term="IT兵器谱" scheme="http://yoursite.com/categories/IT%E5%85%B5%E5%99%A8%E8%B0%B1/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>[Git命令大全]</title>
    <link href="http://yoursite.com/2020/05/21/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
    <id>http://yoursite.com/2020/05/21/Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</id>
    <published>2020-05-20T23:15:12.000Z</published>
    <updated>2020-05-20T23:16:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>配置 Git 的相关参数。</p><p>Git 一共有3个配置文件：</p><p>\1. 仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。 \2. 全局配置文件：Mac 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。 \3. 系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 <code>etc</code> 文件夹中的 <code>gitconfig</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看配置信息</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前生效的配置信息</span></span><br><span class="line">$ git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加配置项</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取配置项</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --get &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除配置项</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --<span class="built_in">unset</span> &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置提交记录中的用户信息</span></span><br><span class="line">$ git config --global user.name &lt;用户名&gt;</span><br><span class="line">$ git config --global user.email &lt;邮箱地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改Git缓存区的大小</span></span><br><span class="line"><span class="comment"># 如果提交的内容较大，默认缓存较小，提交会失败</span></span><br><span class="line"><span class="comment"># 缓存大小单位：B，例如：524288000（500MB）</span></span><br><span class="line">$ git config --global http.postBuffer &lt;缓存大小&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span></span><br><span class="line">$ git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置可以缓存密码，默认缓存时间15分钟</span></span><br><span class="line">$ git config --global credential.helper cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置密码的缓存时间</span></span><br><span class="line"><span class="comment"># 缓存时间单位：秒</span></span><br><span class="line">$ git config --global credential.helper <span class="string">'cache --timeout=&lt;缓存时间&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置长期存储密码</span></span><br><span class="line">$ git config --global credential.helper store</span><br></pre></td></tr></table></figure><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>从远程仓库克隆一个版本库到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地仓库的目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b 指定要克隆的分支，默认是master分支</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span><br></pre></td></tr></table></figure><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库，在当前目录下生成 .git 文件夹</span></span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>查看本地仓库的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地仓库的状态</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以简短模式查看本地仓库的状态</span></span><br><span class="line"><span class="comment"># 会显示两列，第一列是文件的状态，第二列是对应的文件</span></span><br><span class="line"><span class="comment"># 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</span></span><br><span class="line">$ git status -s</span><br></pre></td></tr></table></figure><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p>操作远程库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出已经存在的远程仓库</span></span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程仓库的详细信息，在别名后面列出URL地址</span></span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的别名</span></span><br><span class="line">$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定名称的远程仓库</span></span><br><span class="line">$ git remote remove &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的 URL 地址</span></span><br><span class="line">$ git remote <span class="built_in">set</span>-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span><br></pre></td></tr></table></figure><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>操作 Git 的分支命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本地的所有分支，当前所在分支以 "*" 标出</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 "*" 标出</span></span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支，新的分支基于上一次提交建立</span></span><br><span class="line">$ git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分支名称</span></span><br><span class="line"><span class="comment"># 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line">$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"><span class="comment"># 强制修改分支名称</span></span><br><span class="line">$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的本地分支</span></span><br><span class="line">$ git branch -d &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除指定的本地分支</span></span><br><span class="line">$ git branch -D &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>检出命令，用于创建、切换分支等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到已存在的指定分支</span></span><br><span class="line">$ git checkout &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，保留所有的提交记录</span></span><br><span class="line"><span class="comment"># 等同于 "git branch" 和 "git checkout" 两个命令合并</span></span><br><span class="line">$ git checkout -b &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line">$ git checkout --orphan &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line">$ git checkout &lt;文件路径&gt;</span><br></pre></td></tr></table></figure><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>把已经提交的记录合并到当前分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把已经提交的记录合并到当前分支</span></span><br><span class="line">$ git cherry-pick &lt;commit ID&gt;</span><br></pre></td></tr></table></figure><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把指定的文件添加到暂存区中</span></span><br><span class="line">$ git add &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line">$ git add -u [&lt;文件路径&gt;]</span><br><span class="line">$ git add --update [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line">$ git add -A [&lt;文件路径&gt;]</span><br><span class="line">$ git add --all [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span></span><br><span class="line">$ git add -i [&lt;文件路径&gt;]</span><br><span class="line">$ git add --interactive [&lt;文件路径&gt;]</span><br></pre></td></tr></table></figure><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>将暂存区中的文件提交到本地仓库中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line">$ git commit -m <span class="string">"&lt;提交的描述信息&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="comment"># 不包括未被版本库跟踪的文件，等同于先调用了 "git add -u"</span></span><br><span class="line">$ git commit -a -m <span class="string">"&lt;提交的描述信息&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上次提交的描述信息</span></span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>从远程仓库获取最新的版本到本地的 tmp 分支上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将远程仓库所有分支的最新版本全部取回到本地</span></span><br><span class="line">$ git fetch &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程仓库指定分支的最新版本取回到本地</span></span><br><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>合并分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下</span></span><br><span class="line">$ git merge &lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>比较版本之间的差异。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较暂存区中的文件和上次提交时的差异</span></span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前文件和上次提交时的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看从指定的版本之后改动的内容</span></span><br><span class="line">$ git diff &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个分支之间的差异</span></span><br><span class="line">$ git diff &lt;分支名称&gt; &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个分支分开后各自的改动内容</span></span><br><span class="line">$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span><br></pre></td></tr></table></figure><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>从远程仓库获取最新版本并合并到本地。 首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从远程仓库获取最新版本。</span></span><br><span class="line">$ git pull</span><br></pre></td></tr></table></figure><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>把本地仓库的提交推送到远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把本地仓库的分支推送到远程仓库的指定分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的远程仓库的分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</span><br></pre></td></tr></table></figure><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>显示提交的记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印所有的提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次提交到指定的提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印指定数量的最新提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> -&lt;指定的数量&gt;</span><br></pre></td></tr></table></figure><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>还原提交记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重置暂存区，但文件不受影响</span></span><br><span class="line"><span class="comment"># 相当于将用 "git add" 命令更新到暂存区的内容撤出暂存区，可以指定文件</span></span><br><span class="line"><span class="comment"># 没有指定 commit ID 则默认为当前 HEAD</span></span><br><span class="line">$ git reset [&lt;文件路径&gt;]</span><br><span class="line">$ git reset --mixed [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line">$ git reset &lt;commit ID&gt;</span><br><span class="line">$ git reset --mixed &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line"><span class="comment"># 相当于调用 "git reset --mixed" 命令后又做了一次 "git add"</span></span><br><span class="line">$ git reset --soft &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了</span></span><br><span class="line">$ git reset --hard &lt;commit ID&gt;</span><br></pre></td></tr></table></figure><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个新的提交来撤销某次提交</span></span><br><span class="line">$ git revert &lt;commit ID&gt;</span><br></pre></td></tr></table></figure><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>操作标签的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印所有的标签</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</span></span><br><span class="line">$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加带有描述信息的附注标签，可以指定之前的提交记录</span></span><br><span class="line">$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定的标签</span></span><br><span class="line">$ git checkout &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看标签的信息</span></span><br><span class="line">$ git show &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的标签</span></span><br><span class="line">$ git tag -d &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的标签提交到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地所有的标签全部提交到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; –tags</span><br></pre></td></tr></table></figure><h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>重命名文件或者文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名指定的文件或者文件夹</span></span><br><span class="line">$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</span><br></pre></td></tr></table></figure><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>删除文件或者文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除</span></span><br><span class="line">$ git rm &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</span></span><br><span class="line">$ git rm -r &lt;文件夹路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</span></span><br><span class="line">$ git rm --cached</span><br></pre></td></tr></table></figure><h2 id="Git操作场景示例"><a href="#Git操作场景示例" class="headerlink" title="Git操作场景示例"></a>Git操作场景示例</h2><h3 id="1-删除掉本地不存在的远程分支"><a href="#1-删除掉本地不存在的远程分支" class="headerlink" title="1. 删除掉本地不存在的远程分支"></a>1. 删除掉本地不存在的远程分支</h3><p>多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 <code>git branch --all</code> 依然会显示该远程分支，可使用下列的命令进行删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 pull 命令，添加 -p 参数</span></span><br><span class="line">$ git pull -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于下面的命令</span></span><br><span class="line">$ git fetch -p</span><br><span class="line">$ git fetch --prune origin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      配置 Git 的相关参数,1. 仓库级的配置文件：在仓库的 `.git/.gitconfig`，该配置文件只对所在的仓库有效。 \2. 全局配置文件：Mac 系统在 `~/.gitconfig`，Windows 系统...
    
    </summary>
    
    
      <category term="IT兵器谱" scheme="http://yoursite.com/categories/IT%E5%85%B5%E5%99%A8%E8%B0%B1/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>[Go语言开发环境搭建]</title>
    <link href="http://yoursite.com/2020/05/14/Go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/05/14/Go%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2020-05-14T04:58:34.000Z</published>
    <updated>2020-05-14T05:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go语言开发环境搭建"><a href="#Go语言开发环境搭建" class="headerlink" title="Go语言开发环境搭建"></a>Go语言开发环境搭建</h1><h1 id="安装Go语言及搭建Go语言开发环境"><a href="#安装Go语言及搭建Go语言开发环境" class="headerlink" title="安装Go语言及搭建Go语言开发环境"></a>安装Go语言及搭建Go语言开发环境</h1><p><strong>注意：</strong>Go语言1.14版本之后推荐使用go modules管理以来，也不再需要把代码写在GOPATH目录下了，之前旧版本的教程戳这个<a href="https://www.liwenzhou.com/posts/Go/install_go_dev_old/" target="_blank" rel="noopener">链接</a>。</p><table><strong><tr><td bgcolor=#DDEDEA align=center>**下载**</td></tr></strong></table><blockquote><p><strong>下载地址</strong></p></blockquote><p>Go官网下载地址：<a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a></p><p>Go官方镜像站（推荐）：<a href="https://golang.google.cn/dl/" target="_blank" rel="noopener">https://golang.google.cn/dl/</a></p><blockquote><p><strong>版本的选择</strong></p></blockquote><p>Windows平台和Mac平台推荐下载可执行文件版，Linux平台下载压缩文件版。</p><p><strong>下图中的版本号可能并不是最新的，但总体来说安装教程是类似的。Go语言更新迭代比较快，推荐使用较新版本，体验最新特性。</strong></p><p><img src="/images/download1.png" alt=""></p><hr><table><tr><td bgcolor=#FBE4E4 align=center bolder>**安装**  </td></tr></table>           <blockquote><p><strong>Windows安装</strong></p></blockquote><p>此安装实例以 <code>64位Win10</code>系统安装 <code>Go1.14.1可执行文件版本</code>为例。</p><p>将上一步选好的安装包下载到本地。</p><p>双击下载好的文件，然后按照下图的步骤安装即可。</p><p><img src="/images/install01.png" alt=""></p><blockquote><p><strong>Linux下安装</strong></p></blockquote><p>如果不是要在Linux平台敲go代码就不需要在Linux平台安装Go，我们开发机上写好的go代码只需要跨平台编译（详见文章末尾的跨平台编译）好之后就可以拷贝到Linux服务器上运行了，这也是go程序跨平台易部署的优势。</p><p>我们在版本选择页面选择并下载好<code>go1.14.1.linux-amd64.tar.gz</code>文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.google.com/go/go1.14.1.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>将下载好的文件解压到/usr/local目录下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf go1.14.1.linux-amd64.tar.gz -C /usr/<span class="built_in">local</span>  <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure><p>如果提示没有权限，加上<code>sudo</code>以root用户的身份再运行。执行完就可以在<code>/usr/local/</code>下看到<code>go</code>目录了。</p><p>配置环境变量： Linux下有两个文件可以配置环境变量，其中<code>/etc/profile</code>是对所有用户生效的；<code>$HOME/.profile</code>是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> GOROOT=/usr/<span class="built_in">local</span>/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin</span><br></pre></td></tr></table></figure><p>修改/etc/profile后要重启生效，修改$HOME/.profile后使用source命令加载$HOME/.profile文件即可生效。 检查：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~ go version</span><br><span class="line">go version go1.14.1 linux/amd64</span><br></pre></td></tr></table></figure><blockquote><p><strong>Mac下安装</strong></p></blockquote><p>下载可执行文件版，直接点击下一步安装即可，默认会将go安装到<code>/usr/local/go</code>目录下。</p><p><img src="/images/mac_install_go.png" alt=""></p><blockquote><p><strong>检查</strong></p></blockquote><p>上一步安装过程执行完毕后，可以打开终端窗口，输入<code>go version</code>命令，查看安装的Go版本。</p><p><img src="/images/install06.png" alt=""></p><table><tr><td bgcolor=#D3EBF1 align=center bolder>**GOROOT和GOPATH**</td></tr></table>  <p><code>GOROOT</code>和<code>GOPATH</code>都是环境变量，其中<code>GOROOT</code>是我们安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为<code>GOPATH</code>设置一个默认目录，参见下表。</p><p><strong>GOPATH在不同操作系统平台上的默认值</strong></p><table><thead><tr><th align="center">平台</th><th align="center">GOPATH默认值</th><th align="center">举例</th></tr></thead><tbody><tr><td align="center">Windows</td><td align="center">%USERPROFILE%/go</td><td align="center">C:\Users\用户名\go</td></tr><tr><td align="center">Unix</td><td align="center">$HOME/go</td><td align="center">/home/用户名/go</td></tr></tbody></table><p>可以通过以下方法查看默认的<code>GOPATH</code>目录：</p><p><img src="/images/env04.png" alt=""></p><blockquote><p><strong>GOPROXY</strong></p></blockquote><p>Go1.14版本之后，都推荐使用<code>go mod</code>模式来管理依赖环境了，也不再强制我们把代码必须写在<code>GOPATH</code>下面的src目录了，你可以在你电脑的任意位置编写go代码。（网上有些教程适用于1.11版本之前。）</p><p>默认GoPROXY配置是：<code>GOPROXY=https://proxy.golang.org,direct</code>，由于国内访问不到<code>https://proxy.golang.org</code>，所以我们需要换一个PROXY，这里推荐使用<code>https://goproxy.io</code>或<code>https://goproxy.cn</code>。</p><p>可以执行下面的命令修改GOPROXY：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><table><tr><td bgcolor=#EAE4F2 align=center bolder>**Go开发编辑器**</td></tr></table><p>Go采用的是UTF-8编码的文本文件存放源代码，理论上使用任何一款文本编辑器都可以做Go语言开发，这里推荐使用<code>VS Code</code>和<code>Goland</code>。 <code>VS Code</code>是微软开源的编辑器，而<code>Goland</code>是jetbrains出品的付费IDE。</p><p>我们这里使用<code>VS Code</code> 加插件做为go语言的开发工具。</p><blockquote><p><strong>VS Code介绍</strong></p></blockquote><p><code>VS Code</code>全称<code>Visual Studio Code</code>，是微软公司开源的一款<strong>免费</strong>现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，支持 Win、Mac 以及 Linux平台。</p><p>虽然不如某些IDE功能强大，但是它添加Go扩展插件后已经足够胜任我们日常的Go开发。</p><blockquote><p><strong>下载与安装</strong></p></blockquote><p><code>VS Code</code>官方下载地址：<a href="https://code.visualstudio.com/Download" target="_blank" rel="noopener">https://code.visualstudio.com/Download</a></p><p>三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。</p><p><img src="/images/vscode_home.png" alt=""></p><p>双击下载好的安装文件，双击安装即可。</p><blockquote><p><strong>配置</strong></p></blockquote><h3 id="安装中文简体插件"><a href="#安装中文简体插件" class="headerlink" title="安装中文简体插件"></a>安装中文简体插件</h3><p>点击左侧菜单栏最后一项<code>管理扩展</code>，在<code>搜索框</code>中输入<code>chinese</code> ，选中结果列表第一项，点击<code>install</code>安装。</p><p>安装完毕后右下角会提示<code>重启VS Code</code>，重启之后你的VS Code就显示中文啦！</p><p>![]/images/vscode1.gif)</p><p>VSCode主界面介绍：</p><p><img src="/images/vscode_menu.png" alt=""></p><h3 id="安装go扩展"><a href="#安装go扩展" class="headerlink" title="安装go扩展"></a><strong>安装go扩展</strong></h3><p>现在我们要为我们的VS Code编辑器安装<code>Go</code>扩展插件，让它支持Go语言开发。</p><p><img src="/images/vscode_plugin.png" alt=""></p><table><tr><td bgcolor=#E9E5E3 align=center bolder>**第一个Go程序**</td></tr></table>       <blockquote><p>Hello World</p></blockquote><p>现在我们来创建第一个Go项目——<code>hello</code>。在我们桌面创建一个<code>hello</code>目录。</p><p>在该目录中创建一个<code>main.go</code>文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main  <span class="comment">// 声明 main 包，表明当前是一个可执行程序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span>  <span class="comment">// 导入内置 fmt 包</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;  <span class="comment">// main函数，是程序执行的入口</span></span><br><span class="line">fmt.Println(<span class="string">"Hello World!"</span>)  <span class="comment">// 在终端打印 Hello World!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>go build</strong></p></blockquote><p><code>go build</code>表示将源代码编译成可执行文件。</p><p>在hello目录下执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build</span><br></pre></td></tr></table></figure><p>或者在其他目录执行以下命令：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build hello</span><br></pre></td></tr></table></figure><p>go编译器会去 <code>GOPATH</code>的src目录下查找你要编译的<code>hello</code>项目</p><p>编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到<code>hello.exe</code>可执行文件。</p><p>可在终端直接执行该<code>hello.exe</code>文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c:\desktop\hello&gt;hello.exe</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>我们还可以使用<code>-o</code>参数来指定编译后得到的可执行文件的名字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -o heiheihei.exe</span><br></pre></td></tr></table></figure><blockquote><p><strong>Windows下VSCode切换cmd.exe作为默认终端</strong></p></blockquote><p>如果你打开VS Code的终端界面出现如下图场景（注意观察红框圈中部分），那么你的<code>VS Code</code>此时正使用<code>powershell</code>作为默认终端：</p><p><img src="/images/vscode_shell1.png" alt=""></p><p>十分推荐你按照下面的步骤，选择cmd.exe作为默认的终端工具：</p><p><img src="/images/vscode_shell2.png" alt=""></p><p>此时，VS Code正上方中间位置会弹出如下界面，参照下图挪动鼠标使光标选中后缀为<code>cmd.exe</code>的那一个，然后点击鼠标左键。</p><p>最后<strong>重启VS Code中已经打开的终端</strong>或者<strong>直接重启VS Code</strong>就可以了。</p><p><img src="/images/vscode_shell3.png" alt=""></p><p>如果没有出现下拉三角，也没有关系，按下Ctrl+Shift+P，VS Code正上方会出现一个框，你按照下图输入shell，然后点击指定选项即可出现上面的界面了。</p><p><img src="/images/vscode_shell4.png" alt=""></p><p>补充说明：由于VS Code对go mod模式的支持暂时还不够完善，建议大家使用Goland编辑器。</p><blockquote><p><strong>go install</strong></p></blockquote><p><code>go install</code>表示安装的意思，它先编译源代码得到可执行文件，然后将可执行文件移动到<code>GOPATH</code>的bin目录下。因为我们的环境变量中配置了<code>GOPATH</code>下的bin目录，所以我们就可以在任意地方直接执行可执行文件了。</p><blockquote><p><strong>跨平台编译</strong></p></blockquote><p>默认我们<code>go build</code>的可执行文件都是当前操作系统可执行的文件，如果我想在windows下编译一个linux下可执行文件，那需要怎么做呢？</p><p>只需要指定目标操作系统的平台和处理器架构即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0  // 禁用CGO</span><br><span class="line">SET GOOS=linux  // 目标平台是linux</span><br><span class="line">SET GOARCH=amd64  // 目标处理器架构是amd64</span><br></pre></td></tr></table></figure><p><em>使用了cgo的代码是不支持跨平台编译的</em></p><p>然后再执行<code>go build</code>命令，得到的就是能够在Linux平台运行的可执行文件了。</p><p>Mac 下编译 Linux 和 Windows平台 64位 可执行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure><p>Linux 下编译 Mac 和 Windows 平台64位可执行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build</span><br><span class="line">CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build</span><br></pre></td></tr></table></figure><p>Windows下编译Mac平台64位可执行程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SET CGO_ENABLED=0</span><br><span class="line">SET GOOS=darwin</span><br><span class="line">SET GOARCH=amd64</span><br><span class="line">go build</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      安装Go语言及搭建Go语言开发环境,注意：**Go语言1.14版本之后推荐使用go modules管理以来，也不再需要把代码写在GOPATH目录下了,前旧版本的教程...
    
    </summary>
    
    
      <category term="Go语言" scheme="http://yoursite.com/categories/Go%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Go基础" scheme="http://yoursite.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Django Rest Framework]</title>
    <link href="http://yoursite.com/2020/04/22/Django%20Rest%20Framework%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2020/04/22/Django%20Rest%20Framework%E6%A1%86%E6%9E%B6/</id>
    <published>2020-04-22T14:16:13.000Z</published>
    <updated>2020-04-23T13:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DRF框架"><a href="#DRF框架" class="headerlink" title="DRF框架"></a>DRF框架</h1><p>Django Rest Framework 是一个强大且灵活的工具包，用以构建Web API</p><p>为什么要使用Rest Framework</p><p>Django REST Framework可以在Django的基础上迅速实现API，并且自身还带有WEB的测试页面，可以方便的测试自己的API</p><p><a href="https://rogerxs80.github.io/2020/04/22/API%E8%A7%84%E8%8C%83%E4%B8%8Edrf%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">1.restful API规范与DRF安装</a></p><p><a href="https://rogerxs80.github.io/2020/04/22/%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8-Serializer/" target="_blank" rel="noopener">2.序列化器-Serializer</a></p><p><a href="https://rogerxs80.github.io/2020/04/22/http%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">3.HTTP请求处理</a></p><p><a href="https://rogerxs80.github.io/2020/04/22/%E8%A7%86%E5%9B%BEView%E4%B8%8E%E8%B7%AF%E7%94%B1Router/" target="_blank" rel="noopener">4.视图View与路由Router</a></p><p><a href="https://rogerxs80.github.io/2020/04/22/DRF%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6/" target="_blank" rel="noopener">5.DRF框架中常用的组件</a></p><p><a href="https://www.notion.so/xadmin-2047b48498d2461e9f91191fe07a8738" target="_blank" rel="noopener">6.xadmin</a></p>]]></content>
    
    <summary type="html">
    
      Django 是用Python开发的一个免费开源的Web框架，可以用于快速搭建高性能，优雅的网站！采用了MVC的框架模式，即模型M，视图V和控制器C，也可以称为MVT模式，模型M，视图V，模板T...
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="Django Rest_Framework" scheme="http://yoursite.com/tags/Django-Rest-Framework/"/>
    
  </entry>
  
  <entry>
    <title>[DRF框架中常用的组件]</title>
    <link href="http://yoursite.com/2020/04/22/DRF%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/04/22/DRF%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6/</id>
    <published>2020-04-22T14:16:13.000Z</published>
    <updated>2020-04-23T13:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DRF框架中常用的组件"><a href="#DRF框架中常用的组件" class="headerlink" title="DRF框架中常用的组件"></a>DRF框架中常用的组件</h1><p>为了方便接下来的学习，我们创建一个新的子应用 opt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp opt</span><br></pre></td></tr></table></figure><p>提前在总路由和配置文件中注册子应用和配置总路由。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># settings.py中注册子应用：</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line"><span class="comment"># ....</span></span><br><span class="line"><span class="string">'opt'</span>,        <span class="comment"># drf的常用组件</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总路由中加上：</span></span><br><span class="line">path(<span class="string">"opt/"</span>,include(<span class="string">"opt.urls"</span>)),</span><br></pre></td></tr></table></figure><p>因为接下来的功能中需要使用到登陆功能，所以我们使用django内置admin站点并创建一个管理员.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure><p><img src="/images/1557276390641.png" alt=""></p><p>创建管理员以后，访问admin站点，先修改站点的语言配置</p><p>settings.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">'zh-hans'</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Shanghai'</span></span><br></pre></td></tr></table></figure><p><img src="/images/1553043081445.png" alt=""></p><p>访问admin 站点效果：</p><p><img src="/images/1553043054133.png" alt=""></p><h1 id="1-认证Authentication"><a href="#1-认证Authentication" class="headerlink" title="1. 认证Authentication"></a>1. 认证Authentication</h1><p>可以在配置文件中配置全局默认的认证方案</p><p>/home/moluo/.virtualenvs/drfdemo/lib/python3.6/site-packages/rest_framework/settings.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以在项目的主应用的settings.py配置文件中加入以下配置覆盖全局默认的配置方案。</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,  <span class="comment"># session认证</span></span><br><span class="line">        <span class="string">'rest_framework.authentication.BasicAuthentication'</span>,    <span class="comment"># 基本认证</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在每个视图中通过设置authentication_classess类属性来设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> SessionAuthentication, BasicAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    authentication_classes = [SessionAuthentication, BasicAuthentication]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>认证失败会有两种可能的返回值，这个需要我们配合权限组件来使用：</p><ul><li>401 Unauthorized 未认证</li><li>403 Permission Denied 权限被禁止</li></ul><h1 id="2-权限Permissions"><a href="#2-权限Permissions" class="headerlink" title="2. 权限Permissions"></a>2. 权限Permissions</h1><p>权限控制可以限制用户对于视图的访问和对于具体数据对象的访问。</p><ul><li>在执行视图的as_view()方法的dispatch()方法前，会先进行视图访问权限的判断</li><li>在通过get_object()获取具体模型对象时，会进行模型对象访问权限的判断</li></ul><h3 id="提供的权限"><a href="#提供的权限" class="headerlink" title="提供的权限"></a>提供的权限</h3><ul><li>AllowAny 允许所有用户</li><li>IsAuthenticated 仅通过登录认证的用户</li><li>IsAdminUser 仅管理员用户</li><li>IsAuthenticatedOrReadOnly 已经登陆认证的用户可以对数据进行增删改操作，没有登陆认证的只能查看数据。</li></ul><h3 id="配置使用"><a href="#配置使用" class="headerlink" title="配置使用"></a>配置使用</h3><p>chorme浏览器进入无痕模式的快捷键，Ctrl+Shift+N</p><p>可以在配置文件settings.py中全局设置默认的权限管理类，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># drf的配置信息，需要卸载django的配置文件，而且必须写在REST_FRAMEWORK的字典中，才能被drf识别</span></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">#  权限[全局配置，所有的视图都会被影响到]</span></span><br><span class="line">    <span class="string">'DEFAULT_PERMISSION_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'rest_framework.permissions.IsAuthenticated'</span>, <span class="comment"># 已经登录认证的用户才能访问</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未指明，则采用如下默认配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'DEFAULT_PERMISSION_CLASSES'</span>: (</span><br><span class="line">   <span class="string">'rest_framework.permissions.AllowAny'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>也可以在具体的视图中通过permission_classes属性来设置，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    permission_classes = (IsAuthenticated,)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> SessionAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> IsAuthenticated</span><br><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> RetrieveAPIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentAPIView</span><span class="params">(RetrieveAPIView)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentSerializer</span><br><span class="line">    authentication_classes = [SessionAuthentication]</span><br><span class="line">    permission_classes = [IsAuthenticated]</span><br></pre></td></tr></table></figure><h3 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h3><p>如需自定义权限，需继承rest_framework.permissions.BasePermission父类，并实现以下两个任何一个方法或全部</p><ul><li><p><code>.has_permission(self, request, view)</code></p><p>是否可以访问视图， view表示当前视图对象</p></li><li><p><code>.has_object_permission(self, request, view, obj)</code></p><p>是否可以访问数据对象， view表示当前视图， obj为模型数据对象</p></li></ul><p>例如：</p><p>在当前子应用下，创建一个权限文件permissions.py中声明自定义权限类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> BasePermission</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsXiaoMingPermission</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.user <span class="keyword">and</span> request.user.username == <span class="string">"xiaoming"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .permissions <span class="keyword">import</span> IsXiaoMingPermission</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentSerializer</span><br><span class="line">    permission_classes = [IsXiaoMingPermission]</span><br></pre></td></tr></table></figure><h1 id="3-限流Throttling"><a href="#3-限流Throttling" class="headerlink" title="3. 限流Throttling"></a>3. 限流Throttling</h1><p>可以对接口访问的频次进行限制，以减轻服务器压力，或者实现特定的业务。</p><p>一般用于付费购买次数,投票等场景使用.</p><h2 id="可选限流类"><a href="#可选限流类" class="headerlink" title="可选限流类"></a>可选限流类</h2><p>1） AnonRateThrottle</p><p>限制所有匿名未认证用户，使用IP区分用户。</p><p>使用<code>DEFAULT_THROTTLE_RATES[&#39;anon&#39;]</code> 来设置频次</p><p>2）UserRateThrottle</p><p>限制认证用户，使用User id 来区分。</p><p>使用<code>DEFAULT_THROTTLE_RATES[&#39;user&#39;]</code> 来设置频次</p><p>3）ScopedRateThrottle</p><p>限制用户对于每个视图的访问频次，使用ip或user id。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactListView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    throttle_scope = <span class="string">'contacts'</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContactDetailView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    throttle_scope = <span class="string">'contacts'</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    throttle_scope = <span class="string">'uploads'</span></span><br><span class="line">    ...</span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'rest_framework.throttling.ScopedRateThrottle'</span>,</span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;</span><br><span class="line">        <span class="string">'contacts'</span>: <span class="string">'1000/day'</span>,</span><br><span class="line">        <span class="string">'uploads'</span>: <span class="string">'20/day'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>可以在配置文件中，使用<code>DEFAULT_THROTTLE_CLASSES</code> 和 <code>DEFAULT_THROTTLE_RATES</code>进行全局配置，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_CLASSES'</span>: ( <span class="comment"># 启用的限制类</span></span><br><span class="line">        <span class="string">'rest_framework.throttling.AnonRateThrottle'</span>,</span><br><span class="line">        <span class="string">'rest_framework.throttling.UserRateThrottle'</span></span><br><span class="line">    ),</span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;   <span class="comment"># 限制频率</span></span><br><span class="line">        <span class="string">'anon'</span>: <span class="string">'100/day'</span>,</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'1000/day'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DEFAULT_THROTTLE_RATES</code> 可以使用 <code>second</code>, <code>minute</code>, <code>hour</code> 或<code>day</code>来指明周期。</p><p>也可以在具体视图中通过throttle_classess属性来配置，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> UserRateThrottle</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    throttle_classes = (UserRateThrottle,)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>全局配置中设置访问频率，settings.py代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 权限[全局配置，会被局部配置覆盖]</span></span><br><span class="line">    <span class="comment"># 'DEFAULT_PERMISSION_CLASSES': (</span></span><br><span class="line">    <span class="comment">#     'rest_framework.permissions.IsAuthenticated',</span></span><br><span class="line">    <span class="comment"># ),</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 限流</span></span><br><span class="line">    <span class="comment"># 'DEFAULT_THROTTLE_CLASSES': (  # 全局启用的限制类</span></span><br><span class="line">    <span class="comment">#     'rest_framework.throttling.AnonRateThrottle', # 匿名用户,游客</span></span><br><span class="line">    <span class="comment">#     'rest_framework.throttling.UserRateThrottle'  # 登录用户</span></span><br><span class="line">    <span class="comment"># ),</span></span><br><span class="line">    <span class="string">'DEFAULT_THROTTLE_RATES'</span>: &#123;  <span class="comment"># 限制频率</span></span><br><span class="line">        <span class="string">'anon'</span>: <span class="string">'3/minute'</span>,</span><br><span class="line">        <span class="string">'user'</span>: <span class="string">'10/minute'</span>,</span><br><span class="line">        <span class="string">'access'</span>: <span class="string">'5/minute'</span>, <span class="comment"># 这个是自定义限流的频率配置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>视图代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> students.serializers <span class="keyword">import</span> StudentModelSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> AllowAny,IsAuthenticated,IsAuthenticatedOrReadOnly,IsAdminUser</span><br><span class="line"><span class="keyword">from</span> .permission <span class="keyword">import</span> ISMingGe</span><br><span class="line"><span class="keyword">from</span> rest_framework.throttling <span class="keyword">import</span> UserRateThrottle,AnonRateThrottle,ScopedRateThrottle</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students8APIView</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    <span class="comment"># 权限配置</span></span><br><span class="line">    permission_classes = [AllowAny]</span><br><span class="line">    <span class="comment"># 限流配置</span></span><br><span class="line">    <span class="comment"># throttle_classes = [AnonRateThrottle,UserRateThrottle]</span></span><br><span class="line">    <span class="comment"># 自定义限流配置</span></span><br><span class="line">    throttle_classes = [ScopedRateThrottle]</span><br><span class="line">    throttle_scope = <span class="string">'access'</span></span><br></pre></td></tr></table></figure><h1 id="4-过滤Filtering"><a href="#4-过滤Filtering" class="headerlink" title="4. 过滤Filtering"></a>4. 过滤Filtering</h1><p>对于列表数据可能需要根据字段进行过滤，我们可以通过添加django-fitlter扩展来增强支持。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django-filter</span><br></pre></td></tr></table></figure><p>在配置文件settings.py中增加过滤组件的设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'django_filters'</span>,  <span class="comment"># 需要注册应用，</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># 全局配置，也可以使用局部配置</span></span><br><span class="line">    <span class="string">'DEFAULT_FILTER_BACKENDS'</span>: (<span class="string">'django_filters.rest_framework.DjangoFilterBackend'</span>,)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在视图类中添加类属性filter_fields，指定可以过滤的字段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentListView</span><span class="params">(ListAPIView)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentSerializer</span><br><span class="line">    filter_fields = (<span class="string">'age'</span>, <span class="string">'sex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 127.0.0.1:8000/opt/students/?sex=true  #单个过滤条件</span></span><br><span class="line"><span class="comment"># http://127.0.0.1:8000/opt/students/?sex=false&amp;age=27 # 多个并列的过滤条件</span></span><br></pre></td></tr></table></figure><h1 id="5-排序"><a href="#5-排序" class="headerlink" title="5. 排序"></a>5. 排序</h1><p>对于列表数据，REST framework提供了<strong>OrderingFilter</strong>过滤器来帮助我们快速指明数据按照指定字段进行排序。</p><p>使用方法：</p><p>在类视图中设置filter_backends，使用<code>rest_framework.filters.OrderingFilter</code>过滤器，REST framework会在请求的查询字符串参数中检查是否包含了ordering参数，如果包含了ordering参数，则按照ordering参数指明的排序字段对数据集进行排序。</p><p>前端可以传递的ordering参数的可选字段值需要在ordering_fields中指明。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentListView</span><span class="params">(ListAPIView)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    filter_backends = [OrderingFilter]</span><br><span class="line">    ordering_fields = (<span class="string">'id'</span>, <span class="string">'age'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 127.0.0.1:8000/books/?ordering=-age</span></span><br><span class="line"><span class="comment"># -id 表示针对id字段进行倒序排序</span></span><br><span class="line"><span class="comment"># id  表示针对id字段进行升序排序</span></span><br></pre></td></tr></table></figure><p>如果需要在过滤以后再次进行排序，则需要两者同步。要么一起写在全局配置中，要么一起写在视图类中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> ListAPIView</span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentModelSerializer</span><br><span class="line"><span class="keyword">from</span> django_filters.rest_framework <span class="keyword">import</span> DjangoFilterBackend</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student3ListView</span><span class="params">(ListAPIView)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    filter_fields = (<span class="string">'age'</span>, <span class="string">'sex'</span>)</span><br><span class="line">    <span class="comment"># 因为排序配置和过滤配置使用同一个类属性，所以当视图中需要使用排序和过滤时，</span></span><br><span class="line">    <span class="comment"># 要么大家一起在视图类中局部配置，要么大家一起在全局中配置，否则会出现过滤组件使用无效的情况</span></span><br><span class="line">    <span class="comment"># filter_backends = [DjangoFilterBackend,OrderingFilter]</span></span><br><span class="line">    ordering_fields = (<span class="string">'id'</span>, <span class="string">'age'</span>)</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 过滤组件[全局引入]</span></span><br><span class="line">    <span class="comment"># 'DEFAULT_FILTER_BACKENDS': ('django_filters.rest_framework.DjangoFilterBackend','rest_framework.filters.OrderingFilter')</span></span><br></pre></td></tr></table></figure><h1 id="6-分页Pagination"><a href="#6-分页Pagination" class="headerlink" title="6. 分页Pagination"></a>6. 分页Pagination</h1><p>REST framework提供了分页的支持。</p><p>我们可以在配置文件中设置全局的分页方式，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_PAGINATION_CLASS'</span>:  <span class="string">'rest_framework.pagination.PageNumberPagination'</span>,</span><br><span class="line">    <span class="string">'PAGE_SIZE'</span>: <span class="number">100</span>  <span class="comment"># 每页数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果在配置settings.py文件中， 设置了全局分页，那么在drf中凡是调用了ListModelMixin的list()，</span><br><span class="line">都会自动分页。如果项目中出现大量需要分页的数据，只有少数部分的分页，则可以在少部分的视图类中关闭分页功能。</span><br><span class="line"><span class="class"><span class="keyword">class</span> 视图类<span class="params">(ListAPIView)</span>:</span></span><br><span class="line">pagination_class = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>也可通过自定义Pagination类，来为视图添加不同分页行为。在视图中通过<code>pagination_clas</code>属性来指明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeResultsSetPagination</span><span class="params">(PageNumberPagination)</span>:</span></span><br><span class="line">    page_size = <span class="number">1000</span></span><br><span class="line">    page_size_query_param = <span class="string">'page_size'</span></span><br><span class="line">    max_page_size = <span class="number">10000</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailView</span><span class="params">(RetrieveAPIView)</span>:</span></span><br><span class="line">    queryset = BookInfo.objects.all()</span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line">    pagination_class = LargeResultsSetPagination</span><br></pre></td></tr></table></figure><h2 id="可选分页器"><a href="#可选分页器" class="headerlink" title="可选分页器"></a>可选分页器</h2><p>1） <strong>PageNumberPagination</strong></p><p>前端访问网址形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET  http:&#x2F;&#x2F;127.0.0.1:8000&#x2F;students&#x2F;?page&#x3D;4</span><br></pre></td></tr></table></figure><p>可以在子类中定义的属性：</p><ul><li>page_size 每页数目</li><li>page_query_param 前端发送的页数关键字名，默认为“page”</li><li>page_size_query_param 前端发送的每页数目关键字名，默认为None</li><li>max_page_size 前端最多能设置的每页数量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明分页的配置类</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> PageNumberPagination</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardPageNumberPagination</span><span class="params">(PageNumberPagination)</span>:</span></span><br><span class="line">    <span class="comment"># 默认每一页显示的数据量</span></span><br><span class="line">    page_size = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 允许客户端通过get参数来控制每一页的数据量</span></span><br><span class="line">    page_size_query_param = <span class="string">"size"</span></span><br><span class="line">    max_page_size = <span class="number">10</span></span><br><span class="line">    <span class="comment"># 自定义页码的参数名</span></span><br><span class="line">    page_query_param = <span class="string">"p"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentAPIView</span><span class="params">(ListAPIView)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    pagination_class = StandardPageNumberPagination</span><br><span class="line"></span><br><span class="line"><span class="comment"># 127.0.0.1/four/students/?p=1&amp;size=5</span></span><br></pre></td></tr></table></figure><p>2）<strong>LimitOffsetPagination</strong></p><p>前端访问网址形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;127.0.0.1&#x2F;four&#x2F;students&#x2F;?limit&#x3D;100&amp;offset&#x3D;100</span><br></pre></td></tr></table></figure><p>可以在子类中定义的属性：</p><ul><li>default_limit 默认限制，默认值与<code>PAGE_SIZE</code>设置一直</li><li>limit_query_param limit参数名，默认’limit’</li><li>offset_query_param offset参数名，默认’offset’</li><li>max_limit 最大limit限制，默认None</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.pagination <span class="keyword">import</span> LimitOffsetPagination</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardLimitOffsetPagination</span><span class="params">(LimitOffsetPagination)</span>:</span></span><br><span class="line">    <span class="comment"># 默认每一页查询的数据量,类似上面的page_size</span></span><br><span class="line">    default_limit = <span class="number">2</span></span><br><span class="line">    limit_query_param = <span class="string">"size"</span></span><br><span class="line">    offset_query_param = <span class="string">"start"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentAPIView</span><span class="params">(ListAPIView)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line">    <span class="comment"># 调用页码分页类</span></span><br><span class="line">    <span class="comment"># pagination_class = StandardPageNumberPagination</span></span><br><span class="line">    <span class="comment"># 调用查询偏移分页类</span></span><br><span class="line">    pagination_class = StandardLimitOffsetPagination</span><br></pre></td></tr></table></figure><h1 id="7-异常处理-Exceptions"><a href="#7-异常处理-Exceptions" class="headerlink" title="7. 异常处理 Exceptions"></a>7. 异常处理 Exceptions</h1><p>REST framework提供了自定义异常处理，我们可以自定义的方式来编写异常处理函数。例如我们想在要创建一个自定义异常函数，</p><p>这个函数，我们保存到当前主应用中[注意在实际工作中，我们可以设置一个单独的独立的公共目录来保存这种公共的函数/工具/类库]。</p><p>drfdemo/exceptions.py，代码；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler <span class="keyword">as</span> drf_exception_handler</span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> DatabaseError</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_exception_handler</span><span class="params">(exc, context)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    自定义异常处理函数</span></span><br><span class="line"><span class="string">    :param exc: 异常对象，本次发生的异常对象</span></span><br><span class="line"><span class="string">    :param context: 字典，异常出现时的执行上下文环境</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 先让drf进行异常判断</span></span><br><span class="line">    response = drf_exception_handler(exc, context)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断response对象是否为None</span></span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="string">"""出现drf不能处理的异常"""</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(exc, DatabaseError):</span><br><span class="line">            view = context.get(<span class="string">"view"</span>)</span><br><span class="line">            print(<span class="string">'数据库报错，[%s]: %s'</span> % (view, exc))</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">"detail"</span>:<span class="string">"服务器内部错误!"</span>&#125;, status=status.HTTP_507_INSUFFICIENT_STORAGE)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isinstance(exc, ZeroDivisionError):</span><br><span class="line">            view = context.get(<span class="string">"view"</span>)</span><br><span class="line">            print(<span class="string">"0不能作为除数! [%s]: %s"</span> % (view, exc) )</span><br><span class="line">            <span class="keyword">return</span> Response(&#123;<span class="string">"detail"</span>:<span class="string">"服务器内部错误!"</span>&#125;, status=status.HTTP_500_INTERNAL_SERVER_ERROR)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>在主应用的配置文件settings.py中声明自定义的异常处理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 异常处理</span></span><br><span class="line">    <span class="string">'EXCEPTION_HANDLER'</span>: <span class="string">'drfdemo.exceptions.custom_exception_handler'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果未声明，会采用默认的方式，如下</p><p>rest_frame/settings.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'EXCEPTION_HANDLER'</span>: <span class="string">'rest_framework.views.exception_handler'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="REST-framework定义的异常"><a href="#REST-framework定义的异常" class="headerlink" title="REST framework定义的异常"></a>REST framework定义的异常</h3><ul><li>APIException drf中所有异常的父类</li><li>ParseError 解析错误</li><li>AuthenticationFailed 认证失败</li><li>NotAuthenticated 尚未认证</li><li>PermissionDenied 权限受限</li><li>NotFound 未找到</li><li>MethodNotAllowed 请求方式不支持</li><li>NotAcceptable 要获取的数据格式不支持</li><li>Throttled 超过限流次数</li><li>ValidationError 校验失败</li></ul><p>也就是说，很多的没有在上面列出来的异常，就需要我们在自定义异常中自己处理了。</p><h1 id="8-自动生成接口文档"><a href="#8-自动生成接口文档" class="headerlink" title="8. 自动生成接口文档"></a>8. 自动生成接口文档</h1><p>官方文档：<a href="http://core-api.github.io/python-client/" target="_blank" rel="noopener">http://core-api.github.io/python-client/</a></p><p>REST framework可以自动帮助我们生成接口文档。</p><p>接口文档以网页的方式呈现。</p><p>自动接口文档能生成的是继承自<code>APIView</code>及其子类的视图。</p><h2 id="8-1-安装依赖"><a href="#8-1-安装依赖" class="headerlink" title="8.1. 安装依赖"></a>8.1. 安装依赖</h2><p>REST framewrok生成接口文档需要<code>coreapi</code>库的支持。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install coreapi</span><br></pre></td></tr></table></figure><h2 id="8-2-设置接口文档访问路径"><a href="#8-2-设置接口文档访问路径" class="headerlink" title="8.2. 设置接口文档访问路径"></a>8.2. 设置接口文档访问路径</h2><p>在settings.py中配置接口文档。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="comment"># 。。。 其他选项</span></span><br><span class="line">    <span class="comment"># 接口文档</span></span><br><span class="line">    <span class="string">'DEFAULT_SCHEMA_CLASS'</span>: <span class="string">'rest_framework.schemas.AutoSchema'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在总路由中添加接口文档路径。</p><p>文档路由对应的视图配置为<code>rest_framework.documentation.include_docs_urls</code>，</p><p>参数<code>title</code>为接口文档网站的标题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.documentation <span class="keyword">import</span> include_docs_urls</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    path(<span class="string">'docs/'</span>, include_docs_urls(title=<span class="string">'站点页面标题'</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="8-3-文档描述说明的定义位置"><a href="#8-3-文档描述说明的定义位置" class="headerlink" title="8.3. 文档描述说明的定义位置"></a>8.3. 文档描述说明的定义位置</h2><p>1） 单一方法的视图，可直接使用类视图的文档字符串，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListView</span><span class="params">(generics.ListAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    返回所有图书信息.</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><p>2）包含多个方法的视图，在类视图的文档字符串中，分开方法定义，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListCreateView</span><span class="params">(generics.ListCreateAPIView)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    get:</span></span><br><span class="line"><span class="string">    返回所有图书信息.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    post:</span></span><br><span class="line"><span class="string">    新建图书.</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><p>3）对于视图集ViewSet，仍在类视图的文档字符串中封开定义，但是应使用action名称区分，如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoViewSet</span><span class="params">(mixins.ListModelMixin, mixins.RetrieveModelMixin, GenericViewSet)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    list:</span></span><br><span class="line"><span class="string">    返回图书列表数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    retrieve:</span></span><br><span class="line"><span class="string">    返回图书详情数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    latest:</span></span><br><span class="line"><span class="string">    返回最新的图书数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    read:</span></span><br><span class="line"><span class="string">    修改图书的阅读量</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><h2 id="8-4-访问接口文档网页"><a href="#8-4-访问接口文档网页" class="headerlink" title="8.4. 访问接口文档网页"></a>8.4. 访问接口文档网页</h2><p>浏览器访问 127.0.0.1:8000/docs/，即可看到自动生成的接口文档。</p><p><img src="/images/drf%205%2089be22d379b34dacb463a31e54a46e7f.png" alt=""></p><h3 id="两点说明："><a href="#两点说明：" class="headerlink" title="两点说明："></a>两点说明：</h3><p>1） 视图集ViewSet中的retrieve名称，在接口文档网站中叫做read</p><p>2）参数的Description需要在模型类或序列化器类的字段中以help_text选项定义，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    age = models.IntegerField(default=<span class="number">0</span>, verbose_name=<span class="string">'年龄'</span>, help_text=<span class="string">'年龄'</span>)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = Student</span><br><span class="line">        fields = <span class="string">"__all__"</span></span><br><span class="line">        extra_kwargs = &#123;</span><br><span class="line">            <span class="string">'age'</span>: &#123;</span><br><span class="line">                <span class="string">'required'</span>: <span class="literal">True</span>,</span><br><span class="line">                <span class="string">'help_text'</span>: <span class="string">'年龄'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      DRF框架中常用的组件，为了方便接下来的学习，我们创建一个新的子应用，提前在总路由和配置文件中注册子应用和配置总路由...
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="Django Rest_Framework" scheme="http://yoursite.com/tags/Django-Rest-Framework/"/>
    
  </entry>
  
  <entry>
    <title>[视图View与路由Router]</title>
    <link href="http://yoursite.com/2020/04/22/%E8%A7%86%E5%9B%BEView%E4%B8%8E%E8%B7%AF%E7%94%B1Router/"/>
    <id>http://yoursite.com/2020/04/22/%E8%A7%86%E5%9B%BEView%E4%B8%8E%E8%B7%AF%E7%94%B1Router/</id>
    <published>2020-04-22T13:16:11.000Z</published>
    <updated>2020-04-23T11:58:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-视图"><a href="#1-视图" class="headerlink" title="1. 视图"></a>1. 视图</h1><p>Django REST framwork 提供的视图的主要作用：</p><ul><li>控制序列化器的执行（检验、保存、转换数据）</li><li>控制数据库查询的执行[数据库的删除/查询代码写在视图中，更新和添加写在序列化器]</li></ul><h2 id="1-2-视图"><a href="#1-2-视图" class="headerlink" title="1.2 视图"></a>1.2 视图</h2><p>REST framework 提供了众多的通用视图基类与扩展类，以简化视图的编写。</p><h3 id="1-2-1-2个视图基类"><a href="#1-2-1-2个视图基类" class="headerlink" title="1.2.1 2个视图基类"></a>1.2.1 2个视图基类</h3><h3 id="1-2-1-1-APIView"><a href="#1-2-1-1-APIView" class="headerlink" title="1.2.1.1 APIView"></a>1.2.1.1 APIView</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest_framework.views.APIView</span><br></pre></td></tr></table></figure><p><code>APIView</code>是REST framework提供的所有视图的基类，继承自Django的<code>View</code>父类。</p><p>drf的<code>APIView</code>与django<code>View</code>的不同之处在于：</p><ul><li>传入到视图方法中的是REST framework的<code>Request</code>对象，而不是Django的<code>HttpRequeset</code>对象；</li><li>视图方法可以返回REST framework的<code>Response</code>对象，视图会为响应数据设置（render）符合前端要求的格式；</li><li>任何<code>APIException</code>异常都会被捕获到，并且处理成合适的响应信息；</li><li>重写了as_view()，在进行dispatch()路由分发前，会对http请求进行身份认证、权限检查、访问流量控制。</li></ul><p>支持定义的类属性</p><ul><li><strong>authentication_classes</strong> 列表或元组，身份认证类</li><li><strong>permissoin_classes</strong> 列表或元组，权限检查类</li><li><strong>throttle_classes</strong> 列表或元祖，流量控制类</li></ul><p>在<code>APIView</code>中仍以常规的类视图定义方法来实现get() 、post() 或者其他请求方式的方法。</p><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="string">"""APIView是drf里面提供的所有视图类的父类</span></span><br><span class="line"><span class="string">   APIView提供的功能/属性/方法是最少的,所以使用APIView基本类似我们使用django的View</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">GET   /students/ 获取多个学生信息 </span></span><br><span class="line"><span class="string">POST  /students/ 添加一个学生信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">GET    /students/&lt;pk&gt;/  获取一个学生信息 </span></span><br><span class="line"><span class="string">PUT    /students/&lt;pk&gt;/  修改一个学生信息</span></span><br><span class="line"><span class="string">DELETE /students/&lt;pk&gt;/  删除一个学生信息</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentModelSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentAPIView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 1. 获取学生信息的数据模型</span></span><br><span class="line">        student_list = Student.objects.all()</span><br><span class="line">        <span class="comment"># 2. 调用序列化器</span></span><br><span class="line">        serializer = StudentModelSerializer(instance=student_list, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 3. 返回数据</span></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="comment"># 1. 调用序列化器对用户提交的数据进行验证</span></span><br><span class="line">        serializer = StudentModelSerializer(data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2. 调用序列化器进行数据库操作</span></span><br><span class="line">        instance = serializer.save() <span class="comment"># save()方法返回的是添加成功以后的模型对象</span></span><br><span class="line"></span><br><span class="line">        serializer = StudentModelSerializer(instance=instance)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 返回新增数据</span></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2APIView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request,pk)</span>:</span></span><br><span class="line">        <span class="comment"># 1. 根据pk获取模型对象</span></span><br><span class="line">        student = Student.objects.get(pk=pk)</span><br><span class="line">        <span class="comment"># 2. 序列化器转换数据</span></span><br><span class="line">        serializer = StudentModelSerializer(instance=student)</span><br><span class="line">        <span class="comment"># 3. 响应数据</span></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,request,pk)</span>:</span></span><br><span class="line">        <span class="comment"># 1. 通过pk查询学生信息</span></span><br><span class="line">        student = Student.objects.get(pk=pk)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3. 调用序列化器对客户端发送过来的数据进行验证</span></span><br><span class="line">        serializer = StudentModelSerializer(instance=student, data=request.data)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 4. 保存数据</span></span><br><span class="line">        instance = serializer.save()</span><br><span class="line"></span><br><span class="line">        serializer = StudentModelSerializer(instance=instance)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 5. 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        <span class="comment"># 1. 通过pk查询学生信息</span></span><br><span class="line">        Student.objects.get(pk=pk).delete()</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">"message"</span>:<span class="string">"ok"</span>&#125;, status=status.HTTP_204_NO_CONTENT)</span><br></pre></td></tr></table></figure><h3 id="1-2-1-2-GenericAPIView"><a href="#1-2-1-2-GenericAPIView" class="headerlink" title="1.2.1.2 GenericAPIView"></a>1.2.1.2 GenericAPIView</h3><p>通用视图类主要作用就是把视图中的独特的代码抽取出来，让视图方法中的代码更加通用，方便把通用代码进行简写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest_framework.generics.GenericAPIView</span><br></pre></td></tr></table></figure><p>继承自<code>APIView</code>，<strong>主要增加了操作序列化器和数据库查询的类属性，作用是为下面Mixin视图扩展类的执行提供方法支持。通常在使用时，可搭配一个或多个Mixin扩展类。</strong></p><p>提供的关于序列化器使用的属性与方法</p><ul><li><p>属性：</p><ul><li><strong>serializer_class</strong> 指明视图使用的序列化器类</li></ul></li><li><p>方法：</p><ul><li><p><strong>get_serializer_class(self)</strong></p><p>当出现一个视图类中调用多个序列化器时,那么可以通过条件判断在get_serializer_class方法中通过返回不同的序列化器类名就可以让视图方法执行不同的序列化器对象了。</p><p>返回序列化器类，默认返回<code>serializer_class</code>，可以重写，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.request.user.is_staff:</span><br><span class="line">        <span class="keyword">return</span> FullAccountSerializer</span><br><span class="line">    <span class="keyword">return</span> BasicAccountSerializer</span><br></pre></td></tr></table></figure></li><li><p>get_serializer(self, <em>args, *</em>kwargs)</p><p>返回序列化器对象，主要用来提供给Mixin扩展类使用，如果我们在视图中想要获取序列化器对象，也可以直接调用此方法。</p><p><strong>注意，该方法在提供序列化器对象的时候，会向序列化器对象的context属性补充三个数据：request、format、view，这三个数据对象可以在定义序列化器时使用。</strong></p><ul><li><strong>request</strong> 当前视图的请求对象</li><li><strong>view</strong> 当前请求的类视图对象</li><li>format 当前请求期望返回的数据格式</li></ul></li></ul></li></ul><p>提供的关于数据库查询的属性与方法</p><ul><li><p>属性：</p><ul><li><strong>queryset</strong> 指明使用的数据查询集</li></ul></li><li><p>方法：</p><ul><li><p><strong>get_queryset(self)</strong></p><p>返回视图使用的查询集，主要用来提供给Mixin扩展类使用，是列表视图与详情视图获取数据的基础，默认返回<code>queryset</code>属性，可以重写，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">    user = self.request.user</span><br><span class="line">    <span class="keyword">return</span> user.accounts.all()</span><br></pre></td></tr></table></figure></li><li><p><strong>get_object(self)</strong></p><p>返回详情视图所需的模型类数据对象，主要用来提供给Mixin扩展类使用。</p><p>在试图中可以调用该方法获取详情信息的模型类对象。</p><p><strong>若详情访问的模型类对象不存在，会返回404。</strong></p><p>该方法会默认使用APIView提供的check_object_permissions方法检查当前对象是否有权限被访问。</p><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># url(r'^books/(?P&lt;pk&gt;\d+)/$', views.BookDetailView.as_view()),</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailView</span><span class="params">(GenericAPIView)</span>:</span></span><br><span class="line">    queryset = BookInfo.objects.all()</span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        book = self.get_object() <span class="comment"># get_object()方法根据pk参数查找queryset中的数据对象</span></span><br><span class="line">        serializer = self.get_serializer(book)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>其他可以设置的属性</p><ul><li><strong>pagination_class</strong> 指明分页控制类</li><li><strong>filter_backends</strong> 指明过滤控制后端</li></ul><p>为了方便学习上面的GenericAPIView通用视图类，我们新建一个子应用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py startapp gen</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.generics <span class="keyword">import</span> GenericAPIView</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentModelSerializer, StudentModel2Serializer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentsGenericAPIView</span><span class="params">(GenericAPIView)</span>:</span></span><br><span class="line">    <span class="comment"># 本次视图类中要操作的数据[必填]</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    <span class="comment"># 本次视图类中要调用的默认序列化器[玄天]</span></span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""获取所有学生信息"""</span></span><br><span class="line">        serializer = self.get_serializer(instance=self.get_queryset(), many=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line"></span><br><span class="line">        data = request.data</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(data=data)</span><br><span class="line"></span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        instance = serializer.save()</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(instance=instance)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentGenericAPIView</span><span class="params">(GenericAPIView)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_serializer_class</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""重写获取序列化器类的方法"""</span></span><br><span class="line">        <span class="keyword">if</span> self.request.method == <span class="string">"GET"</span>:</span><br><span class="line">            <span class="keyword">return</span> StudentModel2Serializer</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在使用GenericAPIView视图获取或操作单个数据时,视图方法中的代表主键的参数最好是pk</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request,pk)</span>:</span></span><br><span class="line">        <span class="string">"""获取一条数据"""</span></span><br><span class="line">        serializer = self.get_serializer(instance=self.get_object())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,request,pk)</span>:</span></span><br><span class="line"></span><br><span class="line">        data = request.data</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(instance=self.get_object(),data=data)</span><br><span class="line"></span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        serializer.save()</span><br><span class="line"></span><br><span class="line">        serializer = self.get_serializer(instance=self.get_object())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure><p>序列化器类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model= Student</span><br><span class="line">        fields = <span class="string">"__all__"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModel2Serializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model= Student</span><br><span class="line">        fields = (<span class="string">"name"</span>,<span class="string">"class_null"</span>)</span><br></pre></td></tr></table></figure><h3 id="1-2-2-5个视图扩展类"><a href="#1-2-2-5个视图扩展类" class="headerlink" title="1.2.2 5个视图扩展类"></a>1.2.2 5个视图扩展类</h3><p>作用：</p><p>提供了几种后端视图（对数据资源进行曾删改查）处理流程的实现，如果需要编写的视图属于这五种，则视图可以通过继承相应的扩展类来复用代码，减少自己编写的代码量。</p><p>这五个扩展类需要搭配GenericAPIView父类，因为五个扩展类的实现需要调用GenericAPIView提供的序列化器与数据库查询的方法。</p><h3 id="1）ListModelMixin"><a href="#1）ListModelMixin" class="headerlink" title="1）ListModelMixin"></a>1）ListModelMixin</h3><p>列表视图扩展类，提供<code>list(request, *args, **kwargs)</code>方法快速实现列表视图，返回200状态码。</p><p>该Mixin的list方法会对数据进行过滤和分页。</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListModelMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    List a queryset.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 过滤</span></span><br><span class="line">        queryset = self.filter_queryset(self.get_queryset())</span><br><span class="line">        <span class="comment"># 分页</span></span><br><span class="line">        page = self.paginate_queryset(queryset)</span><br><span class="line">        <span class="keyword">if</span> page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            serializer = self.get_serializer(page, many=<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_paginated_response(serializer.data)</span><br><span class="line">        <span class="comment"># 序列化</span></span><br><span class="line">        serializer = self.get_serializer(queryset, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookListView</span><span class="params">(ListModelMixin, GenericAPIView)</span>:</span></span><br><span class="line">    queryset = BookInfo.objects.all()</span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request)</span><br></pre></td></tr></table></figure><h3 id="2）CreateModelMixin"><a href="#2）CreateModelMixin" class="headerlink" title="2）CreateModelMixin"></a>2）CreateModelMixin</h3><p>创建视图扩展类，提供<code>create(request, *args, **kwargs)</code>方法快速实现创建资源的视图，成功返回201状态码。</p><p>如果序列化器对前端发送的数据验证失败，返回400错误。</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateModelMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 获取序列化器</span></span><br><span class="line">        serializer = self.get_serializer(data=request.data)</span><br><span class="line">        <span class="comment"># 验证</span></span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 保存</span></span><br><span class="line">        self.perform_create(serializer)</span><br><span class="line">        headers = self.get_success_headers(serializer.data)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_create</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">        serializer.save()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_success_headers</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">'Location'</span>: str(data[api_settings.URL_FIELD_NAME])&#125;</span><br><span class="line">        <span class="keyword">except</span> (TypeError, KeyError):</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="3）RetrieveModelMixin"><a href="#3）RetrieveModelMixin" class="headerlink" title="3）RetrieveModelMixin"></a>3）RetrieveModelMixin</h3><p>详情视图扩展类，提供<code>retrieve(request, *args, **kwargs)</code>方法，可以快速实现返回一个存在的数据对象。</p><p>如果存在，返回200， 否则返回404。</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RetrieveModelMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Retrieve a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retrieve</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 获取对象，会检查对象的权限</span></span><br><span class="line">        instance = self.get_object()</span><br><span class="line">        <span class="comment"># 序列化</span></span><br><span class="line">        serializer = self.get_serializer(instance)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookDetailView</span><span class="params">(RetrieveModelMixin, GenericAPIView)</span>:</span></span><br><span class="line">    queryset = BookInfo.objects.all()</span><br><span class="line">    serializer_class = BookInfoSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request, pk)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request)</span><br></pre></td></tr></table></figure><h3 id="4）UpdateModelMixin"><a href="#4）UpdateModelMixin" class="headerlink" title="4）UpdateModelMixin"></a>4）UpdateModelMixin</h3><p>更新视图扩展类，提供<code>update(request, *args, **kwargs)</code>方法，可以快速实现更新一个存在的数据对象。</p><p>同时也提供<code>partial_update(request, *args, **kwargs)</code>方法，可以实现局部更新。</p><p>成功返回200，序列化器校验数据失败时，返回400错误。</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdateModelMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Update a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        partial = kwargs.pop(<span class="string">'partial'</span>, <span class="literal">False</span>)</span><br><span class="line">        instance = self.get_object()</span><br><span class="line">        serializer = self.get_serializer(instance, data=request.data, partial=partial)</span><br><span class="line">        serializer.is_valid(raise_exception=<span class="literal">True</span>)</span><br><span class="line">        self.perform_update(serializer)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> getattr(instance, <span class="string">'_prefetched_objects_cache'</span>, <span class="literal">None</span>):</span><br><span class="line">            <span class="comment"># If 'prefetch_related' has been applied to a queryset, we need to</span></span><br><span class="line">            <span class="comment"># forcibly invalidate the prefetch cache on the instance.</span></span><br><span class="line">            instance._prefetched_objects_cache = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_update</span><span class="params">(self, serializer)</span>:</span></span><br><span class="line">        serializer.save()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partial_update</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        kwargs[<span class="string">'partial'</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> self.update(request, *args, **kwargs)</span><br></pre></td></tr></table></figure><h3 id="5）DestroyModelMixin"><a href="#5）DestroyModelMixin" class="headerlink" title="5）DestroyModelMixin"></a>5）DestroyModelMixin</h3><p>删除视图扩展类，提供<code>destroy(request, *args, **kwargs)</code>方法，可以快速实现删除一个存在的数据对象。</p><p>成功返回204，不存在返回404。</p><p>源代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DestroyModelMixin</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Destroy a model instance.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">destroy</span><span class="params">(self, request, *args, **kwargs)</span>:</span></span><br><span class="line">        instance = self.get_object()</span><br><span class="line">        self.perform_destroy(instance)</span><br><span class="line">        <span class="keyword">return</span> Response(status=status.HTTP_204_NO_CONTENT)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perform_destroy</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        instance.delete()</span><br></pre></td></tr></table></figure><p>使用GenericAPIView和视图扩展类，实现api接口，代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""GenericAPIView结合视图扩展类实现api接口"""</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin,CreateModelMixin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Students2GenericAPIView</span><span class="params">(GenericAPIView,ListModelMixin,CreateModelMixin)</span>:</span></span><br><span class="line">    <span class="comment"># 本次视图类中要操作的数据[必填]</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    <span class="comment"># 本次视图类中要调用的默认序列化器[玄天]</span></span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""获取多个学生信息"""</span></span><br><span class="line">        <span class="keyword">return</span> self.list(request)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="string">"""添加学生信息"""</span></span><br><span class="line">        <span class="keyword">return</span> self.create(request)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student2GenericAPIView</span><span class="params">(GenericAPIView,RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line"></span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在使用GenericAPIView视图获取或操作单个数据时,视图方法中的代表主键的参数最好是pk</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self,request,pk)</span>:</span></span><br><span class="line">        <span class="string">"""获取一条数据"""</span></span><br><span class="line">        <span class="keyword">return</span> self.retrieve(request,pk)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self,request,pk)</span>:</span></span><br><span class="line">        <span class="string">"""更新一条数据"""</span></span><br><span class="line">        <span class="keyword">return</span> self.update(request,pk)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self,request,pk)</span>:</span></span><br><span class="line">        <span class="string">"""删除一条数据"""</span></span><br><span class="line">        <span class="keyword">return</span> self.destroy(request,pk)</span><br></pre></td></tr></table></figure><h3 id="1-2-3-GenericAPIView的视图子类"><a href="#1-2-3-GenericAPIView的视图子类" class="headerlink" title="1.2.3 GenericAPIView的视图子类"></a>1.2.3 GenericAPIView的视图子类</h3><h3 id="1）CreateAPIView"><a href="#1）CreateAPIView" class="headerlink" title="1）CreateAPIView"></a>1）CreateAPIView</h3><p>提供 post 方法</p><p>继承自： GenericAPIView、CreateModelMixin</p><h3 id="2）ListAPIView"><a href="#2）ListAPIView" class="headerlink" title="2）ListAPIView"></a>2）ListAPIView</h3><p>提供 get 方法</p><p>继承自：GenericAPIView、ListModelMixin</p><h3 id="3）RetrieveAPIView"><a href="#3）RetrieveAPIView" class="headerlink" title="3）RetrieveAPIView"></a>3）RetrieveAPIView</h3><p>提供 get 方法</p><p>继承自: GenericAPIView、RetrieveModelMixin</p><h3 id="4）DestoryAPIView"><a href="#4）DestoryAPIView" class="headerlink" title="4）DestoryAPIView"></a>4）DestoryAPIView</h3><p>提供 delete 方法</p><p>继承自：GenericAPIView、DestoryModelMixin</p><h3 id="5）UpdateAPIView"><a href="#5）UpdateAPIView" class="headerlink" title="5）UpdateAPIView"></a>5）UpdateAPIView</h3><p>提供 put 和 patch 方法</p><p>继承自：GenericAPIView、UpdateModelMixin</p><h3 id="6）RetrieveUpdateAPIView"><a href="#6）RetrieveUpdateAPIView" class="headerlink" title="6）RetrieveUpdateAPIView"></a>6）RetrieveUpdateAPIView</h3><p>提供 get、put、patch方法</p><p>继承自： GenericAPIView、RetrieveModelMixin、UpdateModelMixin</p><h3 id="7）RetrieveUpdateDestoryAPIView"><a href="#7）RetrieveUpdateDestoryAPIView" class="headerlink" title="7）RetrieveUpdateDestoryAPIView"></a>7）RetrieveUpdateDestoryAPIView</h3><p>提供 get、put、patch、delete方法</p><p>继承自：GenericAPIView、RetrieveModelMixin、UpdateModelMixin、DestoryModelMixin</p><h2 id="1-3-视图集ViewSet"><a href="#1-3-视图集ViewSet" class="headerlink" title="1.3 视图集ViewSet"></a>1.3 视图集ViewSet</h2><p>使用视图集ViewSet，可以将一系列逻辑相关的动作放到一个类中：</p><ul><li>list() 提供一组数据</li><li>retrieve() 提供单个数据</li><li>create() 创建数据</li><li>update() 保存数据</li><li>destory() 删除数据</li></ul><p>ViewSet视图集类不再实现get()、post()等方法，而是实现动作 <strong>action</strong> 如 list() 、create() 等。</p><p>视图集只在使用as_view()方法的时候，才会将<strong>action</strong>动作与具体请求方式对应上。如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookInfoViewSet</span><span class="params">(viewsets.ViewSet)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        books = BookInfo.objects.all()</span><br><span class="line">        serializer = BookInfoSerializer(books, many=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retrieve</span><span class="params">(self, request, pk=None)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            books = BookInfo.objects.get(id=pk)</span><br><span class="line">        <span class="keyword">except</span> BookInfo.DoesNotExist:</span><br><span class="line">            <span class="keyword">return</span> Response(status=status.HTTP_404_NOT_FOUND)</span><br><span class="line">        serializer = BookInfoSerializer(books)</span><br><span class="line">        <span class="keyword">return</span> Response(serializer.data)</span><br></pre></td></tr></table></figure><p>在设置路由时，我们可以如下操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">r'^books/$'</span>, BookInfoViewSet.as_view(&#123;<span class="string">'get'</span>:<span class="string">'list'</span>&#125;),</span><br><span class="line">    url(<span class="string">r'^books/(?P&lt;pk&gt;\d+)/$'</span>, BookInfoViewSet.as_view(&#123;<span class="string">'get'</span>: <span class="string">'retrieve'</span>&#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="1-3-1-常用视图集父类"><a href="#1-3-1-常用视图集父类" class="headerlink" title="1.3.1 常用视图集父类"></a>1.3.1 常用视图集父类</h3><h3 id="1）-ViewSet"><a href="#1）-ViewSet" class="headerlink" title="1） ViewSet"></a>1） ViewSet</h3><p>继承自<code>APIView</code>与<code>ViewSetMixin</code>，作用也与APIView基本类似，提供了身份认证、权限校验、流量管理等。</p><p><strong>ViewSet主要通过继承ViewSetMixin来实现在调用as_view()时传入字典（如{‘get’:‘list’}）的映射处理工作。</strong></p><p>在ViewSet中，没有提供任何动作action方法，需要我们自己实现action方法。</p><h3 id="2）GenericViewSet"><a href="#2）GenericViewSet" class="headerlink" title="2）GenericViewSet"></a>2）GenericViewSet</h3><p>使用ViewSet通常并不方便，因为list、retrieve、create、update、destory等方法都需要自己编写，而这些方法与前面讲过的Mixin扩展类提供的方法同名，所以我们可以通过继承Mixin扩展类来复用这些方法而无需自己编写。但是Mixin扩展类依赖与<code>GenericAPIView</code>，所以还需要继承<code>GenericAPIView</code>。</p><p><strong>GenericViewSet</strong>就帮助我们完成了这样的继承工作，继承自<code>GenericAPIView</code>与<code>ViewSetMixin</code>，在实现了调用as_view()时传入字典（如<code>{&#39;get&#39;:&#39;list&#39;}</code>）的映射处理工作的同时，还提供了<code>GenericAPIView</code>提供的基础方法，可以直接搭配Mixin扩展类使用。</p><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> GenericViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.mixins <span class="keyword">import</span> ListModelMixin,CreateModelMixin,RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student4ViewSet</span><span class="params">(GenericViewSet,ListModelMixin,CreateModelMixin,RetrieveModelMixin,UpdateModelMixin,DestroyModelMixin)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br></pre></td></tr></table></figure><p>url的定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">"students7/"</span>, views.Student4ViewSet.as_view(&#123;<span class="string">"get"</span>: <span class="string">"list"</span>, <span class="string">"post"</span>: <span class="string">"create"</span>&#125;)),</span><br><span class="line">    re_path(<span class="string">"students7/(?P&lt;pk&gt;\d+)/"</span>, views.Student4ViewSet.as_view(&#123;<span class="string">"get"</span>: <span class="string">"retrieve"</span>,<span class="string">"put"</span>:<span class="string">"update"</span>,<span class="string">"delete"</span>:<span class="string">"destroy"</span>&#125;)),</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="3）ModelViewSet"><a href="#3）ModelViewSet" class="headerlink" title="3）ModelViewSet"></a>3）ModelViewSet</h3><p>继承自<code>GenericViewSet</code>，同时包括了ListModelMixin、RetrieveModelMixin、CreateModelMixin、UpdateModelMixin、DestoryModelMixin。</p><h3 id="4）ReadOnlyModelViewSet"><a href="#4）ReadOnlyModelViewSet" class="headerlink" title="4）ReadOnlyModelViewSet"></a>4）ReadOnlyModelViewSet</h3><p>继承自<code>GenericViewSet</code>，同时包括了ListModelMixin、RetrieveModelMixin。</p><h3 id="1-3-2-视图集中定义附加action动作"><a href="#1-3-2-视图集中定义附加action动作" class="headerlink" title="1.3.2 视图集中定义附加action动作"></a>1.3.2 视图集中定义附加action动作</h3><p>在视图集中，除了上述默认的方法动作外，还可以添加自定义动作。</p><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet,ReadOnlyModelViewSet</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="string">"""学生登录功能"""</span></span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">"message"</span>:<span class="string">"登录成功"</span>&#125;)</span><br></pre></td></tr></table></figure><p>url的定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">"students8/"</span>, views.StudentModelViewSet.as_view(&#123;<span class="string">"get"</span>: <span class="string">"list"</span>, <span class="string">"post"</span>: <span class="string">"create"</span>&#125;)),</span><br><span class="line">    re_path(<span class="string">"students8/(?P&lt;pk&gt;\d+)/"</span>,</span><br><span class="line">            views.StudentModelViewSet.as_view(&#123;<span class="string">"get"</span>: <span class="string">"retrieve"</span>, <span class="string">"put"</span>: <span class="string">"update"</span>, <span class="string">"delete"</span>: <span class="string">"destroy"</span>&#125;)),</span><br><span class="line"></span><br><span class="line">    path(<span class="string">"stu/login/"</span>,views.StudentModelViewSet.as_view(&#123;<span class="string">"get"</span>:<span class="string">"login"</span>&#125;))</span><br><span class="line"></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="1-3-3-action属性"><a href="#1-3-3-action属性" class="headerlink" title="1.3.3 action属性"></a>1.3.3 action属性</h3><p>在视图集中，我们可以通过action对象属性来获取当前请求视图集时的action动作是哪个。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> students.models <span class="keyword">import</span> Student</span><br><span class="line"><span class="keyword">from</span> .serializers <span class="keyword">import</span> StudentModelSerializer</span><br><span class="line"><span class="keyword">from</span> rest_framework.response <span class="keyword">import</span> Response</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_5</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="string">"""获取最近添加的5个学生信息"""</span></span><br><span class="line">        <span class="comment"># 操作数据库</span></span><br><span class="line">        print(self.action) <span class="comment"># 获取本次请求的视图方法名</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">通过路由访问到当前方法中.可以看到本次的action就是请求的方法名</span><br></pre></td></tr></table></figure><h1 id="2-路由Routers"><a href="#2-路由Routers" class="headerlink" title="2. 路由Routers"></a>2. 路由Routers</h1><p>对于视图集ViewSet，我们除了可以自己手动指明请求方式与动作action之间的对应关系外，还可以使用Routers来帮助我们快速实现路由信息。</p><p>REST framework提供了两个router</p><ul><li><strong>SimpleRouter</strong></li><li><strong>DefaultRouter</strong></li></ul><h2 id="2-1-使用方法"><a href="#2-1-使用方法" class="headerlink" title="2.1 使用方法"></a>2.1 使用方法</h2><p>1） 创建router对象，并注册视图集，例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br><span class="line"></span><br><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(<span class="string">r'router_stu'</span>, StudentModelViewSet, base_name=<span class="string">'student'</span>)</span><br></pre></td></tr></table></figure><p>register(prefix, viewset, base_name)</p><ul><li>prefix 该视图集的路由前缀</li><li>viewset 视图集</li><li>base_name 路由别名的前缀</li></ul><p>如上述代码会形成的路由如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^books/$    name: book-list</span><br><span class="line">^books/&#123;pk&#125;/$   name: book-detail</span><br></pre></td></tr></table></figure><p>2）添加路由数据</p><p>可以有两种方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line">urlpatterns += router.urls</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">    url(<span class="string">r'^'</span>, include(router.urls))</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>使用路由类给视图集生成了路由地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet,ReadOnlyModelViewSet</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="string">"""学生登录功能"""</span></span><br><span class="line">        print(self.action)</span><br><span class="line">        <span class="keyword">return</span> Response(&#123;<span class="string">"message"</span>:<span class="string">"登录成功"</span>&#125;)</span><br></pre></td></tr></table></figure><p>路由代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, re_path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    ...</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="string">"""使用drf提供路由类router给视图集生成路由列表"""</span></span><br><span class="line"><span class="comment"># 实例化路由类</span></span><br><span class="line"><span class="comment"># drf提供一共提供了两个路由类给我们使用,他们用法一致,功能几乎一样</span></span><br><span class="line"><span class="keyword">from</span> rest_framework.routers <span class="keyword">import</span> DefaultRouter</span><br><span class="line">router = DefaultRouter()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注册视图集</span></span><br><span class="line"><span class="comment"># router.register("路由前缀",视图集类)</span></span><br><span class="line">router.register(<span class="string">"router_stu"</span>,views.StudentModelViewSet)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把生成的路由列表追加到urlpatterns</span></span><br><span class="line">print( router.urls )</span><br><span class="line">urlpatterns += router.urls</span><br></pre></td></tr></table></figure><p>上面的代码就成功生成了路由地址[增/删/改/查一条/查多条的功能]，但是不会自动我们在视图集自定义方法的路由。</p><p>所以我们如果也要给自定义方法生成路由，则需要进行action动作的声明。</p><h2 id="2-2-视图集中附加action的声明"><a href="#2-2-视图集中附加action的声明" class="headerlink" title="2.2 视图集中附加action的声明"></a>2.2 视图集中附加action的声明</h2><p>在视图集中，如果想要让Router自动帮助我们为自定义的动作生成路由信息，需要使用<code>rest_framework.decorators.action</code>装饰器。</p><p>以action装饰器装饰的方法名会作为action动作名，与list、retrieve等同。</p><p>action装饰器可以接收两个参数：</p><ul><li><p><strong>methods</strong>: 声明该action对应的请求方式，列表传递</p></li><li><p>detail声明该action的路径是否与单一资源对应，及是否是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx/&lt;pk&gt;/action方法名/</span><br></pre></td></tr></table></figure><ul><li>True 表示路径格式是<code>xxx/&lt;pk&gt;/action方法名/</code></li><li>False 表示路径格式是<code>xxx/action方法名/</code></li></ul></li></ul><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> action</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudentModelViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = Student.objects.all()</span><br><span class="line">    serializer_class = StudentModelSerializer</span><br><span class="line"></span><br><span class="line">    <span class="comment"># methods 设置当前方法允许哪些http请求访问当前视图方法</span></span><br><span class="line">    <span class="comment"># detail 设置当前视图方法是否是操作一个数据</span></span><br><span class="line">    <span class="comment"># detail为True，表示路径名格式应该为 router_stu/&#123;pk&#125;/login/</span></span><br><span class="line"><span class="meta">    @action(methods=['get'], detail=True)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(self, request,pk)</span>:</span></span><br><span class="line">        <span class="string">"""登录"""</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># detail为False 表示路径名格式应该为 router_stu/get_new_5/</span></span><br><span class="line"><span class="meta">    @action(methods=['put'], detail=False)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_new_5</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""获取最新添加的5个学生信息"""</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>由路由器自动为此视图集自定义action方法形成的路由会是如下内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^router_stu/get_new_5/$    name: router_stu-get_new_5</span><br><span class="line">^router_stu/&#123;pk&#125;/login/$   name: router_stu-login</span><br></pre></td></tr></table></figure><h2 id="2-3-路由router形成URL的方式"><a href="#2-3-路由router形成URL的方式" class="headerlink" title="2.3 路由router形成URL的方式"></a>2.3 路由router形成URL的方式</h2><p>1） SimpleRouter</p><p><img src="/imamges/SimpleRouter.png" alt=""></p><p>2）DefaultRouter</p><p><img src="/imamges/DefaultRouter.png" alt=""></p><p>DefaultRouter与SimpleRouter的区别是，DefaultRouter会多附带一个默认的API根视图，返回一个包含所有列表视图的超链接响应数据。</p>]]></content>
    
    <summary type="html">
    
      Django REST framwork 提供的视图的主要作用：控制序列化器的执行（检验、保存、转换数据）,控制数据库查询的执行[数据库的删除/查询代码写在视图中，更新和添加写在序列化器]...
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="Django Rest_Framework" scheme="http://yoursite.com/tags/Django-Rest-Framework/"/>
    
  </entry>
  
</feed>
