<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lupinus</title>
  
  <subtitle>Re：从零开始的go学习生活(｀・ω・´)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-23T15:05:34.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lupinus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Go流程控制语句]</title>
    <link href="http://yoursite.com/2021/04/23/Go%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2021/04/23/Go%E5%87%BD%E6%95%B0/</id>
    <published>2021-04-23T12:55:51.000Z</published>
    <updated>2021-04-23T15:05:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的基本形式"><a href="#函数的基本形式" class="headerlink" title="函数的基本形式"></a>函数的基本形式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义。a,b是形参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">argf</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">a = a + b </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">6</span></span><br><span class="line">argf(x, y) <span class="comment">//函数调用。x,y是实参</span></span><br></pre></td></tr></table></figure><ul><li>形参是函数内部的局部变量，实参的值会拷贝给形参。</li><li>函数定义时的第一个的大括号不能另起一行。</li><li>形参可以有0个或多个。</li><li>参数类型相同时可以只写一次，比如argf(a,b int)。 </li><li>在函数内部修改形参的值，实参的值不受影响。</li><li>如果想通过函数修改实参，就需要指针类型。 </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">argf</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">    *a = *a + *b</span><br><span class="line">    *b = <span class="number">888</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">6</span></span><br><span class="line">argf(&amp;x, &amp;y)</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;slice、map、channel都是引用类型，它们作为函数参数时其实跟普通struct没什么区别，都是对struct内部的各个字段做一次拷贝传到函数内部。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice_arg_1</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123; <span class="comment">//slice作为参数，实际上是把slice的arrayPointer、len、cap拷贝了一份传进来</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>           <span class="comment">//修改底层数据里的首元素</span></span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">1</span>) <span class="comment">//arr的len和cap发生了变化，不会影响实参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">8</span>&#125;</span><br><span class="line">slice_arg_1(arr)</span><br><span class="line">fmt.Println(arr[<span class="number">0</span>])   <span class="comment">//1</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr)) <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于函数返回值</p><ul><li>可以返回0个或多个参数。</li><li>可以在func行直接声明要返回的变量。</li><li>return后面的语句不会执行。</li><li>无返回参数时return可以不写。   </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnf</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(c <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//返回变量c已经声明好了</span></span><br><span class="line">    a = a + b</span><br><span class="line">    c = a <span class="comment">//直接使用c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//由于函数要求有返回值，即使给c赋过值了，也需要显式写return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;不定长参数实际上是slice类型。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variable_ength_arg</span><span class="params">(a <span class="keyword">int</span>, other ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; </span><br><span class="line">    sum := a</span><br><span class="line">    <span class="keyword">for</span> _, ele := <span class="keyword">range</span> other &#123;<span class="comment">//不定长参数实际上是slice类型</span></span><br><span class="line">        sum += ele</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"len %d cap %d\n"</span>, <span class="built_in">len</span>(other), <span class="built_in">cap</span>(other))</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">variable_ength_arg(<span class="number">1</span>)</span><br><span class="line">variable_ength_arg(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;append函数接收的就是不定长参数。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">7</span>)</span><br><span class="line">arr = <span class="built_in">append</span>(arr)</span><br><span class="line">slice := <span class="built_in">append</span>([]<span class="keyword">byte</span>(<span class="string">"hello "</span>), <span class="string">"world"</span>...) <span class="comment">//...自动把"world"转成byte切片，等价于[]byte("world")...</span></span><br><span class="line">slice2 := <span class="built_in">append</span>([]<span class="keyword">rune</span>(<span class="string">"hello "</span>), []<span class="keyword">rune</span>(<span class="string">"world"</span>)...) <span class="comment">//需要显式把"world"转成rune切片</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;在很多场景下string都隐式的转换成了byte切片，而非rune切片，比如”a中”[1]是228而非”中”。<br>递归函数  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n <span class="comment">//凡是递归，一定要有终止条件，否则会进入无限循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>) <span class="comment">//递归调用函数自身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>&#8195;&#8195;函数也是一种数据类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_arg1</span><span class="params">(f <span class="keyword">func</span>(a, b <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span> &#123; <span class="comment">//f参数是一种函数类型</span></span><br><span class="line">a := <span class="number">2</span> * b</span><br><span class="line"><span class="keyword">return</span> f(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> foo <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span> //<span class="title">foo</span>是一种函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_arg2</span><span class="params">(f foo, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">//参数类型看上去简洁多了</span></span><br><span class="line">    a := <span class="number">2</span> * b</span><br><span class="line">    <span class="keyword">return</span> f(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    bye foo <span class="comment">//bye的类型是foo，而foo代表一种函数类型</span></span><br><span class="line">    hello <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span> //使用匿名函数来声明<span class="title">struct</span>字段的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span>, 10)</span></span><br><span class="line">ch &lt;- <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;  <span class="comment">//使用匿名函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>&#8195;&#8195;闭包（Closure）是引用了自由变量的函数，自由变量将和函数一同存在，即使已经离开了创造它的环境。闭包复制的是原对象的指针。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包（Closure）是引用了自由变量的函数。自由变量将和函数一同存在，即使已经离开了创造它的环境。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;i)</span><br><span class="line">b := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"i addr %p\n"</span>, &amp;i) <span class="comment">//闭包复制的是原对象的指针</span></span><br><span class="line">i--                           <span class="comment">//b函数内部引用了变量i</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b <span class="comment">//返回了b函数，变量i和b函数将一起存在，即使已经离开函数sub()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用函数参数局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"base addr %p\n"</span>, &amp;base)</span><br><span class="line">base += i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := sub()</span><br><span class="line">b()</span><br><span class="line">b()</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">tmp1 := add(<span class="number">10</span>)</span><br><span class="line">fmt.Println(tmp1(<span class="number">1</span>), tmp1(<span class="number">2</span>)) <span class="comment">//11,13</span></span><br><span class="line"><span class="comment">// 此时tmp1和tmp2不是一个实体了</span></span><br><span class="line">tmp2 := add(<span class="number">100</span>)</span><br><span class="line">fmt.Println(tmp2(<span class="number">1</span>), tmp2(<span class="number">2</span>)) <span class="comment">//101,103</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟调用defer"><a href="#延迟调用defer" class="headerlink" title="延迟调用defer"></a>延迟调用defer</h2><ul><li>defer用于注册一个延迟调用（在函数返回之前调用）。</li><li>defer典型的应用场景是释放资源，比如关闭文件句柄，释放数据库连接等。</li><li>如果同一个函数里有多个defer，则后注册的先执行。</li><li>defer后可以跟一个func，func内部如果发生panic，会把panic暂时搁置，当把其他defer执行完之后再来执行这个。</li><li>defer后不是跟func，而直接跟一条执行语句，则相关变量在注册defer时被拷贝或计算。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">basic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="number">1</span>) fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">    <span class="comment">//如果同一个函数里有多个defer，则后注册的先执行</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defer_exe_time</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">i = <span class="number">9</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//defer后可以跟一个func</span></span><br><span class="line">fmt.Printf(<span class="string">"first i=%d\n"</span>, i) <span class="comment">//打印5，而非9。充分理解“defer在函数返回前执行”的含义，不是在“return语句前执行defer”</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"second i=%d\n"</span>, i) <span class="comment">//打印9</span></span><br><span class="line">&#125;(i)</span><br><span class="line"><span class="keyword">defer</span> fmt.Printf(<span class="string">"third i=%d\n"</span>, i) <span class="comment">//defer后不是跟func，而直接跟一条执行语句，则相关变量在注册defer时被拷贝或计算</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>&#8195;&#8195;go语言没有try catch，它提倡返回error。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"divide by zero"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res, err := divide(<span class="number">3</span>, <span class="number">0</span>); err != <span class="literal">nil</span> &#123;<span class="comment">//函数调用方判断error是否为nil</span></span><br><span class="line">    fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;Go语言定义了error这个接口，自定义的error要实现Error()方法。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;    <span class="comment">//自定义error</span></span><br><span class="line">    path <span class="keyword">string</span></span><br><span class="line">    op <span class="keyword">string</span></span><br><span class="line">    createTime <span class="keyword">string</span></span><br><span class="line">    message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(err PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;    <span class="comment">//error接口要求实现Error() string方法</span></span><br><span class="line"><span class="keyword">return</span> err.createTime + <span class="string">": "</span> + err.op + <span class="string">" "</span> + err.path + <span class="string">" "</span> + err.message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>何时会发生panic:  </p><ul><li>运行时错误会导致panic，比如数组越界、除0。</li><li>程序主动调用panic(error)。</li></ul><p>panic会执行什么：  </p><ol><li>逆序执行当前goroutine的defer链（recover从这里介入）。</li><li>打印错误信息和调用堆栈。</li><li>调用exit(2)结束整个进程。  </li></ol><p>&#8195;&#8195;recover会使程序从panic中恢复(即不会执行panic的第2步和第3步)，并返回panic value。recover所在的函数后续的代码不会执行，但函数可以正常返回。在未发生panic时调用recover，会返回nil。recover()必须在defer中才能生效。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">soo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"enter soo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//去掉这个defer试试，看看panic的流程。把这个defer放到soo函数末尾试试。把这个defer移到main()里试试。</span></span><br><span class="line"><span class="comment">//recover必须在defer中才能生效</span></span><br><span class="line"><span class="keyword">if</span> panic_value := <span class="built_in">recover</span>(); panic_value != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"soo函数中发生了panic:%v\n"</span>, panic_value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">"regist recover"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line">_ = <span class="number">3</span> / n <span class="comment">//除0异常，发生panic，下一行的defer没有注册成功</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"how are you"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// defer func() &#123; //方式一，recover()在B()函数里，则在B()函数中panic后面的代码不会执行。不影响BBBBBBB的打印</span></span><br><span class="line"><span class="comment">// if panicValue := recover(); panicValue != nil &#123;</span></span><br><span class="line"><span class="comment">// fmt.Printf("panic info %v\n", panicValue)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;()</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//方式二，recover()在main()函数里，则在main()函数中panic后面的代码不会执行。BBBBBBB不会打印出来</span></span><br><span class="line"><span class="keyword">if</span> panicValue := <span class="built_in">recover</span>(); panicValue != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"panic info %v\n"</span>, panicValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">B()</span><br><span class="line">fmt.Println(<span class="string">"BBBBBBB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Go流程控制语句]</title>
    <link href="http://yoursite.com/2021/04/22/Go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2021/04/22/Go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</id>
    <published>2021-04-22T10:55:32.000Z</published>
    <updated>2021-04-22T07:01:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">5</span> &gt; <span class="number">9</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"5&gt;9"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果逻辑表达式成立，就会执行{}里的内容。</li><li>逻辑表达式不需要加()。</li><li>“{“必须紧跟在逻辑表达式后面，不能另起一行。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c, d, e := <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>; c &lt; d &amp;&amp; (c &gt; e || c &gt; <span class="number">3</span>) &#123; <span class="comment">//初始化多个局部变量。复杂的逻辑表达式</span></span><br><span class="line">    fmt.Println(<span class="string">"fit"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>逻辑表达中可以含有变量或常量。</li><li>if句子中允许包含1个(仅1个)分号，在分号前初始化一些局部变量(即只在if块内可见)。  </li></ul><p>if-else的用法  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">color := <span class="string">"black"</span></span><br><span class="line"><span class="keyword">if</span> color == <span class="string">"red"</span> &#123; <span class="comment">//if只能有一个</span></span><br><span class="line">    fmt.Println(<span class="string">"stop"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> color == <span class="string">"green"</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"go"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> color == <span class="string">"yellow"</span> &#123; <span class="comment">//else if可以有0个、一个或者连续多个</span></span><br><span class="line">    fmt.Println(<span class="string">"stop"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//else有0个或1个</span></span><br><span class="line">    fmt.Printf(<span class="string">"invalid traffic signal: %s\n"</span>, strings.ToUpper(color))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if表达式嵌套  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> xxx &#123;</span><br><span class="line">    <span class="keyword">if</span> xxx &#123;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> xxx&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> xxx &#123;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;注意太深的嵌套不利于代码的维护，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">color := <span class="string">"black"</span></span><br><span class="line"><span class="keyword">switch</span> color &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"green"</span> :<span class="comment">//相当于  if color== "green"</span></span><br><span class="line">fmt.Println(<span class="string">"go"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"red"</span> :<span class="comment">//相当于else if color== "red" </span></span><br><span class="line">fmt.Println(<span class="string">"stop"</span>)</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//相当于else </span></span><br><span class="line">fmt.Printf(<span class="string">"invalid traffic signal: %s\n"</span>, strings.ToUpper(color))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch-case-default可能模拟if-else if-else，但只能实现相等判断。</li><li>switch和case后面可以跟常量、变量或函数表达式，只要它们表示的数据类型相同就行。</li><li>case后面可以跟多个值，只要有一个值满足就行。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switch_expression</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">switch</span> add(a) &#123; <span class="comment">//switch后跟一个函数表达式</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">15</span>: <span class="comment">//case后跟一个常量</span></span><br><span class="line">fmt.Println(<span class="string">"right"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> B = <span class="number">15</span></span><br><span class="line"><span class="keyword">switch</span> B &#123; <span class="comment">//switch后跟一个常量</span></span><br><span class="line"><span class="keyword">case</span> add(a): <span class="comment">//case后跟一个函数表达式</span></span><br><span class="line">fmt.Println(<span class="string">"right"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;switch后带表达式时，switch-case只能模拟相等的情况；如果switch后不带表达式，case后就可以跟任意的条件表达式。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switch_condition</span><span class="params">()</span></span> &#123;</span><br><span class="line">color := <span class="string">"yellow"</span></span><br><span class="line"><span class="keyword">switch</span> color &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"green"</span>:</span><br><span class="line">fmt.Println(<span class="string">"go"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"red"</span>, <span class="string">"yellow"</span>: <span class="comment">//用逗号分隔多个condition，它们之间是“或”的关系，只需要有一个condition满足就行</span></span><br><span class="line">fmt.Println(<span class="string">"stop"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch后带表达式时，switch-case只能模拟相等的情况；如果switch后不带表达式，case后就可以跟任意的条件表达式</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> add(<span class="number">5</span>) &gt; <span class="number">10</span>:</span><br><span class="line">fmt.Println(<span class="string">"right"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch Type</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switch_type</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">interface</span>&#123;&#125; = <span class="number">6.5</span></span><br><span class="line"><span class="keyword">switch</span> num.(<span class="keyword">type</span>) &#123; <span class="comment">//获取interface的具体类型。.(type)只能用在switch后面</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Println(<span class="string">"int"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float32</span>:</span><br><span class="line">fmt.Println(<span class="string">"float32"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">fmt.Println(<span class="string">"float64"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">byte</span>:</span><br><span class="line">fmt.Println(<span class="string">"byte"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"neither"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> value := num.(<span class="keyword">type</span>) &#123; <span class="comment">//相当于在每个case内部申明了一个变量value</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>: <span class="comment">//value已被转换为int类型</span></span><br><span class="line">fmt.Printf(<span class="string">"number is int %d\n"</span>, value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>: <span class="comment">//value已被转换为float64类型</span></span><br><span class="line">fmt.Printf(<span class="string">"number is float64 %f\n"</span>, value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">byte</span>, <span class="keyword">string</span>: <span class="comment">//如果case后有多个类型，则value还是interface&#123;&#125;类型</span></span><br><span class="line">fmt.Printf(<span class="string">"number is inerface %v\n"</span>, value)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"neither"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价形式</span></span><br><span class="line"><span class="keyword">switch</span> num.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">value := num.(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"number is int %d\n"</span>, value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">value := num.(<span class="keyword">float64</span>)</span><br><span class="line">fmt.Printf(<span class="string">"number is float64 %f\n"</span>, value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">byte</span>:</span><br><span class="line">value := num.(<span class="keyword">byte</span>)</span><br><span class="line">fmt.Printf(<span class="string">"number is byte %d\n"</span>, value)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"neither"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fallthrough 强制执行下一个case（或default）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fall_throth</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"您的年龄是%d, 您可以：\n"</span>, age)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">50</span>:</span><br><span class="line">fmt.Println(<span class="string">"出任国家首脑"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">25</span>:</span><br><span class="line">fmt.Println(<span class="string">"生育子女"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">22</span>:</span><br><span class="line">fmt.Println(<span class="string">"结婚"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">18</span>:</span><br><span class="line">fmt.Println(<span class="string">"开车"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">16</span>:</span><br><span class="line">fmt.Println(<span class="string">"参加工作"</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">15</span>:</span><br><span class="line">fmt.Println(<span class="string">"上高中"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"上幼儿园"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123; <span class="comment">//正序遍历切片</span></span><br><span class="line">fmt.Printf(<span class="string">"%d: %d\n"</span>, i, arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 初始化局部变量;条件表达式;后续操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sum, i := <span class="number">0</span>, <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr) &amp;&amp; sum &lt; <span class="number">100</span>; sum, i = sum*<span class="number">1</span>, i+<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>局部变量指仅在for块内可见。</li><li>初始化变量可以放在for上面。</li><li>后续操作可以放在for块内部。</li><li>只有条件判断时，前后的分号可以不要。</li><li>for{}是一个无限循环。  </li></ul><p>for range  </p><ul><li>遍历数组或切片<ul><li>for i, ele := range arr </li></ul></li><li>遍历string<ul><li>for i, ele := range “我会唱ABC”    //ele是rune类型</li></ul></li><li>遍历map，go不保证遍历的顺序<ul><li>for key, value := range m</li></ul></li><li>遍历channel，遍历前一定要先close<ul><li>for ele := range ch</li><li>for range拿到的是数据的拷贝</li></ul></li></ul><p>for嵌套<br>&#8195;&#8195;矩阵乘法需要用到三层for循环嵌套。 </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/mat_mul.png" alt="avatar">   </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nest_for</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">A := [SIZE][SIZE]<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line"><span class="comment">//初始化二维数组</span></span><br><span class="line"><span class="comment">//两层for循环嵌套</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line">A[i][j] = rand.Float64() <span class="comment">//[0,1)上的随机数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B := [SIZE][SIZE]<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line">B[i][j] = rand.Float64() <span class="comment">//[0,1)上的随机数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rect := [SIZE][SIZE]<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line"><span class="comment">//三层for循环嵌套</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line">prod := <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; SIZE; k++ &#123;</span><br><span class="line">prod += A[i][k] * B[k][j]</span><br><span class="line">&#125;</span><br><span class="line">rect[i][j] = prod</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i, j := <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">fmt.Println(A[i]) <span class="comment">//二维数组第i行</span></span><br><span class="line"><span class="comment">//打印二维数组的第j列</span></span><br><span class="line"><span class="comment">//注意：B[:][j]这不是二维数组第j列，这是二维数组第j行！</span></span><br><span class="line"><span class="keyword">for</span> _, row := <span class="keyword">range</span> B &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%g "</span>, row[j])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(rect[i][j])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h2><ul><li>break与continue用于控制for循环的代码流程，并且只针对最靠近自己的外层for循环。</li><li>break:退出for循环，且本轮break下面的代码不再执行。</li><li>continue:本轮continue下面的代码不再执行，进入for循环的下一轮。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//break和continue都是针对for循环的，不针对if或switch</span></span><br><span class="line"><span class="comment">//break和continue都是针对套在自己外面的最靠里的那层for循环，不针对更外层的for循环（除非使用Label）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">complex_break_continue</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">5</span></span><br><span class="line">arr := [SIZE][SIZE]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"开始检查第%d行\n"</span>, i)</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"开始检查第%d列\n"</span>, j)</span><br><span class="line"><span class="keyword">if</span> arr[i][j]%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">//针对第二层for循环</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"将要检查第%d列\n"</span>, j+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">//针对第一层for循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="goto与Label"><a href="#goto与Label" class="headerlink" title="goto与Label"></a>goto与Label</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">4</span></span><br><span class="line">MY_LABEL:</span><br><span class="line">i += <span class="number">3</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">goto</span> MY_LABEL <span class="comment">//返回定义MY_LABEL的那一行，把代码再执行一遍（会进入一个无限循环）</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> L1 <span class="comment">//Label指示的是某一行代码，并没有圈定一个代码块，所以goto L1也会执行L2后的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> L2<span class="comment">//先使用Label</span></span><br><span class="line">&#125;</span><br><span class="line">L1: </span><br><span class="line">i += <span class="number">3</span></span><br><span class="line">L2: <span class="comment">//后定义Label。Label定义后必须在代码的某个地方被使用</span></span><br><span class="line">i *= <span class="number">3</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;goto与Label结合可以实现break的功能，甚至比break更强大。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line">L2:</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line"><span class="keyword">goto</span> L1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L1:</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure><ul><li>break、continue与Label结合使用可以跳转到更外层的for循环。</li><li>continue和break针对的Label必须写在for前面，而goto可以针对任意位置的Label。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">break_label</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">5</span></span><br><span class="line">arr := [SIZE][SIZE]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">L1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line">L2:</span><br><span class="line">fmt.Printf(<span class="string">"开始检查第%d行\n"</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">L3:</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"开始检查第%d列\n"</span>, j)</span><br><span class="line"><span class="keyword">if</span> arr[i][j]%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> L1 <span class="comment">//直接退出最外层的fot循环</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[i][j]%<span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> L2 <span class="comment">//continue和break针对的Label必须写在for前面，而goto可以针对任意位置的Label</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span> L3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>练习</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">L1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; &#123;</span><br><span class="line">fmt.Println(<span class="string">"开始"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"i=%d\n"</span>, i)</span><br><span class="line">L2:</span><br><span class="line">fmt.Println(<span class="string">"开始2"</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">"i=%d\n"</span>, i)</span><br><span class="line">fmt.Print(<span class="string">"请输入："</span>)</span><br><span class="line">fmt.Scan(&amp;num)</span><br><span class="line"><span class="keyword">switch</span> num &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">break</span> L1 <span class="comment">//直接跳出L1</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">continue</span> L1 <span class="comment">// 会直接执行L1下面的语句,但变量仍保持，仍保持刚刚的进行</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">goto</span> L2 <span class="comment">// 会直接执行L2下面的语句,但变量仍保持</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">goto</span> L1 <span class="comment">// 会直接重新执行L1下面的语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"结束"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Go结构体]</title>
    <link href="http://yoursite.com/2021/04/21/Go%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/2021/04/21/Go%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2021-04-21T12:29:40.000Z</published>
    <updated>2021-04-21T13:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="结构体创建、访问与修改"><a href="#结构体创建、访问与修改" class="headerlink" title="结构体创建、访问与修改"></a>结构体创建、访问与修改</h2><p>定义结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">    score <span class="keyword">float32</span></span><br><span class="line">    enrollment time.Time</span><br><span class="line">    name, addr <span class="keyword">string</span> <span class="comment">//多个字段类型相同时可以简写到一行里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明和初始化结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u user <span class="comment">//声明，会用相应类型的默认值初始化struct里的每一个字段</span></span><br><span class="line">u = user&#123;&#125; <span class="comment">//用相应类型的默认值初始化struct里的每一个字段</span></span><br><span class="line">u = user&#123;id: <span class="number">3</span>, name: <span class="string">"zcy"</span>&#125; <span class="comment">//赋值初始化</span></span><br><span class="line">u = user&#123;<span class="number">4</span>, <span class="number">100.0</span>, time.Now(), <span class="string">"zcy"</span>, <span class="string">"beijing"</span>&#125; <span class="comment">//赋值初始化，可以不写字段名，但需要跟结构体定义里的字段顺序一致</span></span><br></pre></td></tr></table></figure><p>访问与修改结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u.enrollment = time.Now() <span class="comment">//给结构体的成员变量赋值</span></span><br><span class="line">fmt.Printf(<span class="string">"id=%d, enrollment=%v, name=%s\n"</span>, u.id, u.enrollment, u.name) <span class="comment">//访问结构体的成员变量</span></span><br></pre></td></tr></table></figure><p>成员方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以把user理解为hello函数的参数，即hello(u user, man string)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">hello</span><span class="params">(man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", my name is "</span> + u.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数里不需要访问user的成员，可以传匿名，甚至_也不传</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_ user)</span> <span class="title">think</span><span class="params">(man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", do you know my name?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为自定义类型添加方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserMap <span class="keyword">map</span>[<span class="keyword">int</span>]User <span class="comment">//自定义类型</span></span><br><span class="line"><span class="comment">//可以给自定义类型添加任意方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(um UserMap)</span> <span class="title">GetUser</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> um[id]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体的可见性：  </p><ul><li>go语言关于可见的统一规则：大写字母开头跨package也可以访问；否则只能本package内部访问。</li><li>结构体名称以大写开头时，package外部可见，在此前提下，结构体中以大写开头在成员变量或成员方法在package外部也可见。  </li></ul><p>匿名结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu <span class="keyword">struct</span> &#123; <span class="comment">//声明stu是一个结构体，但这个结构体是匿名的</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Addr <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">stu.Name = <span class="string">"zcy"</span></span><br><span class="line">stu.Addr = <span class="string">"bj"</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;匿名结构体通常用于只使用一次的情况。<br>结构体中含有匿名成员</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Id <span class="keyword">int</span></span><br><span class="line"><span class="keyword">string</span> <span class="comment">//匿名字段</span></span><br><span class="line"><span class="keyword">float32</span> <span class="comment">//直接使用数据类型作为字段名，所以匿名字段中不能出现重复的数据类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = Student&#123;Id: <span class="number">1</span>, <span class="keyword">string</span>: <span class="string">"zcy"</span>, <span class="keyword">float32</span>: <span class="number">79.5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"anonymous_member string member=%s float member=%f\n"</span>, stu.<span class="keyword">string</span>, stu.<span class="keyword">float32</span>)  <span class="comment">//直接使用数据类型访问匿名成员</span></span><br></pre></td></tr></table></figure><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>创建结构体指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u User</span><br><span class="line">user := &amp;u <span class="comment">//通过取址符&amp;得到指针</span></span><br><span class="line">user = &amp;User&#123; <span class="comment">//直接创建结构体指针</span></span><br><span class="line">    Id: <span class="number">3</span>, Name: <span class="string">"zcy"</span>, addr: <span class="string">"beijing"</span>,</span><br><span class="line">&#125;</span><br><span class="line">user = <span class="built_in">new</span>(User) <span class="comment">//通过new()函数实体化一个结构体，并返回其指针</span></span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数。返回指针是为了避免值拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUser</span><span class="params">(id <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">User</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;User&#123;</span><br><span class="line">Id: id,</span><br><span class="line">Name: name,</span><br><span class="line">addr: <span class="string">"China"</span>,</span><br><span class="line">Score: <span class="number">59</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法接收指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user传的是值，即传的是整个结构体的拷贝。在函数里修改结构体不会影响原来的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(u user, man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.name = <span class="string">"杰克"</span></span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", my name is "</span> + u.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传的是user指针，在函数里修改user的成员会影响原来的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello2</span><span class="params">(u *user, man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.name = <span class="string">"杰克"</span></span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", my name is "</span> + u.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把user理解为hello()的参数，即hello(u user, man string)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">hello</span><span class="params">(man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.name = <span class="string">"杰克"</span></span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", my name is "</span> + u.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以理解为hello2(u *user, man string)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">hello2</span><span class="params">(man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.name = <span class="string">"杰克"</span></span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", my name is "</span> + u.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> paper <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    auther user <span class="comment">//结构体嵌套</span></span><br><span class="line">&#125;</span><br><span class="line">p := <span class="built_in">new</span>(paper)</span><br><span class="line">p.name = <span class="string">"论文标题"</span></span><br><span class="line">p.auther.name = <span class="string">"作者姓名"</span></span><br><span class="line">p.auther.sex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> vedio <span class="keyword">struct</span> &#123;</span><br><span class="line">    length <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    user<span class="comment">//匿名字段,可用数据类型当字段名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体嵌套时字段名冲突的问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v := <span class="built_in">new</span>(vedio)</span><br><span class="line">v.length = <span class="number">13</span></span><br><span class="line">v.name = <span class="string">"视频名称"</span></span><br><span class="line">v.user.sex = <span class="number">0</span> <span class="comment">//通过字段名逐级访问</span></span><br><span class="line">v.sex = <span class="number">0</span> <span class="comment">//对于匿名字段也可以跳过中间字段名，直接访问内部的字段名</span></span><br><span class="line">v.user.name = <span class="string">"作者姓名"</span> <span class="comment">//由于内部、外部结构体都有name这个字段，名字冲突了，所以需要指定中间字段名</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Vedio <span class="keyword">struct</span> &#123;</span><br><span class="line">Length <span class="keyword">int</span></span><br><span class="line">Author User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;Go语言里的赋值都会发生值拷贝。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/deep_copy.png" alt="avatar">  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Vedio <span class="keyword">struct</span> &#123;</span><br><span class="line">Length <span class="keyword">int</span></span><br><span class="line">Author *User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/shallow_copy.png" alt="avatar">  </p><ul><li>深拷贝，拷贝的是值，比如Vedio.Length。</li><li>浅拷贝，拷贝的是指针，比如Vedio.Author。</li><li>深拷贝开辟了新的内存空间，修改操作不影响原先的内存。</li><li>浅拷贝指向的还是原来的内存空间，修改操作直接作用在原内存空间上。</li></ul><p>&#8195;&#8195;传slice，对sclice的3个字段进行了拷贝，拷贝的是底层数组的指针，所以修改底层数组的元素会反应到原数组上。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">users := []User&#123;&#123;Name: <span class="string">"康熙"</span>&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update_users</span><span class="params">(users []User)</span></span> &#123;</span><br><span class="line">    users[<span class="number">0</span>].Name = <span class="string">"光绪"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Go数据类型]</title>
    <link href="http://yoursite.com/2021/04/21/Go%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2021/04/21/Go%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-04-21T12:29:30.000Z</published>
    <updated>2021-04-21T13:11:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go数据类型"><a href="#Go数据类型" class="headerlink" title="Go数据类型"></a>Go数据类型</h1><h2 id="数据类型概览"><a href="#数据类型概览" class="headerlink" title="数据类型概览"></a>数据类型概览</h2><p>基础数据类型</p><table><thead><tr><th align="center">类型</th><th align="center">长度(字节)</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">1</td><td align="center">false</td><td align="center"></td></tr><tr><td align="center">byte</td><td align="center">1</td><td align="center">0</td><td align="center">uint8，取值范围[0,255]</td></tr><tr><td align="center">rune</td><td align="center">4</td><td align="center">0</td><td align="center">Unicode Code Point, int32</td></tr><tr><td align="center">int, uint</td><td align="center">4或8</td><td align="center">0</td><td align="center">32 或 64 位，取决于操作系统</td></tr><tr><td align="center">int8, uint8</td><td align="center">1</td><td align="center">0</td><td align="center">-128 ~ 127, 0 ~ 255</td></tr><tr><td align="center">int16, uint16</td><td align="center">2</td><td align="center">0</td><td align="center">-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td align="center">int32, uint32</td><td align="center">4</td><td align="center">0</td><td align="center">-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td></tr><tr><td align="center">int64, uint64</td><td align="center">8</td><td align="center">0</td><td align="center"></td></tr><tr><td align="center">float32</td><td align="center">4</td><td align="center">0.0</td><td align="center"></td></tr><tr><td align="center">float64</td><td align="center">8</td><td align="center">0.0</td><td align="center"></td></tr><tr><td align="center">complex64</td><td align="center">8</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">complex128</td><td align="center">16</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">uintptr</td><td align="center">4或8</td><td align="center"></td><td align="center">以存储指针的 uint32 或 uint64 整数</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"os arch %s, int size %d\n"</span>, runtime.GOARCH, strconv.IntSize) <span class="comment">//int是4字节还是8字节，取决于操作系统是32位还是64位</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int8</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int16</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">int32</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">int64</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">uint</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">uint8</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> h <span class="keyword">uint16</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">uint32</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">uint64</span> = <span class="number">5</span></span><br><span class="line">fmt.Printf(<span class="string">"a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, g=%d, h=%d, i=%d, j=%d\n"</span>, a, b, c, d, e, f, g, h, i, j)</span><br><span class="line"><span class="keyword">var</span> k <span class="keyword">float32</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> l <span class="keyword">float64</span> = <span class="number">5</span></span><br><span class="line">fmt.Printf(<span class="string">"k=%f, l=%.2f\n"</span>, k, l) <span class="comment">//%.2f保留2位小数</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">complex64</span> = <span class="built_in">complex</span>(<span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line">fmt.Printf(<span class="string">"type of m is %T, type of n is %T\n"</span>, m, n) <span class="comment">//%T输出变量类型</span></span><br><span class="line">fmt.Printf(<span class="string">"m=%v, n=%v\n"</span>, m, n)                       <span class="comment">//按值的本来值输出</span></span><br><span class="line">fmt.Printf(<span class="string">"m=%+v, n=%+v\n"</span>, m, n)                     <span class="comment">//在 %v 基础上，对结构体字段名和值进行展开</span></span><br><span class="line">fmt.Printf(<span class="string">"m=%#v, n=%#v\n"</span>, m, n)                     <span class="comment">//输出 Go 语言语法格式的值</span></span><br><span class="line">fmt.Printf(<span class="string">"m的实部%f, m的虚部%f\n"</span>, <span class="built_in">real</span>(m), <span class="built_in">imag</span>(m))</span><br><span class="line">fmt.Printf(<span class="string">"m的实部%e, m的虚部%g\n"</span>, <span class="built_in">real</span>(m), <span class="built_in">imag</span>(m)) <span class="comment">//%e科学计数法，%g根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</span></span><br><span class="line">o := <span class="literal">true</span>                                        <span class="comment">//等价于var o bool = true</span></span><br><span class="line">fmt.Printf(<span class="string">"o=%t\n"</span>, o)                          <span class="comment">//%t布尔变量</span></span><br><span class="line"><span class="keyword">var</span> pointer unsafe.Pointer = unsafe.Pointer(&amp;a)</span><br><span class="line"><span class="keyword">var</span> p <span class="keyword">uintptr</span> = <span class="keyword">uintptr</span>(pointer)</span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"p=%x pointer=%p ptr=%p\n"</span>, p, pointer, ptr) <span class="comment">//%p输出地址，%x十六进制</span></span><br><span class="line"><span class="keyword">var</span> q <span class="keyword">byte</span> = <span class="number">100</span>                                        <span class="comment">//byte是uint，取值范围[0,255]</span></span><br><span class="line">fmt.Printf(<span class="string">"q=%d, binary of q is %b\n"</span>, q, q)           <span class="comment">//%b输出二进制</span></span><br><span class="line"><span class="keyword">var</span> r <span class="keyword">rune</span> = <span class="string">'☻'</span>                                        <span class="comment">//rune实际上是int32，即可以表示2147483647种字符，包括所有汉字和各种特殊符号</span></span><br><span class="line">fmt.Printf(<span class="string">"r=%d, r=%U\n"</span>, r, r)                        <span class="comment">//%U Unicode 字符</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"I'm 张朝阳"</span></span><br><span class="line">fmt.Printf(<span class="string">"s=%s\n"</span>, s)</span><br><span class="line"><span class="keyword">var</span> t error = errors.New(<span class="string">"my error"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"error is %v\n"</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">"error is %+v\n"</span>, t) <span class="comment">//在 %v 基础上，对结构体字段名和值进行展开</span></span><br><span class="line">fmt.Printf(<span class="string">"error is %#v\n"</span>, t) <span class="comment">//输出 Go 语言语法格式的值</span></span><br></pre></td></tr></table></figure><p>数值型变量的默认值是0，字符串的默认值是空字符串，布尔型变量的默认值是false，引用类型、函数、指针、接口的默认值是nil。数组的默认值取每个元素对应类型的默认值，结构体的默认值取每个成员变量对应类型的默认值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> r <span class="keyword">rune</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> slc []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"default value of int %d\n"</span>, a)</span><br><span class="line">fmt.Printf(<span class="string">"default value of byte %d\n"</span>, b)</span><br><span class="line">fmt.Printf(<span class="string">"default value of float %.2f\n"</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">"default value of bool %t\n"</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">"default value of string [%s]\n"</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">"default value of rune %d, [%c]\n"</span>, r, r)</span><br><span class="line">fmt.Printf(<span class="string">"default int array is %v\n"</span>, arr) <span class="comment">//取每个元素对应类型的默认值</span></span><br><span class="line">fmt.Printf(<span class="string">"default slice is nil %t\n"</span>, slc == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>复合数据类型</p><table><thead><tr><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">array</td><td align="center">取每个元素对应类型的默认值</td><td align="center">值类型</td></tr><tr><td align="center">struct</td><td align="center">取每个成员变量对应类型的默认值</td><td align="center">值类型</td></tr><tr><td align="center">string</td><td align="center">“”</td><td align="center">UTF-8 字符串</td></tr><tr><td align="center">slice</td><td align="center">nil</td><td align="center">引用类型</td></tr><tr><td align="center">map</td><td align="center">nil</td><td align="center">引用类型</td></tr><tr><td align="center">channel</td><td align="center">nil</td><td align="center">引用类型</td></tr><tr><td align="center">interface</td><td align="center">nil</td><td align="center">接口</td></tr><tr><td align="center">function</td><td align="center">nil</td><td align="center">函数</td></tr></tbody></table><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>类型别名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">type</span> semaphore = <span class="keyword">uint8</span></span><br></pre></td></tr></table></figure><p>自定义类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;name <span class="keyword">string</span>;age <span class="keyword">int</span>&#125;  <span class="comment">//用分号把多行代码隔开</span></span><br><span class="line"><span class="keyword">type</span> signal <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> ms <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> add <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是块连续的内存空间，在声明的时候必须指定长度，且长度不能改变。所以数组在声明的时候就可以把内存空间分配好，并赋上默认值，即完成了初始化。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/array.png" alt="avatar">  </p><p>一维数组初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>&#123;&#125; <span class="comment">//数组必须指定长度和类型，且长度和类型指定后不可改变</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>&#125; <span class="comment">//给前2个元素赋值</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>: <span class="number">15</span>, <span class="number">4</span>: <span class="number">30</span>&#125; <span class="comment">//指定index赋值</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [...]<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;<span class="comment">//根据&#123;&#125;里元素的个数推断出数组的长度</span></span><br><span class="line"><span class="keyword">var</span> arr6 = [...]<span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;&#123;&#123;<span class="string">"Tom"</span>, <span class="number">18</span>&#125;, &#123;<span class="string">"Jim"</span>, <span class="number">20</span>&#125;&#125; <span class="comment">//数组的元素类型由匿名结构体给定</span></span><br></pre></td></tr></table></figure><p>二维数组初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5行3列，只给前2行赋值，且前2行的所有列还没有赋满</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line"><span class="comment">//第1维可以用...推测，第2维不能用...</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>访问数组里的元素</p><ul><li>通过index访问<ul><li>首元素 arr[0]</li><li>末元素 arr[len(arr)-1]</li></ul></li><li>访问二维数组里的元素<ul><li>位于第三行第四列的元素 arr[2][3]</li></ul></li></ul><p>遍历数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历数组里的元素</span></span><br><span class="line"><span class="keyword">for</span> i, ele := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"index=%d, element=%d\n"</span>, i, ele)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者这样遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123; <span class="comment">//len(arr)获取数组的长度</span></span><br><span class="line">    fmt.Printf(<span class="string">"index=%d, element=%d\n"</span>, i, arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> row, array := <span class="keyword">range</span> arr &#123; <span class="comment">//先取出某一行</span></span><br><span class="line">    <span class="keyword">for</span> col, ele := <span class="keyword">range</span> array &#123; <span class="comment">//再遍历这一行</span></span><br><span class="line">        fmt.Printf(<span class="string">"arr[%d][%d]=%d\n"</span>, row, col, ele)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;通过for range遍历数组时取得的是数组里每一个元素的拷贝。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, ele := <span class="keyword">range</span> arr &#123; <span class="comment">//ele是arr中元素的拷贝</span></span><br><span class="line">    arr[i] += <span class="number">8</span> <span class="comment">//修改arr里的元素，不影响ele</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d %d %d\n"</span>, i, arr[i], ele)</span><br><span class="line">    ele += <span class="number">1</span> <span class="comment">//修改ele不影响arr</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d %d %d\n"</span>, i, arr[i], ele)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d %d\n"</span>, i, arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在数组上调用cap()函数表示capacity容量，即给数组分配的内存空间可以容纳多少个元素；len()函数代表length长度，即目前数组里有几个元素。由于数组初始化之后长度不会改变，不需要给它预留内存空间，所以len(arr)==cap(arr)。对于多维数组，其cap和len指第一维的长度。<br>数组的长度和类型都是数组类型的一部分，函数传递数组类型时这两部分都必须吻合。<strong>go语言没有按引用传参，全都是按值传参，即传递数组实际上传的是数组的拷贝，当数组的长度很大时，仅传参开销都很大。</strong>如果想修改函数外部的数组，就把它的指针（数组在内存里的地址）传进来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数必须是长度为5的int型数组（注意长度必须是5）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update_array1</span><span class="params">(arr [5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"array in function, address is %p\n"</span>, &amp;arr[<span class="number">0</span>])</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">888</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update_array2</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"array in function, address is %p\n"</span>, &amp;((*arr)[<span class="number">0</span>]))</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">888</span> <span class="comment">//因为传的是数组指针，所以直接在原来的内存空间上进行修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>&#8195;&#8195;切片是一个结构体，包含三个成员变量，array指向一块连续的内存空间，cap表示这块内存的大小，len表示目前该内存里存储了多少元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123; </span><br><span class="line">    array unsafe.Pointer </span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span> </span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/slice.png" alt="avatar">   </p><p>切片的初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> <span class="comment">//切片声明，len=cap=0</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;&#125; <span class="comment">//初始化，len=cap=0</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">//初始化，len=cap=3</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">//初始化，len=3，cap=5</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//初始化，len=cap=5</span></span><br><span class="line">s2d := [][]<span class="keyword">int</span>&#123;</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>, <span class="number">3</span>&#125;, <span class="comment">//二维数组各行的列数相等，但二维切片各行的len可以不等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片相对于数组最大的特点就是可以追加元素，可以自动扩容。追加的元素放到预留的内存空间里，同时len加1。如果预留空间已用完，则会重新申请一块更大的内存空间，capacity大约变成之前的2倍(cap&lt;1024)或1.25倍(cap&gt;1024)。把原内存空间的数据拷贝过来，在新内存空间上执行append操作。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    s[i] = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="comment">//s=[1,2,3]</span></span><br><span class="line">fmt.Printf(<span class="string">"s[0] address %p, s=%v\n"</span>, &amp;s[<span class="number">0</span>], s)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">capacity还够用，直接把追加的元素放到预留的内存空间上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//可以一次append多个元素</span></span><br><span class="line">fmt.Printf(<span class="string">"s[0] address %p, s=%v\n"</span>, &amp;s[<span class="number">0</span>], s)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">capacity不够用了，得申请一片新的内存，把老数据先拷贝过来，在新内存上执行append操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">6</span>)</span><br><span class="line">fmt.Printf(<span class="string">"s[0] address %p, s=%v\n"</span>, &amp;s[<span class="number">0</span>], s)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//探究capacity扩容规律</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expansion</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">prevCap := <span class="built_in">cap</span>(s)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, i)</span><br><span class="line">currCap := <span class="built_in">cap</span>(s)</span><br><span class="line"><span class="keyword">if</span> currCap &gt; prevCap &#123;</span><br><span class="line"><span class="comment">//每次扩容都是扩到原先的2倍</span></span><br><span class="line">fmt.Printf(<span class="string">"capacity从%d变成%d\n"</span>, prevCap, currCap)</span><br><span class="line">prevCap = currCap</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">brr := <span class="built_in">append</span>(arr, <span class="number">8</span>) <span class="comment">//arr和brr共享底层数组，但它们的len不同</span></span><br></pre></td></tr></table></figure><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/append.png" alt="append"></p><p>&#8195;&#8195;通过指定起止下标，可以从大切片中截取一个子切片。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)<span class="comment">//len=3, cap=5</span></span><br><span class="line">sub_slice = s[<span class="number">1</span>:<span class="number">3</span>]<span class="comment">//len=2, cap=4</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;刚开始，子切片和母切片共享底层的内存空间，修改子切片会反映到母切片上，在子切片上执行append会把新元素放到母切片预留的内存空间上。当子切片不断执行append，耗完了母切片预留的内存空间，子切片跟母切片就会发生内存分离，此后两个切片没有任何关系。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/sub_slice.png" alt="avatar"> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub_slice</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">截取一部分，创造子切片，此时子切片与母切片(或母数组)共享底层内存空间，母切片的capacity子切片可能直接用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">s[i] = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="comment">//s=[1,2,3]</span></span><br><span class="line">fmt.Printf(<span class="string">"s[1] address %p\n"</span>, &amp;s[<span class="number">1</span>])</span><br><span class="line">sub_slice := s[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//从切片创造子切片，len=2，cap=4</span></span><br><span class="line">fmt.Printf(<span class="string">"len %d cap %d\n"</span>, <span class="built_in">len</span>(sub_slice), <span class="built_in">cap</span>(sub_slice))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">母切片的capacity还允许子切片执行append操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sub_slice = <span class="built_in">append</span>(sub_slice, <span class="number">6</span>, <span class="number">7</span>) <span class="comment">//可以一次append多个元素</span></span><br><span class="line">sub_slice[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">fmt.Printf(<span class="string">"s=%v, sub_slice=%v, s[1] address %p, sub_slice[0] address %p\n"</span>, s, sub_slice, &amp;s[<span class="number">1</span>], &amp;sub_slice[<span class="number">0</span>])</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">母切片的capacity用完了，子切片再执行append就得申请一片新的内存，把老数据先拷贝过来，在新内存上执行append操作。此时的append操作跟母切片没有任何关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sub_slice = <span class="built_in">append</span>(sub_slice, <span class="number">8</span>)</span><br><span class="line">sub_slice[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">fmt.Printf(<span class="string">"s=%v, sub_slice=%v, s[1] address %p, sub_slice[0] address %p\n"</span>, s, sub_slice, &amp;s[<span class="number">1</span>], &amp;sub_slice[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"arr[1] address %p\n"</span>, &amp;arr[<span class="number">1</span>])</span><br><span class="line">sub_slice = arr[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//从数组创造子切片，len=cap=2</span></span><br><span class="line">fmt.Printf(<span class="string">"len %d cap %d\n"</span>, <span class="built_in">len</span>(sub_slice), <span class="built_in">cap</span>(sub_slice))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">母数组的capacity还允许子切片执行append操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sub_slice = <span class="built_in">append</span>(sub_slice, <span class="number">6</span>, <span class="number">7</span>) <span class="comment">//可以一次append多个元素</span></span><br><span class="line">sub_slice[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">fmt.Printf(<span class="string">"arr=%v, sub_slice=%v, arr[1] address %p, sub_slice[0] address %p\n"</span>, arr, sub_slice, &amp;arr[<span class="number">1</span>], &amp;sub_slice[<span class="number">0</span>])</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">母数组的capacity用完了，子切片再执行append就得申请一片新的内存，把老数据先拷贝过来，在新内存上执行append操作。此时的append操作跟母数组没有任何关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sub_slice = <span class="built_in">append</span>(sub_slice, <span class="number">8</span>)</span><br><span class="line">sub_slice[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">fmt.Printf(<span class="string">"arr=%v, sub_slice=%v, arr[1] address %p, sub_slice[0] address %p\n"</span>, arr, sub_slice, &amp;arr[<span class="number">1</span>], &amp;sub_slice[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;go语言函数传参，传的都是值，即传切片会把切片的{arrayPointer, len, cap}这3个字段拷贝一份传进来。由于传的是底层数组的指针，所以可以直接修改底层数组里的元素。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update_slice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">888</span></span><br><span class="line">&#125;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">update_slice(s)</span><br><span class="line">fmt.Printf(<span class="string">"s=%v\n"</span>, s)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">"address of slice %p, address of array %p %p\n"</span>, &amp;s, &amp;s[<span class="number">0</span>], s)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">"address of slice %p, address of array %p %p\n"</span>, &amp;s, &amp;s[<span class="number">0</span>], s)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">"address of slice %p, address of array %p %p\n"</span>, &amp;s, &amp;s[<span class="number">0</span>], s)</span><br></pre></td></tr></table></figure><p>获取切片的地址用&amp;s；获取切片底层数组的地址用&amp;s[0]，或直接把s当地址打印。  </p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串里可以包含任意Unicode字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">" My name is 张朝阳☻"</span></span><br></pre></td></tr></table></figure><p>字符串里可以包含转义字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"He say:\"I'm fine.\" \n\\Thank\tyou.\\"</span></span><br></pre></td></tr></table></figure><p>字符串也可以用反引号来定义，反引号里的转义字符无效。反引号里的内容原封不动地输出，包括空白符和换行符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">`here is first line. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  there is third line.</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>字符串常用操作</p><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">len(str)</td><td align="center">求长度</td></tr><tr><td align="center">strings.Split</td><td align="center">分割</td></tr><tr><td align="center">strings.Contains</td><td align="center">判断是否包含</td></tr><tr><td align="center">strings.HasPrefix,strings.HasSuffix</td><td align="center">前缀/后缀判断</td></tr><tr><td align="center">strings.Index(),strings.LastIndex()</td><td align="center">子串出现的位置</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"born to win, born to die."</span></span><br><span class="line">fmt.Printf(<span class="string">"sentence length %d\n"</span>, <span class="built_in">len</span>(s))</span><br><span class="line">fmt.Printf(<span class="string">"\"s\" length %d\n"</span>, <span class="built_in">len</span>(<span class="string">"s"</span>))  <span class="comment">//英文字母的长度为1</span></span><br><span class="line">fmt.Printf(<span class="string">"\"中\"  length %d\n"</span>, <span class="built_in">len</span>(<span class="string">"中"</span>)) <span class="comment">//一个汉字占3个长度</span></span><br><span class="line">arr := strings.Split(s, <span class="string">" "</span>)</span><br><span class="line">fmt.Printf(<span class="string">"arr[3]=%s\n"</span>, arr[<span class="number">3</span>])</span><br><span class="line">fmt.Printf(<span class="string">"contain die %t\n"</span>, strings.Contains(s, <span class="string">"die"</span>))          <span class="comment">//包含子串</span></span><br><span class="line">fmt.Printf(<span class="string">"contain wine %t\n"</span>, strings.Contains(s, <span class="string">"wine"</span>))        <span class="comment">//包含子串</span></span><br><span class="line">fmt.Printf(<span class="string">"first index of born %d\n"</span>, strings.Index(s, <span class="string">"born"</span>))    <span class="comment">//寻找子串第一次出现的位置</span></span><br><span class="line">fmt.Printf(<span class="string">"last index of born %d\n"</span>, strings.LastIndex(s, <span class="string">"born"</span>)) <span class="comment">//寻找子串最后一次出现的位置</span></span><br><span class="line">fmt.Printf(<span class="string">"begin with born %t\n"</span>, strings.HasPrefix(s, <span class="string">"born"</span>))    <span class="comment">//以xxx开头</span></span><br><span class="line">fmt.Printf(<span class="string">"end with die. %t\n"</span>, strings.HasSuffix(s, <span class="string">"die."</span>))      <span class="comment">//以xxx结尾</span></span><br></pre></td></tr></table></figure><p>把多个字符串拼接成一个长的字符串有多种方式。</p><ol><li>加号连接。</li><li>func fmt.Sprintf(format string, a …interface{}) string</li><li>func strings.Join(elems []string, sep string) string</li><li>当有大量的string需要拼接时，用strings.Builder效率最高</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"Hello"</span></span><br><span class="line">s2 := <span class="string">"how"</span></span><br><span class="line">s3 := <span class="string">"are"</span></span><br><span class="line">s4 := <span class="string">"you"</span></span><br><span class="line">merged := s1 + <span class="string">" "</span> + s2 + <span class="string">" "</span> + s3 + <span class="string">" "</span> + s4</span><br><span class="line">fmt.Println(merged)</span><br><span class="line">merged = fmt.Sprintf(<span class="string">"%s %s %s %s"</span>, s1, s2, s3, s4)</span><br><span class="line">fmt.Println(merged)</span><br><span class="line">merged = strings.Join([]<span class="keyword">string</span>&#123;s1, s2, s3, s4&#125;, <span class="string">" "</span>)</span><br><span class="line">fmt.Println(merged)</span><br><span class="line"><span class="comment">//当有大量的string需要拼接时，用strings.Builder效率最高</span></span><br><span class="line">sb := strings.Builder&#123;&#125;</span><br><span class="line">sb.WriteString(s1)</span><br><span class="line">sb.WriteString(<span class="string">" "</span>)</span><br><span class="line">sb.WriteString(s2)</span><br><span class="line">sb.WriteString(<span class="string">" "</span>)</span><br><span class="line">sb.WriteString(s3)</span><br><span class="line">sb.WriteString(<span class="string">" "</span>)</span><br><span class="line">sb.WriteString(s4)</span><br><span class="line">sb.WriteString(<span class="string">" "</span>)</span><br><span class="line">merged = sb.String()</span><br><span class="line">fmt.Println(merged)</span><br></pre></td></tr></table></figure><p>string中每个元素叫“字符”，字符有两种：</p><ol><li>byte：1个字节， 代表ASCII码的一个字符。</li><li>rune：4个字节，代表一个UTF-8字符，一个汉字可用一个rune表示。</li></ol><p>string是常量，不能修改其中的字符。<br>string可以转换为[]byte或[]rune类型。<br>string底层是byte数组，string的长度就是该byte数组的长度， UTF-8编码下一个汉字占3个byte，即一个汉字占3个长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"My name is 张朝阳"</span></span><br><span class="line">arr := []<span class="keyword">byte</span>(s1)</span><br><span class="line">brr := []<span class="keyword">rune</span>(s1)</span><br><span class="line">fmt.Printf(<span class="string">"last byte %d\n"</span>, arr[<span class="built_in">len</span>(arr)<span class="number">-1</span>]) <span class="comment">//string可以转换为[]byte或[]rune类型</span></span><br><span class="line">fmt.Printf(<span class="string">"last byte %c\n"</span>, arr[<span class="built_in">len</span>(arr)<span class="number">-1</span>]) <span class="comment">//byte或rune可以转为string</span></span><br><span class="line">fmt.Printf(<span class="string">"last rune %d\n"</span>, brr[<span class="built_in">len</span>(brr)<span class="number">-1</span>])</span><br><span class="line">fmt.Printf(<span class="string">"last rune %c\n"</span>, brr[<span class="built_in">len</span>(brr)<span class="number">-1</span>])</span><br><span class="line">L := <span class="built_in">len</span>(s1)</span><br><span class="line">fmt.Printf(<span class="string">"string len %d byte array len %d rune array len %d\n"</span>, L, <span class="built_in">len</span>(arr), <span class="built_in">len</span>(brr))</span><br><span class="line"><span class="keyword">for</span> _, ele := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%c "</span>, ele) <span class="comment">//string中的每个元素是字符</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; L; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%c "</span>, s1[i]) <span class="comment">//[i]前面应该出现数组或切片，这里自动把string转成了[]byte（而不是[]rune）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>强制类型转换的基本方法就是把目标类型放在变量前面，把变量括起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">9</span></span><br><span class="line"><span class="keyword">var</span> by <span class="keyword">byte</span> = <span class="keyword">byte</span>(i)<span class="comment">//int转为byte</span></span><br><span class="line">i = <span class="keyword">int</span>(by)<span class="comment">//byte转为int</span></span><br></pre></td></tr></table></figure><ul><li>低精度向高精度转换没问题，高精度向低精度转换会丢失位数。</li><li>无符号向有符号转换，最高位是符号位。</li><li>byte和int可以互相转换。</li><li>float和int可以互相转换，小数位会丢失。</li><li>bool和int不能相互转换。</li><li>不同长度的int或float之间可以相互转换。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度向低精度转换，数字很小时这种转换没问题</span></span><br><span class="line"><span class="keyword">var</span> ua <span class="keyword">uint64</span> = <span class="number">1</span></span><br><span class="line">i8 := <span class="keyword">int8</span>(ua)</span><br><span class="line">fmt.Printf(<span class="string">"i8=%d\n"</span>, i8)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最高位的1变成了符号位</span></span><br><span class="line">ua = <span class="keyword">uint64</span>(math.MaxUint64)</span><br><span class="line">i64 := <span class="keyword">int64</span>(ua)</span><br><span class="line">fmt.Printf(<span class="string">"i64=%d\n"</span>, i64)</span><br><span class="line"></span><br><span class="line"><span class="comment">//位数丢失</span></span><br><span class="line">ui32 := <span class="keyword">uint32</span>(ua)</span><br><span class="line">fmt.Printf(<span class="string">"ui32=%d\n"</span>, ui32)</span><br><span class="line"></span><br><span class="line"><span class="comment">//单个字符可以转为int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="keyword">int</span>(<span class="string">'a'</span>)</span><br><span class="line">fmt.Printf(<span class="string">"i=%d\n"</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//bool和int不能相互转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//byte和int可以互相转换</span></span><br><span class="line"><span class="keyword">var</span> by <span class="keyword">byte</span> = <span class="keyword">byte</span>(i)</span><br><span class="line">i = <span class="keyword">int</span>(by)</span><br><span class="line">fmt.Printf(<span class="string">"i=%d\n"</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//float和int可以互相转换，小数位会丢失</span></span><br><span class="line"><span class="keyword">var</span> ft <span class="keyword">float32</span> = <span class="keyword">float32</span>(i)</span><br><span class="line">i = <span class="keyword">int</span>(ft)</span><br><span class="line">fmt.Printf(<span class="string">"i=%d\n"</span>, i)</span><br></pre></td></tr></table></figure><p>string和其他数据类型互转。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> i64 <span class="keyword">int64</span> = <span class="keyword">int64</span>(i)</span><br><span class="line"><span class="comment">//int转string</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = strconv.Itoa(i) <span class="comment">//内部调用FormatInt</span></span><br><span class="line">s = strconv.FormatInt(i64, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//string转int</span></span><br><span class="line">i, err = strconv.Atoi(s)</span><br><span class="line"><span class="comment">//string转int64</span></span><br><span class="line">i64, err = strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//float转string</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">8.123456789</span></span><br><span class="line">s = strconv.FormatFloat(f, <span class="string">'f'</span>, <span class="number">2</span>, <span class="number">64</span>) <span class="comment">//保留2位小数</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="comment">//string转float</span></span><br><span class="line">f, err = strconv.ParseFloat(s, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//string&lt;--&gt;[]byte</span></span><br><span class="line"><span class="keyword">var</span> arr []<span class="keyword">byte</span> = []<span class="keyword">byte</span>(s)</span><br><span class="line">s = <span class="keyword">string</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//string&lt;--&gt;[]rune</span></span><br><span class="line"><span class="keyword">var</span> brr []<span class="keyword">rune</span> = []<span class="keyword">rune</span>(s)</span><br><span class="line">s = <span class="keyword">string</span>(brr)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"err %v\n"</span>, err)</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>go map的底层实现是hash table，根据key查找value的时间复杂度是O(1)。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/map.png" alt="avatar">   </p><p>map的初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> <span class="comment">//声明map，指定key和value的数据类型</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//初始化，容量为0</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">200</span>) <span class="comment">//初始化，容量为200。强烈建议初始化时给一个合适的容量，减少扩容的概率</span></span><br><span class="line">m = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"语文"</span>: <span class="number">0</span>, <span class="string">"数学"</span>: <span class="number">39</span>&#125; <span class="comment">//初始化时直接赋值</span></span><br></pre></td></tr></table></figure><p>添加和删除key</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="string">"英语"</span>] = <span class="number">59</span> <span class="comment">//往map里添加key-value对</span></span><br><span class="line">m [<span class="string">"英语"</span>] = <span class="number">70</span> <span class="comment">//会覆盖之前的值</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"数学"</span>) <span class="comment">//从map里删除key-value对</span></span><br></pre></td></tr></table></figure><p>len(m)获取map的长度，go不支持对map上执行cap函数。<br>读取key对应的value时，如果key不存在，则返回value类型的默认值，所以强烈建议先判断key是否存在。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value, exists := m[<span class="string">"语文"</span>]; exists &#123;</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"map里不存在[语文]这个key"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历map</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"-----------"</span>)</span><br><span class="line"><span class="comment">//多次遍历map返回的顺序是不一样的，但相对顺序是一样的，因为每次随机选择一个开始位置，然后顺序遍历</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"-----------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一边遍历一边修改</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    m[key] = value + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"-----------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//for range取得的是值拷贝</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    value = value + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map中的key可以是任意能够用==操作符比较的类型，不能是函数、map、切片，以及包含上述3中类型成员变量的的struct。map的value可以是任意类型。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="keyword">type</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">type</span> s []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[i]f</span><br><span class="line">fmt.Println(m1)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 函数、map、切片不能当key **/</span></span><br><span class="line"><span class="comment">// var m2 map[f]bool</span></span><br><span class="line"><span class="comment">// fmt.Println(m2)</span></span><br><span class="line"><span class="comment">// var m3 map[m]bool</span></span><br><span class="line"><span class="comment">// fmt.Println(m3)</span></span><br><span class="line"><span class="comment">// var m4 map[s]bool</span></span><br><span class="line"><span class="comment">// fmt.Println(m4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">scores <span class="keyword">float32</span> <span class="comment">//如果scores是slice，则user不能作为map的key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := user&#123;&#125;</span><br><span class="line">m5 := <span class="built_in">make</span>(<span class="keyword">map</span>[user]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m5[u] = <span class="number">5</span></span><br><span class="line">fmt.Println(m5)</span><br></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>&#8195;&#8195;channel(管道)底层是一个环形队列(先进先出)，send(插入)和recv(取走)从同一个位置沿同一个方向顺序执行。sendx表示最后一次插入元素的位置，recvx表示最后一次取走元素的位置。<br><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/channel.png" alt="avatar">  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//管道的声明</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">8</span>) <span class="comment">//管道的初始化，环形队列里可容纳8个int</span></span><br><span class="line">ch &lt;- <span class="number">1</span>                <span class="comment">//往管道里写入(send)数据</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line">ch &lt;- <span class="number">5</span></span><br><span class="line">v := &lt;-ch <span class="comment">//从管道里取走(recv)数据</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">v = &lt;-ch</span><br><span class="line">fmt.Println(v)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read_only := <span class="built_in">make</span> (&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)   <span class="comment">//定义只读的channel</span></span><br><span class="line">write_only := <span class="built_in">make</span> (<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)   <span class="comment">//定义只写的channel</span></span><br></pre></td></tr></table></figure><p>定义只读和只写的channel意义不大，一般用于在参数传递中。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能向channel里写数据 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">    c &lt;- <span class="number">1</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//只能取channel中的数据 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">_ = &lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个只读channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过for range遍历并取走管道里的元素，当管道为空且被close后，for循环退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"><span class="comment">//遍历并取走（receive）管道里的元素。当管道里已无剩余元素且没有close管道时，receive操作会一直阻塞，最终报deadlock。当管道为空且被close后，for循环退出。</span></span><br><span class="line"><span class="keyword">for</span> ele := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(ele)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slice、map和channel是go语言里的3种引用类型，都可以通过make函数来进行初始化（申请内存分配）。因为它们都包含一个指向底层数据结构的指针，所以称之为“引用”类型。引用类型未初始化时都是nil，可以对它们执行len()函数，返回0。</p>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Go基础语法]</title>
    <link href="http://yoursite.com/2021/04/21/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2021/04/21/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2021-04-21T12:29:20.000Z</published>
    <updated>2021-04-21T13:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go基础语法"><a href="#Go基础语法" class="headerlink" title="Go基础语法"></a>Go基础语法</h1><h2 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h2><p>go变量、常量、自定义类型、包、函数的命名方式必须遵循以下规则：</p><ol><li>首字符可以是任意Unicode字符或下划线。</li><li>首字符之外的部分可以是Unicode字符、下划线或数字。</li><li>名字的长度无限制。</li></ol><blockquote><p>理论上名字里可以有汉字，甚至可以全是汉字，但实际中不要这么做。</p></blockquote><p>Go语言关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break  default  func  interface  select  case  defer  go  map  struct  chan  else  goto  package  switch  const  if  range  type  continue  for  import  return  fallthrough  var</span><br></pre></td></tr></table></figure><p>常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true  false  iota  nil</span><br></pre></td></tr></table></figure><p>数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int  int8  int16  int32  int64  uint  uint8  uint16  uint32  uint64  uintptr  float32  float64  complex128  complex64  bool  byte  rune  string  error</span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make  len  cap  new  append  copy  close  delete  complex  real  imag  panic  recover</span><br></pre></td></tr></table></figure><h2 id="操作符与表达式"><a href="#操作符与表达式" class="headerlink" title="操作符与表达式"></a>操作符与表达式</h2><p>算法术运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">相加</td></tr><tr><td align="center">-</td><td align="center">相减</td></tr><tr><td align="center">*</td><td align="center">相乘</td></tr><tr><td align="center">/</td><td align="center">相除</td></tr><tr><td align="center">%</td><td align="center">求余</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arithmetic 算术运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arithmetic</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = a + b</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">float32</span> = a - b</span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">float32</span> = a * b</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = a / b</span><br><span class="line">fmt.Printf(<span class="string">"a=%.3f, b=%.3f, c=%.3f, d=%.3f, e=%.3f, f=%.3f\n"</span>, a, b, c, d, e, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关系运算符</p><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">==</td><td align="left">检查两个值是否相等，如果相等返回 True 否则返回 False</td></tr><tr><td align="center">!=</td><td align="left">检查两个值是否不相等，如果不相等返回 True 否则返回 False</td></tr><tr><td align="center">&gt;</td><td align="left">检查左边值是否大于右边值，如果是返回 True 否则返回 False</td></tr><tr><td align="center">&gt;=</td><td align="left">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False</td></tr><tr><td align="center">&lt;</td><td align="left">检查左边值是否小于右边值，如果是返回 True 否则返回 False</td></tr><tr><td align="center">&lt;=</td><td align="left">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//relational 关系运算符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">relational</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = <span class="number">8</span></span><br><span class="line">fmt.Printf(<span class="string">"a==b吗 %t\n"</span>, a == b)</span><br><span class="line">fmt.Printf(<span class="string">"a!=b吗 %t\n"</span>, a != b)</span><br><span class="line">fmt.Printf(<span class="string">"a&gt;b吗 %t\n"</span>, a &gt; b)</span><br><span class="line">fmt.Printf(<span class="string">"a&gt;=b吗 %t\n"</span>, a &gt;= b)</span><br><span class="line">fmt.Printf(<span class="string">"a&lt;c吗 %t\n"</span>, a &lt; b)</span><br><span class="line">fmt.Printf(<span class="string">"a&lt;=c吗 %t\n"</span>, a &lt;= c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑运算符  </p><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="left">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False</td></tr><tr><td align="center">||</td><td align="left">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False</td></tr><tr><td align="center">!</td><td align="left">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//logistic 逻辑运算符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logistic</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = <span class="number">8</span></span><br><span class="line">fmt.Printf(<span class="string">"a&gt;b &amp;&amp; b&gt;c吗 %t\n"</span>, a &gt; b &amp;&amp; b &gt; c)</span><br><span class="line">fmt.Printf(<span class="string">"a&gt;b || b&gt;c吗 %t\n"</span>, a &gt; b || b &gt; c)</span><br><span class="line">fmt.Printf(<span class="string">"a&gt;b不成立，对吗 %t\n"</span>, !(a &gt; b))</span><br><span class="line">fmt.Printf(<span class="string">"b&gt;c不成立，对吗 %t\n"</span>, !(b &gt; c))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位运算符</p><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="left">参与运算的两数各对应的二进位相与（两位均为1才为1）</td></tr><tr><td align="center">|</td><td align="left">参与运算的两数各对应的二进位相或（两位有一个为1就为1）</td></tr><tr><td align="center">^</td><td align="left">参与运算的两数各对应的二进位相异或，当两对应的二进位相同时为0，不同时为1。作为一元运算符时表示按位取反，，符号位也跟着变</td></tr><tr><td align="center">&lt;&lt;</td><td align="left">左移n位就是乘以2的n次方。a&lt;&lt;b是把a的各二进位全部左移b位，高位丢弃，低位补0。通过左移，符号位可能会变</td></tr><tr><td align="center">&gt;&gt;</td><td align="left">右移n位就是除以2的n次方。a&gt;&gt;b是把a的各二进位全部右移b位，正数高位补0，负数高位补1</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bit_op 位运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bit_op</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"os arch %s, int size %d\n"</span>, runtime.GOARCH, strconv.IntSize) <span class="comment">//int是4字节还是8字节，取决于操作系统是32位还是64位</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int32</span> = <span class="number">260</span></span><br><span class="line">fmt.Printf(<span class="string">"260     %s\n"</span>, util.BinaryFormat(a))</span><br><span class="line">fmt.Printf(<span class="string">"-260    %s\n"</span>, util.BinaryFormat(-a)) <span class="comment">//负数用补码表示。在对应正数二进制表示的基础上，按拉取反，再末位加1</span></span><br><span class="line">fmt.Printf(<span class="string">"260&amp;4   %s\n"</span>, util.BinaryFormat(a&amp;<span class="number">4</span>))</span><br><span class="line">fmt.Printf(<span class="string">"260|3   %s\n"</span>, util.BinaryFormat(a|<span class="number">3</span>))</span><br><span class="line">fmt.Printf(<span class="string">"260^7   %s\n"</span>, util.BinaryFormat(a^<span class="number">7</span>))     <span class="comment">//^作为二元运算符时表示异或</span></span><br><span class="line">fmt.Printf(<span class="string">"^-260   %s\n"</span>, util.BinaryFormat(^-a))     <span class="comment">//^作为一元运算符时表示按位取反，符号位也跟着变</span></span><br><span class="line">fmt.Printf(<span class="string">"-260&gt;&gt;10 %s\n"</span>, util.BinaryFormat(-a&gt;&gt;<span class="number">10</span>)) <span class="comment">//正数高位补0，负数高位补1</span></span><br><span class="line">fmt.Printf(<span class="string">"-260&lt;&lt;3 %s\n"</span>, util.BinaryFormat(-a&lt;&lt;<span class="number">3</span>))   <span class="comment">//负数左移，可能变成正数</span></span><br><span class="line"><span class="comment">//go语言没有循环（无符号）左/右移符号   &gt;&gt;&gt;  &lt;&lt;&lt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位运算的应用场景：  </p><ul><li>逻辑控制（运算快，省CPU）</li><li>bitmap和bloom filter（省内存）</li></ul><p>总之，位运算适用于对性能要求高的场景。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bit_application</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> gender <span class="keyword">string</span> = <span class="string">"男"</span></span><br><span class="line"><span class="keyword">var</span> degree <span class="keyword">string</span> = <span class="string">"本科"</span></span><br><span class="line"><span class="keyword">var</span> is985 <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> condition1 <span class="keyword">bool</span> = gender == <span class="string">"男"</span></span><br><span class="line"><span class="keyword">var</span> condition2 <span class="keyword">bool</span> = gender == <span class="string">"男"</span> &amp;&amp; is985</span><br><span class="line"><span class="keyword">var</span> condition3 <span class="keyword">bool</span> = gender == <span class="string">"男"</span> &amp;&amp; degree == <span class="string">"硕士"</span> &amp;&amp; is985</span><br><span class="line">fmt.Printf(<span class="string">"满足条件1 %t\n"</span>, condition1)</span><br><span class="line">fmt.Printf(<span class="string">"满足条件2 %t\n"</span>, condition2)</span><br><span class="line">fmt.Printf(<span class="string">"满足条件3 %t\n"</span>, condition3)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> gender <span class="keyword">byte</span> = <span class="number">1</span>      <span class="comment">//末位，1：男，0：女</span></span><br><span class="line"><span class="keyword">var</span> degree <span class="keyword">byte</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span> <span class="comment">//倒数第二位，1：硕士，0：本科</span></span><br><span class="line"><span class="keyword">var</span> is985 <span class="keyword">byte</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>  <span class="comment">//倒数第三位，1：是985，2：不是985</span></span><br><span class="line"><span class="keyword">var</span> man <span class="keyword">byte</span> = gender | is985</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> condition1 <span class="keyword">byte</span> = gender</span><br><span class="line"><span class="keyword">var</span> condition2 <span class="keyword">byte</span> = gender | is985</span><br><span class="line"><span class="keyword">var</span> condition3 <span class="keyword">byte</span> = gender | is985 | degree</span><br><span class="line">fmt.Printf(<span class="string">"满足条件1 %t\n"</span>, man&amp;condition1 == condition1)</span><br><span class="line">fmt.Printf(<span class="string">"满足条件2 %t\n"</span>, man&amp;condition2 == condition2)</span><br><span class="line">fmt.Printf(<span class="string">"满足条件3 %t\n"</span>, man&amp;condition3 == condition3)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值运算符</p><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">=</td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td align="center">+=</td><td align="left">相加后再赋值</td></tr><tr><td align="center">-=</td><td align="left">相减后再赋值</td></tr><tr><td align="center">*=</td><td align="left">相乘后再赋值</td></tr><tr><td align="center">/=</td><td align="left">相除后再赋值</td></tr><tr><td align="center">%=</td><td align="left">求余后再赋值</td></tr><tr><td align="center">&lt;&lt;=</td><td align="left">左移后赋值</td></tr><tr><td align="center">&gt;&gt;=</td><td align="left">右移后赋值</td></tr><tr><td align="center">&amp;=</td><td align="left">按位与后赋值</td></tr><tr><td align="center">|=</td><td align="left">按位或后赋值</td></tr><tr><td align="center">^=</td><td align="left">按位异或后赋值</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//assignment 赋值运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assignment</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a += b</span><br><span class="line">fmt.Printf(<span class="string">"a+=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a -= b</span><br><span class="line">fmt.Printf(<span class="string">"a-=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a *= b</span><br><span class="line">fmt.Printf(<span class="string">"a*=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a /= b</span><br><span class="line">fmt.Printf(<span class="string">"a/=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a %= b</span><br><span class="line">fmt.Printf(<span class="string">"a%%=b %d\n"</span>, a) <span class="comment">//%在fmt里有特殊含意，所以需要前面再加个%转义一下</span></span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a &lt;&lt;= b</span><br><span class="line">fmt.Printf(<span class="string">"a&lt;&lt;=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a &gt;&gt;= b</span><br><span class="line">fmt.Printf(<span class="string">"a&gt;&gt;=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a &amp;= b</span><br><span class="line">fmt.Printf(<span class="string">"a&amp;=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a |= b</span><br><span class="line">fmt.Printf(<span class="string">"a|=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a ^= b</span><br><span class="line">fmt.Printf(<span class="string">"a^=b %d\n"</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量、常量、字面量"><a href="#变量、常量、字面量" class="headerlink" title="变量、常量、字面量"></a>变量、常量、字面量</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><table><thead><tr><th align="center">类型</th><th align="center">go变量类型</th><th align="center">fmt输出</th></tr></thead><tbody><tr><td align="center">整型</td><td align="center">int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64</td><td align="center">%d</td></tr><tr><td align="center">浮点型</td><td align="center">float32 float64</td><td align="center">%f %e %g</td></tr><tr><td align="center">布尔型</td><td align="center">bool</td><td align="center">%t</td></tr><tr><td align="center">指针</td><td align="center">uintptr</td><td align="center">%p</td></tr><tr><td align="center">引用</td><td align="center">map slice channel</td><td align="center">%v</td></tr><tr><td align="center">字节</td><td align="center">byte</td><td align="center">%c</td></tr><tr><td align="center">任意字符</td><td align="center">rune</td><td align="center">%c</td></tr><tr><td align="center">字符串</td><td align="center">string</td><td align="center">%s</td></tr><tr><td align="center">错误</td><td align="center">error</td><td align="center">%v</td></tr></tbody></table><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>Go语言变量必须先声明再使用，所谓使用指读取或修改。<br>标题声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> </span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> </span><br><span class="line"><span class="keyword">var</span> isOk <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p>批量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ( </span><br><span class="line">name <span class="keyword">string</span> </span><br><span class="line">age <span class="keyword">int</span> </span><br><span class="line">isOk <span class="keyword">bool</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>如果声明后未显式初始化，数值型初始化0，字符串初始化为空字符串，布尔型初始化为false，引用类型、函数、指针、接口初始化为nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span>=<span class="string">"china"</span>  <span class="comment">//初始化一个变量</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"china"</span>  <span class="comment">//类型推断为string</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="keyword">int</span>=<span class="number">3</span>,<span class="number">7</span>  <span class="comment">//初始化多个变量</span></span><br><span class="line"><span class="keyword">var</span> a,b=<span class="string">"china"</span>,<span class="number">7</span>  <span class="comment">//初始化多个变量，每个变量都单独地执行类型推断</span></span><br></pre></td></tr></table></figure><p>函数内部的变量(非全局变量)可以通过:=声明并初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>下划线表示匿名变量。匿名变量不占命名空间，不会分配内存，因此可以重复使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_=<span class="number">2</span>+<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量在定义时必须赋值，且程序运行期间其值不能改变。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI <span class="keyword">float32</span>=<span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    PI=<span class="number">3.14</span></span><br><span class="line">    E=<span class="number">2.71</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a=<span class="number">100</span></span><br><span class="line">    b<span class="comment">//100，跟上一行的值相同</span></span><br><span class="line">    c<span class="comment">//100，跟上一行的值相同</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a=<span class="literal">iota</span><span class="comment">//0</span></span><br><span class="line">    b<span class="comment">//1</span></span><br><span class="line">    c<span class="comment">//2</span></span><br><span class="line">    d<span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a=<span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    b<span class="comment">//1</span></span><br><span class="line">    _<span class="comment">//2</span></span><br><span class="line">    d<span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a=<span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    b=<span class="number">30</span>    </span><br><span class="line">    c=<span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">    d<span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    _=<span class="literal">iota</span><span class="comment">// iota =0</span></span><br><span class="line">    KB=<span class="number">1</span>&lt;&lt;(<span class="number">10</span>* <span class="literal">iota</span>) <span class="comment">// iota =1</span></span><br><span class="line">    MB=<span class="number">1</span>&lt;&lt;(<span class="number">10</span>* <span class="literal">iota</span>) <span class="comment">// iota =2</span></span><br><span class="line">    GB=<span class="number">1</span>&lt;&lt;(<span class="number">10</span>* <span class="literal">iota</span>) <span class="comment">// iota =3</span></span><br><span class="line">    TB=<span class="number">1</span>&lt;&lt;(<span class="number">10</span>* <span class="literal">iota</span>) <span class="comment">// iota =4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a,b=<span class="literal">iota</span>+<span class="number">1</span>, <span class="literal">iota</span>+<span class="number">2</span><span class="comment">//1,2  iota =0</span></span><br><span class="line">     c,d<span class="comment">//2,3  iota =1</span></span><br><span class="line">     e,f<span class="comment">//3,4  iota =2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量–没有出现变量名，直接出现了值。基础类型的字面量相当于是常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, <span class="number">04</span> == <span class="number">4.00</span>) <span class="comment">//用到了整型字面量和浮点型字面量</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, <span class="number">.4i</span>) <span class="comment">//虚数字面量 0.4i</span></span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, <span class="string">'\u4f17'</span> == <span class="string">'众'</span>) <span class="comment">//Unicode和rune字面量</span></span><br><span class="line">fmt.Printf(<span class="string">"Hello\nWorld\n!\n"</span>) <span class="comment">//字符串字面量</span></span><br></pre></td></tr></table></figure><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>&#8195;&#8195;对于全局变量，如果以大写字母开头，所有地方都可以访问，跨package访问时需要带上package名称；如果以小写字母开头，则本package内都可以访问。<br>&#8195;&#8195;函数内部的局部变量，仅本函数内可以访问。{}可以固定一个作用域。内部声明的变量可以跟外部声明的变量有冲突，以内部的为准–就近原则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    A=<span class="number">3</span><span class="comment">//所有地方都可以访问</span></span><br><span class="line">    b=<span class="number">4</span><span class="comment">//本package内可以访问</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    b:=<span class="number">5</span>  <span class="comment">//本函数内可以访问</span></span><br><span class="line">    &#123;</span><br><span class="line">        b:=<span class="number">6</span>  <span class="comment">//本作用域内可以访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释与godoc"><a href="#注释与godoc" class="headerlink" title="注释与godoc"></a>注释与godoc</h2><h3 id="注释的形式"><a href="#注释的形式" class="headerlink" title="注释的形式"></a>注释的形式</h3><ul><li>单行注释，以//打头。</li><li>多行注释有2种形式：<ol><li>连续多行以//打头，注意多行注释之间不能出现空行。</li><li>在段前使用/*，段尾使用*/。</li></ol></li><li>注释行前加缩进即可写go代码。</li><li>注释中给定的关键词。NOTE: 引人注意，TODO: 将来需要优化，Deprecated: 变量或函数强烈建议不要再使用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add 2个整数相加</span></span><br><span class="line"><span class="comment">//返回和。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//<span class="doctag">NOTE:</span> 注释可以有多行，但中间不能出现空行（仅有//不算空行）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sub 函数使用示例：</span></span><br><span class="line"><span class="comment">  for i:=0;i&lt;3;i++&#123;</span></span><br><span class="line"><span class="comment">  Sub(i+1, i)</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">看到了吗？只需要行前缩进，注释里就可以写go代码，是不是很简单。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Prod 该函数不能并发调用，需要优化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Prod</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Deprecated: Div 不要再调用了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注释的位置"><a href="#注释的位置" class="headerlink" title="注释的位置"></a>注释的位置</h3><p>针对行的注释在行上方或右侧。函数的上方在func xxx()上方。结构体的注释在type xxx struct上方。包注释在package xxx的上方。一个包只需要在一个地方写包注释，通常会专门写一个doc.go，里面只有一行package xxx和关于包的注释。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//s := strconv.FormatBool(true)</span></span><br><span class="line"><span class="comment">//s := strconv.FormatFloat(3.1415, 'E', -1, 64)</span></span><br><span class="line"><span class="comment">//s := strconv.FormatInt(-42, 16)</span></span><br><span class="line"><span class="comment">//s := strconv.FormatUint(42, 16)</span></span><br><span class="line"><span class="keyword">package</span> fmt</span><br></pre></td></tr></table></figure><h3 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a>go doc</h3><p>go doc是go自带的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go doc entrance_class/util</span><br></pre></td></tr></table></figure><p>上述命令查看entrance_class/util包的注释。</p><h3 id="godoc"><a href="#godoc" class="headerlink" title="godoc"></a>godoc</h3><p>godoc是第三方工具，可以为项目代码导出网页版的注释文档。安装godoc命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u golang.org/x/tools/cmd/godoc</span><br><span class="line">go install golang.org/x/tools/cmd/godoc@latest</span><br></pre></td></tr></table></figure><p>启动http服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc -http=:6060</span><br></pre></td></tr></table></figure><p>用浏览器访问<a href="http://127.0.0.1:6060" target="_blank" rel="noopener">http://127.0.0.1:6060</a> ，可以查看go标准库的文档。 </p>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[初识Go语言]</title>
    <link href="http://yoursite.com/2021/04/21/%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2021/04/21/%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80/</id>
    <published>2021-04-21T12:29:10.000Z</published>
    <updated>2021-04-21T13:11:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识Go语言"><a href="#初识Go语言" class="headerlink" title="初识Go语言"></a>初识Go语言</h1><h2 id="Go语言发展历史"><a href="#Go语言发展历史" class="headerlink" title="Go语言发展历史"></a>Go语言发展历史</h2><h3 id="阵容豪华的创使人团队"><a href="#阵容豪华的创使人团队" class="headerlink" title="阵容豪华的创使人团队"></a>阵容豪华的创使人团队</h3><p><strong>Ken Thompson</strong></p><ul><li>1966年：加入了贝尔实验室，在参与 Multics （多路信息计算）开发期间，创造出了B语言，并用一个月的时间用B语言开发了全新的操作系统UNICS，后来改名为我们所熟悉的UNIX 操作系统。</li><li>1971年：和丹尼斯·利奇（Dennis Ritchie）一起共同发明了C语言。</li><li>1973年：和丹尼斯·利奇（Dennis Ritchie）使用C语言重写了UNIX，并安装于PDP-11的机器之上。</li><li>1983年：美国计算机协会将图灵奖授予汤普森。</li><li>2000年：离开贝尔实验室，已退休的汤普森成为了一名飞行员。</li><li>2006年：加入Google工作。</li><li>2007年：64岁的高龄，与Rob Pike和Robert Griesemer主导了Go语言的开发。</li></ul><p><strong>Rob Pike</strong></p><ul><li>Go语言项目总负责人。</li><li>贝尔实验室Unix团队成员，参与的项目包括Plan 9，Inferno操作系统和Limbo编程语言。</li><li>UTF-8字符集规范唯二的发明人之一（另一位是Ken Thompson）。</li><li>《UNIX环境编程》和《程序设计实践》这两本书的作者之一。</li><li>第22届莫斯科夏季奥运会射箭项目的银牌得主。</li><li>业余天文学家，设计的珈玛射线望远镜差点被 NASA 用在航天飞机上。</li><li>他的媳妇Renee French 就是 Go 语言吉祥物的设计人。</li></ul><p><strong>Robert Griesemer</strong></p><ul><li>参与V8 JavaScript引擎的开发。</li><li>参与Java HotSpot虚拟机的研发。</li></ul><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>&#8195;&#8195;2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言吧，首先名字得简单好记，大腿一拍就叫“go”。<br>&#8195;&#8195;把事情搞复杂很容易，把事情搞简单才更深刻。</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><ul><li>2007年9月21日，开始雏形设计。</li><li>2009年10月30日，Rob Pike宣布了Go语言的存在。</li><li>2009年11月10日，以完全开源的方式公布了Linux和Mac OSX上的版本，11月22日公布了Windows版本。</li><li>2010年1月8日，当选2009年年度语言。</li><li>2010年5月，谷歌投入使用。</li><li>2011年4月，谷歌开始抽调员工全职开发Go语言，并于5月宣布Google APP Engine支持Go语言。</li></ul><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/tiobe_index_for_go.png" alt="tiobe_index_for_go"></p><p>参考网站<a href="https://www.test.tiobe.com/tiobe-index/go。" target="_blank" rel="noopener">https://www.test.tiobe.com/tiobe-index/go。</a> </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/git_hut_pull_request_for_go1.png" alt="avatar"><br><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/git_hut_pull_request_for_go2.png" alt="avatar">  </p><p>参考网站<a href="https://madnight.github.io/githut/#/pull_requests。" target="_blank" rel="noopener">https://madnight.github.io/githut/#/pull_requests。</a></p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>&#8195;&#8195;从世界范围看，Go语言在中国的发展势头最猛，且远超第二名。在很多互联网大厂Go已成为主要开发语言。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/chinese_company_use_go.png" alt="avatar"></p><p>&#8195;&#8195;不论大小公司，对Go人才需求紧迫，薪酬很高。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/go_position.png" alt="avatar"></p><h2 id="Go语言的优劣"><a href="#Go语言的优劣" class="headerlink" title="Go语言的优劣"></a>Go语言的优劣</h2><p><strong>优势</strong></p><ul><li>语法简单，易于学习。类C的语法，同时比C/C++简洁和干净。</li><li>自带GC，方便使用。</li><li>快速编译，高效执行。</li><li>简单的依赖管理。</li><li>并发编程，轻松驾驭。</li><li>静态类型，同时有一些动态语言的特征(var声明)。</li><li>标准类库，规范统一。<br><strong>劣势</strong></li><li>不支持动态加载代码。</li><li>发展时间短，生态不及Java、C++庞大，但是够用。 </li></ul><h2 id="Go语言的应用场景"><a href="#Go语言的应用场景" class="headerlink" title="Go语言的应用场景"></a>Go语言的应用场景</h2><h3 id="应用场景总览"><a href="#应用场景总览" class="headerlink" title="应用场景总览"></a>应用场景总览</h3><ul><li>巨型中央服务器领域。</li><li>高性能分布式领域。</li><li>游戏服务端开发。</li><li>复杂事件处理。</li><li>对实时性要求很高的软件开发。</li><li>可以在Intel和ARM处理器上运行，因此也可以在安卓上运行。</li></ul><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/application_of_go.png" alt="avatar"></p><h3 id="go微服务开发"><a href="#go微服务开发" class="headerlink" title="go微服务开发"></a>go微服务开发</h3><ul><li>零依赖，让我们可以最小化我们的镜像,节省存储与拉取镜像带宽。</li><li>Runtime使用更小的内存，对比Java的JVM。</li><li>更好的并行能力，当你真的需求更多CPU的时候。</li><li>更高的性能，对比解释性语言，在处理数据已经并发方面优势明显。</li><li>简单，学习成本低，内部人员可以转入Go阵营。</li><li>使用Go能更接近云原生生态，比如docker，k8s, habor都是用Go开发的。 </li></ul><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><ol><li>下载。到<a href="https://studygolang.com/dl上下载最新的Go稳定版本。" target="_blank" rel="noopener">https://studygolang.com/dl上下载最新的Go稳定版本。</a></li><li>安装。对于Windows和macOS用户，直接双击即可安装，留意一下安装路径。对于Linux用户，直接解压安装包即可，比如你打算把go安装到/usr/local目录下，则使用命令<br>tar zxvf goxxx.tar.gz –C /usr/local。这样go标准库及相关的可执行文件就安装到了/usr/local/go目录下，在后续的步骤中会把/usr/local/go赋给GOROOT环境变量。  </li><li>准确GOPATH。在任意目录下创建一个空目录，将来用于存放go语言第三方库文件。比如你打算使用/data/go_path这个目录，则在Linux下使用命令mkdir -p /data/go_path。在GOPATH目录建3个子目录：src、bin、pkg。  </li><li>配置环境变量。把第2步和第3步生成的目录分别赋给GOROOT和GOPATH环境变量，对于Linux和Mac用户在~/.bashrc文件中追加以下几行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/Users/Amor/go_path</span><br><span class="line">export PATH=$PATH:$GOROOT/bin::$GOPATH/bin</span><br></pre></td></tr></table></figure><p>PATH环境变量下的可执行文件在任意目录下都可以直接访问。<br>对于Windows用户，编辑用户环境变量，新增GOROOT和GOPATH，把GOROOT/bin和GOPATH/bin添加到Path里。如下图<br><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/%E8%AE%BE%E7%BD%AEgo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F1.png" alt="avatar">  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/%E8%AE%BE%E7%BD%AEgo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png" alt="avatar">   </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/%E8%AE%BE%E7%BD%AEgo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F3.png" alt="avatar">  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/%E8%AE%BE%E7%BD%AEgo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F4.png" alt="avatar">  </p><p>在Windows下还可以通过go env -w来设置环境变量，比如设置GOPROXY用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>有很多网站支持在线编辑Go代码并查看运行结果，这里列举一些<br><a href="https://play.golang.wiki" target="_blank" rel="noopener">https://play.golang.wiki</a><br><a href="https://play.studygolang.com" target="_blank" rel="noopener">https://play.studygolang.com</a><br><a href="https://goplay.space" target="_blank" rel="noopener">https://goplay.space</a><br><a href="https://goplay.tools" target="_blank" rel="noopener">https://goplay.tools</a><br>集成开发环境推荐GoLand和VSCode，后者是免费的。VSCode需要额外安装支持Go语言的插件，如下图  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/go_plugin_for_vscode.png" alt="avatar"></p><h2 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()函数是Go程序的唯一入口，且main()函数必须位于package main中。fmt是Go标准库中的一个package，该package下有一个Println()函数用于输出字符串。Go语言会依次从以下3个目录里查找依赖包：</p><ol><li>当前工作目录</li><li>$GOPATH/pkg/mod</li><li>$GOROOT/src</li></ol><h2 id="Go命令介绍"><a href="#Go命令介绍" class="headerlink" title="Go命令介绍"></a>Go命令介绍</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">(base) zcymac:~ zcy$ go help</span><br><span class="line">Go is a tool for managing Go source code.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">go &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">bug         start a bug report</span><br><span class="line">build       compile packages and dependencies</span><br><span class="line">clean       remove object files and cached files</span><br><span class="line">doc         show documentation for package or symbol</span><br><span class="line">env         print Go environment information</span><br><span class="line">fix         update packages to use new APIs</span><br><span class="line">fmt         gofmt (reformat) package sources</span><br><span class="line">generate    generate Go files by processing source</span><br><span class="line">get         add dependencies to current module and install them</span><br><span class="line">install     compile and install packages and dependencies</span><br><span class="line">list        list packages or modules</span><br><span class="line">mod         module maintenance</span><br><span class="line">run         compile and run Go program</span><br><span class="line">test        test packages</span><br><span class="line">tool        run specified go tool</span><br><span class="line">version     print Go version</span><br><span class="line">vet         report likely mistakes in packages</span><br><span class="line"></span><br><span class="line">Use "go help &lt;command&gt;" for more information about a command.</span><br><span class="line"></span><br><span class="line">Additional help topics:</span><br><span class="line"></span><br><span class="line">buildconstraint build constraints</span><br><span class="line">buildmode       build modes</span><br><span class="line">c               calling between Go and C</span><br><span class="line">cache           build and test caching</span><br><span class="line">environment     environment variables</span><br><span class="line">filetype        file types</span><br><span class="line">go.mod          the go.mod file</span><br><span class="line">gopath          GOPATH environment variable</span><br><span class="line">gopath-get      legacy GOPATH go get</span><br><span class="line">goproxy         module proxy protocol</span><br><span class="line">importpath      import path syntax</span><br><span class="line">modules         modules, module versions, and more</span><br><span class="line">module-get      module-aware go get</span><br><span class="line">module-auth     module authentication using go.sum</span><br><span class="line">packages        package lists and patterns</span><br><span class="line">private         configuration for downloading non-public code</span><br><span class="line">testflag        testing flags</span><br><span class="line">testfunc        testing functions</span><br><span class="line">vcs             controlling version control with GOVCS</span><br><span class="line"></span><br><span class="line">Use "go help &lt;topic&gt;" for more information about that topic.</span><br></pre></td></tr></table></figure><p>go help: 查看帮助文档。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go help build</span><br></pre></td></tr></table></figure><p>go build: 对源代码和依赖的文件进行打包，生成可执行文件。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o my_first_go_exe entrance_class/demo.go</span><br></pre></td></tr></table></figure><p>go install: 编译并安装包或依赖，安装到$GOPATH/bin下。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install entrance_class/demo.go</span><br></pre></td></tr></table></figure><p>go get: 把依赖库添加到当前module中，如果本机之前从未下载过则先下载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/tinylib/msgp</span><br></pre></td></tr></table></figure><p>以上命令会在$GOPATH/pkg/mod目录下会生成github.com/tinylib/msgp目录。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/tinylib/msgp@latest</span><br></pre></td></tr></table></figure><p>以上命令会在$GOPATH/bin下生成msgp可执行文件。<br>go mod init module_name<br>初始化一个Go项目。<br>go mod tidy通过扫描当前项目中的所有代码来添加未被记录的依赖至go.mod文件或从go.mod文件中删除不再被使用的依赖。<br>go run: 编译并运行程序。<br>go test: 执行测试代码。<br>go tool: 执行go自带的工具。go tool pprof对cpu、内存和协程进行监控；go tool trace跟踪协程的执行过程。<br>go vet: 检查代码中的静态错误。<br>go fmt: 对代码文件进行格式化，如果用了IDE这个命令就不需要了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go fmt entrance_class/demo.go</span><br></pre></td></tr></table></figure><p>go doc: 查看go标准库或第三方库的帮助文档。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go doc fmt</span><br><span class="line">go doc gonum.org/v1/gonum/stat</span><br></pre></td></tr></table></figure><p>go version: 查看go版本号。<br>go env: 查看go环境信息。   </p>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Golang基础]</title>
    <link href="http://yoursite.com/2021/04/20/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/04/20/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-20T12:29:20.000Z</published>
    <updated>2021-04-21T13:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://rogerxs80.github.io/2021/04/21/%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">1.初识Go语言</a></p><p><a href="https://rogerxs80.github.io/2021/04/21/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">2.Go语言基础语法</a></p><p><a href="https://rogerxs80.github.io/2021/04/21/Go%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">3.Go数据类型</a></p><p><a href="https://rogerxs80.github.io/2021/04/21/Go%E7%BB%93%E6%9E%84%E4%BD%93/" target="_blank" rel="noopener">4.Go结构体</a></p><p><a href="https://rogerxs80.github.io/2021/04/22/Go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" target="_blank" rel="noopener">5.Go流程控制语句</a></p><p><a href="https://rogerxs80.github.io/2019/02/20/%E8%99%9A%E6%8B%9F%E5%8C%96%E7%8E%AF%E5%A2%83/" target="_blank" rel="noopener">6.Go函数</a></p>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Docker通关手册]</title>
    <link href="http://yoursite.com/2021/01/21/Docker%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2021/01/21/Docker%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/</id>
    <published>2021-01-21T12:29:59.000Z</published>
    <updated>2021-01-21T13:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人建议把面试题看作是费曼学习法中的回顾、简化的环节，准备面试的时候，跟着题目先自己讲给自己听，看看自己会满意吗，不满意就继续学习这个点，如此反复，好的offer离你不远的，奥利给</p><p>…</p></blockquote><blockquote><p>成长手册，<strong>GitHub</strong> <a href="https://github.com/rogerXS80/roger" target="_blank" rel="noopener">Lupinus</a> ，N线互联网开发必备技能兵器谱</p></blockquote><h1 id="Docker通关手册"><a href="#Docker通关手册" class="headerlink" title="Docker通关手册"></a>Docker通关手册</h1><h2 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a>Docker是什么？</h2><p>最广泛的开源容器引擎</p><p>一种操作系统级的虚拟化技术</p><p>依赖于Linux内核特性：Namespace（<strong>资源隔离</strong>）和Cgroups（<strong>资源限制</strong>）</p><p>一个简单的应用程序打包工具</p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>如果已经安装了，运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                 docker-client \</span><br><span class="line">                 docker-client-latest \</span><br><span class="line">                 docker-common \</span><br><span class="line">                 docker-latest \</span><br><span class="line">                 docker-latest-logrotate \</span><br><span class="line">                 docker-logrotate \</span><br><span class="line">                 docker-engine</span><br></pre></td></tr></table></figure><p>安装docker工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Docker所需的依赖</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加软件源信息</span></span><br><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Docker CE</span></span><br><span class="line">yum install docker-ce -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载 配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 Docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 Docker服务 加入开机自启</span></span><br><span class="line">systemctl enable --now docker.service</span><br><span class="line">Created symlink <span class="keyword">from</span> /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br><span class="line">        </span><br><span class="line"><span class="comment"># yum源工作目录</span></span><br><span class="line">/etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="Docker基本组成"><a href="#Docker基本组成" class="headerlink" title="Docker基本组成"></a>Docker基本组成</h2><img src="https://gitee.com/wjxyzs/img/raw/master/img/docker%E7%BB%84%E6%88%90.png" style="zoom: 67%;" /><h2 id="Docker核心组件"><a href="#Docker核心组件" class="headerlink" title="Docker核心组件"></a>Docker核心组件</h2><img src="https://gitee.com/wjxyzs/img/raw/master/img/docker%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Docker Daemon：Docker守护进程，负责与Docker Clinet交互，并管理镜像、</span><br><span class="line">容器。</span><br><span class="line">Containerd：是一个简单的守护进程，向上给Docker Daemon提供接口，向下</span><br><span class="line">通过containerd-shim结合runC管理容器。</span><br><span class="line">runC：一个命令行工具，它根据OCI标准来创建和运行容器。</span><br></pre></td></tr></table></figure><h2 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• 一个分层存储的文件，不是一个单一的文件 </span><br><span class="line">• 一个软件的环境 </span><br><span class="line">• 一个镜像可以创建N个容器 </span><br><span class="line">• 一种标准化的交付 </span><br><span class="line">• 一个不包含Linux内核而又精简的Linux操作系统</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"registry-mirrors"</span>: [<span class="string">"https://rxsa4cyh.mirror.aliyuncs.com]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="镜像常用指令"><a href="#镜像常用指令" class="headerlink" title="镜像常用指令"></a>镜像常用指令</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">images</td><td align="center">列出镜像</td></tr><tr><td align="center">build</td><td align="center">构建镜像来自Dockerfile</td></tr><tr><td align="center">history</td><td align="center">查看镜像历史</td></tr><tr><td align="center">inspect</td><td align="center">显示一个或多个镜像详细信息</td></tr><tr><td align="center">pull</td><td align="center">从镜像仓库拉取镜像</td></tr><tr><td align="center">push</td><td align="center">推送一个镜像到镜像仓库</td></tr><tr><td align="center">rmi</td><td align="center">移除一个或多个镜像</td></tr><tr><td align="center">prune</td><td align="center">移除没有被标记或者没有被任何容器引用的镜像</td></tr><tr><td align="center">tag</td><td align="center">创建一个引用源镜像标记目标镜像</td></tr></tbody></table><h2 id="镜像存储核心技术"><a href="#镜像存储核心技术" class="headerlink" title="镜像存储核心技术"></a>镜像存储核心技术</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">储存驱动: overlay2（性能好）</span><br></pre></td></tr></table></figure><h3 id="联合文件系统（UnionFS"><a href="#联合文件系统（UnionFS" class="headerlink" title="联合文件系统（UnionFS)"></a>联合文件系统（UnionFS)</h3><img src="https://gitee.com/wjxyzs/img/raw/master/img/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8.png" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">联合文件系统：将镜像多层文件联合挂载到容器文件系统</span><br></pre></td></tr></table></figure><h3 id="写时复制（COW）"><a href="#写时复制（COW）" class="headerlink" title="写时复制（COW）"></a>写时复制（COW）</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/docker%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写时复制：需要修改文件操作时，会先从镜像里把要写的文件复制到自己的文件系统中进行修改</span><br></pre></td></tr></table></figure><h3 id="Docker读写优化"><a href="#Docker读写优化" class="headerlink" title="Docker读写优化"></a>Docker读写优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSD固态硬盘（工作目录：/var/lib/docker）</span><br><span class="line">使用卷作为频繁读写文件的工作目录，绕过储存驱动，减少抽象开销</span><br></pre></td></tr></table></figure><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><h3 id="创建容器常用选项"><a href="#创建容器常用选项" class="headerlink" title="创建容器常用选项"></a>创建容器常用选项</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">交互式</td></tr><tr><td align="center">-t</td><td align="center">分配一个伪终端</td></tr><tr><td align="center">-d</td><td align="center">运行容器到后台</td></tr><tr><td align="center">-e</td><td align="center">设置环境变量</td></tr><tr><td align="center">-p</td><td align="center">发布容器端口到主机</td></tr><tr><td align="center">–name</td><td align="center">指定容器名字</td></tr><tr><td align="center">-h</td><td align="center">指定容器主机名</td></tr><tr><td align="center">-ip</td><td align="center">指定容器IP，只能用于自定义网络</td></tr><tr><td align="center">-network</td><td align="center">连接容器到一个网络</td></tr><tr><td align="center">-m</td><td align="center">将文件系统附加到容器</td></tr><tr><td align="center">-v</td><td align="center">绑定挂载一个卷</td></tr><tr><td align="center">-restart</td><td align="center">容器退出时重启策略，默认no，可选值：[always|on-failure]</td></tr></tbody></table><p>挂载宿主机三个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostname       --hostname</span><br><span class="line">hosts          --dns</span><br><span class="line">resolc.conf    --add-host</span><br></pre></td></tr></table></figure><h3 id="容器资源限制"><a href="#容器资源限制" class="headerlink" title="容器资源限制"></a>容器资源限制</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-m</td><td align="center">容器可以使用的最大内存量（）</td></tr><tr><td align="center">–memory-swap</td><td align="center">允许交换到磁盘的内存量</td></tr><tr><td align="center">–memory-swappiness=&lt;0-100&gt;</td><td align="center">容器使用SWAP分区交换的百分比（0-100，默认为-1）</td></tr><tr><td align="center">–oom-kill-disable</td><td align="center">禁用OOM Killer</td></tr><tr><td align="center">–cpus</td><td align="center">可以使用的CPU数量</td></tr><tr><td align="center">–cpuset-cpus</td><td align="center">限制容器使用特定的CPU核心，如(0-3, 0,1)</td></tr><tr><td align="center">–cpu-shares</td><td align="center">CPU共享（相对权重）</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认创建的容器使用宿主机所有资源</span><br><span class="line">主要用于每个容器能够平均分配到宿主机资源</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存限额：</span></span><br><span class="line"><span class="comment"># 允许容器最多使用500M内存和100M的Swap，并禁用 OOM Killer：</span></span><br><span class="line">docker run -d --name nginx01 -m=<span class="string">"500m"</span> --memory-swap=<span class="string">"100m"</span> --oom-kill-disable nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU限额：</span></span><br><span class="line"><span class="comment"># 允许容器最多使用一个半的CPU：</span></span><br><span class="line">docker run -d --name nginx02 --cpus=<span class="string">"1.5"</span> nginx</span><br><span class="line"><span class="comment"># 允许容器最多使用50%的CPU：</span></span><br><span class="line">docker run -d --name nginx03 --cpus=<span class="string">".5"</span> nginx</span><br></pre></td></tr></table></figure><h3 id="管理容器常用指令"><a href="#管理容器常用指令" class="headerlink" title="管理容器常用指令"></a>管理容器常用指令</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ls</td><td align="center">列出容器</td></tr><tr><td align="center">inspect</td><td align="center">查看一个或多个容器详细信息</td></tr><tr><td align="center">exec</td><td align="center">在运行容器中执行命令</td></tr><tr><td align="center">commit</td><td align="center">创建一个新镜像来自一个容器</td></tr><tr><td align="center">cp</td><td align="center">拷贝文件/文件夹到一个容器</td></tr><tr><td align="center">logs</td><td align="center">获取一个容器日志</td></tr><tr><td align="center">port</td><td align="center">列出或指定容器端口映射</td></tr><tr><td align="center">top</td><td align="center">显示一个容器运行的进程</td></tr><tr><td align="center">stats</td><td align="center">显示容器资源使用统计</td></tr><tr><td align="center">stop/start/restart</td><td align="center">停止/启动一个或多个容器</td></tr><tr><td align="center">rm</td><td align="center">删除一个或多个容器</td></tr><tr><td align="center">prune</td><td align="center">移除已停止的容器</td></tr></tbody></table> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">docker ps</span><br><span class="line">docker ps -a  // 查看所有的容器</span><br><span class="line">docker ps -q  // 查看所有的容器id</span><br><span class="line">docker ps -l  // 查看最新创建的容器</span><br><span class="line"></span><br><span class="line">docker top 容器名    // 查看容器中的进程</span><br><span class="line"></span><br><span class="line">docker stats 容器名  // 容器资源统计信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行基础镜像</span></span><br><span class="line">docker run -it centos</span><br><span class="line"><span class="comment"># 运行应用镜像</span></span><br><span class="line">docker run -d nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="keyword">exec</span> -it centos bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm centos</span><br><span class="line"><span class="comment"># 批量删除容器</span></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件</span></span><br><span class="line">docker cp nginx.tar 容器名:/opt</span><br><span class="line">docker cp 容器名:/opt/nginx ./</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 更新容器配置（部分可以修改）</span></span><br><span class="line">docker update --help</span><br></pre></td></tr></table></figure><h2 id="容器实现核心技术"><a href="#容器实现核心技术" class="headerlink" title="容器实现核心技术"></a>容器实现核心技术</h2><h3 id="命名空间（Namespace）"><a href="#命名空间（Namespace）" class="headerlink" title="命名空间（Namespace）"></a>命名空间（Namespace）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">将特定的全局系统资源通过抽象方法使得Namespace中的进程看起来拥有自己隔离的资源</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6种不同命名空间</span></span><br><span class="line">ll /proc/$$/ns</span><br><span class="line"><span class="number">1</span> IPC:：隔离进程间通信</span><br><span class="line"><span class="number">2</span> MOUNT：隔离文件系统挂载点</span><br><span class="line"><span class="number">3</span> NET：隔离网络协议栈</span><br><span class="line"><span class="number">4</span> PID：隔离进程号，进程命名空间是一个父子结构，子空间对父空间可见</span><br><span class="line"><span class="number">5</span> USER：隔离用户</span><br><span class="line"><span class="number">6</span> UTS：隔离主机名和域名</span><br></pre></td></tr></table></figure><h2 id="控制组（CGroups）"><a href="#控制组（CGroups）" class="headerlink" title="控制组（CGroups）"></a>控制组（CGroups）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果某个容器属于CPU密集型任务，那么会影响其他容器使用CPU，导致多个容器相互影响并抢占资源</span><br><span class="line">CGroups：所有任务就是运行在系统中的一个进程，而CGroups以某种标准将一组进程为目标进行资源分配和控制，并且可以动态配置</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要功能</span></span><br><span class="line">-限制进程组使用的资源数量：可以为进程组设定资源使用上限，例如内存（***）</span><br><span class="line">-进程组优先控制：可以为进程组分配特定CPU,磁盘IO吞吐量</span><br><span class="line">-记录进程组使用的资源数量：例如使用记录某个进程组使用的CPU时间</span><br><span class="line">-可以将进程组挂起和恢复</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看cgroup可控制资源</span></span><br><span class="line">ls /sys/fs/cgroup/&lt;资源名&gt;/docker -l</span><br></pre></td></tr></table></figure><h3 id="工具镜像"><a href="#工具镜像" class="headerlink" title="工具镜像"></a>工具镜像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd busy:<span class="number">1.28</span><span class="number">.4</span></span><br><span class="line">docker <span class="keyword">exec</span> -it 容器名 sh</span><br></pre></td></tr></table></figure><h2 id="容器数据持久化"><a href="#容器数据持久化" class="headerlink" title="容器数据持久化"></a>容器数据持久化</h2><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E6%96%B9%E5%BC%8F.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Docker提供两种方式将数据从宿主机挂载到容器中：</span><br><span class="line">• volumes：Docker管理宿主机文件系统的一部分（/var/lib/docker/volumes）。保存数据的最佳方式。</span><br><span class="line">• bind mounts：将宿主机上的任意位置的文件或者目录挂载到容器中。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line">/var/lib/docker/volumes</span><br><span class="line"></span><br><span class="line"><span class="comment">### volume </span></span><br><span class="line">docker volume --help</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管理卷：</span></span><br><span class="line">docker volume create nginx-vol</span><br><span class="line">docker volume ls</span><br><span class="line">docker volume inspect nginx-vol</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用卷创建一个容器：</span></span><br><span class="line">docker run -d --name=nginx-test --mount src=nginx-vol,dst=/usr/share/nginx/html nginx</span><br><span class="line">docker run -d --name=nginx-test -v nginx-vol:/usr/share/nginx/html nginx</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 清理：</span></span><br><span class="line">docker stop nginx-test</span><br><span class="line">docker rm nginx-test </span><br><span class="line">docker volume rm nginx-vol</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"><span class="number">1.</span> 如果没有指定卷，自动创建。</span><br><span class="line"></span><br><span class="line"><span class="comment">### bind mount</span></span><br><span class="line"><span class="comment"># 用卷创建一个容器：</span></span><br><span class="line">docker run -d --name=nginx-test --mount type=bind,src=/app/wwwroot,dst=/usr/share/nginx/html nginx</span><br><span class="line">docker run -d --name=nginx-test -v /app/wwwroot:/usr/share/nginx/html nginx</span><br><span class="line"><span class="comment"># 验证绑定：</span></span><br><span class="line">docker inspect nginx-test</span><br><span class="line"><span class="comment"># 清理：</span></span><br><span class="line">docker stop nginx-test </span><br><span class="line">docker rm nginx-test </span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"><span class="number">1.</span> 如果源文件/目录没有存在如果挂载目标在容器中非空目录，则该目录现有内容将被隐藏。</span><br></pre></td></tr></table></figure><h2 id="四种网络模式"><a href="#四种网络模式" class="headerlink" title="四种网络模式"></a>四种网络模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-bridege：--net=bridge，Docker启动创建一个docker0网桥，默认创建的容器页是添加到这个网桥中。</span><br><span class="line">-host：--net=host，容器不会获得一个独立的network namespace，而是与宿主机公用一个。容器除了网络都是隔离的。</span><br><span class="line">-none：--net=none，获取独立的network namespace，但部位容器进行任何网络配置，需要手动配置。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用场景</span></span><br><span class="line">host：希望使用宿主机网络</span><br><span class="line">none：手动配置容器网络，对接公司IPAM</span><br><span class="line">container：希望容器与另一个容器在一个网络命名空间</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建网桥</span></span><br><span class="line">docker network create test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">veth pair：成对出现的一种虚拟网络设备，数据从一端进，从另一端出。用于解决网络命名空间之间隔离。</span><br><span class="line">docker：网桥是一个二层网络设备，通过网桥可以将Linux支持的不同端口连接起撸，并实现类似交换机那样的多对多的通信。</span><br></pre></td></tr></table></figure><h3 id="容器网络访问原理"><a href="#容器网络访问原理" class="headerlink" title="容器网络访问原理"></a>容器网络访问原理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实验</span></span><br><span class="line">docker run -d -p <span class="number">88</span>:<span class="number">80</span> ngxin</span><br><span class="line">docker logs 容器名 -f</span><br></pre></td></tr></table></figure><h3 id="容器网络实现核心技术（iptables）"><a href="#容器网络实现核心技术（iptables）" class="headerlink" title="容器网络实现核心技术（iptables）"></a>容器网络实现核心技术（iptables）</h3><table><thead><tr><th align="center">表</th><th align="center">链</th></tr></thead><tbody><tr><td align="center">filter（过滤）</td><td align="center">INPUT，OUTPUT，FORWORD</td></tr><tr><td align="center">nat（地址转发）</td><td align="center">PREROUTING，POSTROUTING，OUTPUT</td></tr><tr><td align="center">mangle（拆包，修改，封装）</td><td align="center">INPUT，OUTPUT，FORWARD，PREROUTING，POSTROUTING</td></tr><tr><td align="center">raw（数据包状态跟踪）</td><td align="center">PREROUTING，OUTPUT</td></tr></tbody></table><img src="https://gitee.com/wjxyzs/img/raw/master/img/iptables%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" style="zoom:80%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INPUT链：接收的数据包是本机（入站）时，应用此链中的规则</span><br><span class="line">OUTPUT链：本机向外发送数据包（出站）时，应用此链中的规则</span><br><span class="line">FORWARD链：需要通过防火墙中转发送给其他地址的数据包（转发）时，应用此链中的规则</span><br><span class="line">PREROUTING链：在对数据包做路由选择之前，应用此链中的规则（DNAT）</span><br><span class="line">POSTROUTING链：在对数据包做路由选择之后，应用此链中的规则（SNAT）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 外部访问容器</span></span><br><span class="line"><span class="comment"># DNAT：目标地址转换，修改数据包目标IP</span></span><br><span class="line">iptables -t nat -vnL DOCKER</span><br><span class="line">Chain DOCKER (<span class="number">2</span> references)</span><br><span class="line">pkts bytes target prot opt <span class="keyword">in</span> out source destination </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> RETURN all -- docker0 * <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">52</span> DNAT tcp -- !docker0 * <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span> tcp dpt:<span class="number">8080</span> to:<span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>:<span class="number">80</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 容器访问外部</span></span><br><span class="line"><span class="comment"># SNAT：修改源IP为宿主机IP向外发出</span></span><br><span class="line">iptables -t nat -vnL POSTROUTING</span><br><span class="line">Chain POSTROUTING (policy ACCEPT <span class="number">0</span> packets, <span class="number">0</span> bytes)</span><br><span class="line">pkts bytes target prot opt <span class="keyword">in</span> out source destination </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> MASQUERADE all -- * !docker0 <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="容器多主机通信"><a href="#容器多主机通信" class="headerlink" title="容器多主机通信"></a>容器多主机通信</h3><img src="https://gitee.com/wjxyzs/img/raw/master/img/docker%E5%A4%9A%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1.png" style="zoom:80%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flannel是CoreOS维护的一个网络组件，在每个主机上运行守护进程负责维护本地路由准发，Flannel使用ETCD来存储容器网络与主机之前的关系。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遇到的问题</span></span><br><span class="line">两台主机容器进行通信，会走FORWORD链执行DROP</span><br><span class="line"><span class="comment"># 解决方案</span></span><br><span class="line">iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最广泛的开源容器引擎，一种操作系统级的虚拟化技术，依赖于Linux内核特性：Namespace（**资源隔离**）和Cgroups（**资源限制**），一个简单的应用程序打包工具...
    
    </summary>
    
    
      <category term="CI/CD" scheme="http://yoursite.com/categories/CI-CD/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>[IDEA总结]</title>
    <link href="http://yoursite.com/2020/07/27/IDEA%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/07/27/IDEA%E6%80%BB%E7%BB%93/</id>
    <published>2020-07-27T00:01:25.000Z</published>
    <updated>2020-07-27T00:01:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>成长手册，<strong>GitHub</strong> <a href="https://github.com/rogerXS80/roger" target="_blank" rel="noopener">Lupinus</a> ，N线互联网开发必备技能兵器谱</p></blockquote><p>工欲善其事，必先利其器 ，当下有数不清的 Java 程序员将石器时代的 Eclipse 替换成了现代化的智能开发工具 InteliJ IDEA ，写代码的小日子过得不亦乐乎。</p><h2 id="InteliJ-IDEA-介绍"><a href="#InteliJ-IDEA-介绍" class="headerlink" title="InteliJ IDEA 介绍"></a>InteliJ IDEA 介绍</h2><p>IDEA，全称 IntelliJ IDEA，是 Java 语言的集成开发环境，IDEA 在业界被公认为是最好的 java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、Ant、JUnit、CVS 整合、代码审查、创新的 GUI 设计等方面的功能可以说是超常的。</p><p>IDEA是 JetBrains 公司的产品，公司旗下还有其它产品，比如： WebStorm、DataGrip、GoLand…</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><ul><li>强大的整合能力。比如：Git、Maven、Spring 等</li><li>提示功能的快速、便捷</li><li>提示功能的范围广</li><li>好用的快捷键和代码模板 private static final psf</li><li>精准搜索（ IDEA 会将您的源代码编入索引 ）</li><li>不需要频繁的Ctrl+S（自动保存）</li><li>自带反编译器，方便查看源码</li></ul><p>在 Eclipse 中我们有 Workspace（工作空间）和 Project（工程）的概念，在 IDEA 中只有 Project（工程）和 Module（模块）的概念 。Eclipse 中 workspace 相当于 IDEA 中的 Project ，Eclipse 中 Project 相当于 IDEA 中的 Module</p><p>IDEA 和 Eclipse 的术语对比</p><table><thead><tr><th>Eclipse</th><th>IntelliJ IDEA</th></tr></thead><tbody><tr><td>Workspace</td><td>Project</td></tr><tr><td>Project</td><td>Module</td></tr><tr><td>Facet</td><td>Facet</td></tr><tr><td>Library</td><td>Library</td></tr><tr><td>JRE</td><td>SDK</td></tr><tr><td>Classpath variable</td><td>Path variable</td></tr></tbody></table><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>实时代码模板 (Live Templates)</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/%E5%AE%9E%E6%97%B6%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF.gif" alt=""></p><p>它的原理就是配置一些常用代码字母缩写，在输入简写时可以出现你预定义的固 定模式的代码，使得开发效率大大提高，同时也可以增加个性化。最简单的例子 就是在 Java 中输入 sout 会出现 System.out.println();</p><p><strong>Editor – General – Postfix Completion</strong>  查看已经存在的模板（不可修改）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1.jpg" alt=""></p><p><strong>Editor — Live Templates</strong> 查看或自定义模板（可以添加方式注释、类注释）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d998044c7a7.jpg" alt=""></p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d998038a98f.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @description:</span></span><br><span class="line"><span class="comment"> * @param $param$</span></span><br><span class="line"><span class="comment"> * @return $return$</span></span><br><span class="line"><span class="comment"> * @date $time$ $date$</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><p>类注释一般通过 <strong>File — Setting — Editor — Live Templates — File and Code Templates</strong> 设置</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d9980eb46b1.jpg" alt=""></p><h2 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h2><p>程序猿么，每天都在写bug，所以这个功能一定得用的溜</p><p>配置通用调试属性和行为 ： <strong>Settings/Preferences | Build, Execution, Deployment | Debugger</strong></p><h4 id="1-断点类型"><a href="#1-断点类型" class="headerlink" title="1. 断点类型"></a>1. 断点类型</h4><p>断点有四种类型：</p><ol><li>行断点（Line Breakpoints）：最经常用的方式， 可以设置在任何可执行的代码行上</li><li>方法断点（Method Breakpoints）： 在进入或退出指定的方法或其实现之一时挂起程序，允许您检查方法的进入/退出条件</li><li>字段断点（Field Watchpoints）： 当指定的字段被读取或写入时，挂起程序。需要注意的是，默认只有写才会停下，想要让读取时也停下，需要右击断点，在<strong>Watch</strong>的<strong>Field access</strong>上打勾才行</li><li>异常断点（Exception Breakpoints）： 当抛出Throwable或其子类时挂起程序 。可以在 *<em>Run — View Breakpoints *</em>中的 Java Exception Breakpoints 里添加异常的具体类型。这样的话，程序中一旦发生了这种异常马上就会停下来</li></ol><h4 id="2-设置断点"><a href="#2-设置断点" class="headerlink" title="2. 设置断点"></a>2. 设置断点</h4><p>左键点击行号栏（快捷键： <code>Ctrl+F8</code> ）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99ab8cc421.jpg" alt=""></p><h5 id="置异常断点"><a href="#置异常断点" class="headerlink" title="置异常断点"></a>置异常断点</h5><p>点击<strong>Debug</strong>工具窗口左侧的的 <strong>View Breakpoints</strong> <img src="https://gitee.com/wjxyzs/img/raw/master/img/small-1.jpg" alt=""> 或者快捷键 <code>Ctrl+Shift+F8</code> ，可以新建异常检测，或者检测所有异常（<strong>Any Exception</strong>） 情况，这样只要程序有相应异常，就会挂起</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99a91e3296.jpg" alt=""></p><h5 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h5><p>有时候我们在循环处理数据时候，可能只关心某个条件的数据，就可以在断点位置右键，设置<strong>断点条件</strong>，（下图，在i==6 的时候挂起程序）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99aceda1e2.jpg" alt=""></p><h5 id="多线程断点"><a href="#多线程断点" class="headerlink" title="多线程断点"></a>多线程断点</h5><p>在调试多线程代码时候，只能串行调试，因为IDEA在Debug时默认阻塞级别是ALL，会阻塞其它线程，只有在当前调试线程走完时才会走其它线程。如果像下图一样是lambda表达式的行，可以选择断点类型。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99a9b956a4.jpg" alt=""></p><p>可以在 View Breakpoints 里选择 Thread （右键断点），这样就可以Frames 切换线程debug了。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99adc603f0.jpg" alt=""></p><h4 id="3-逐步执行程序"><a href="#3-逐步执行程序" class="headerlink" title="3. 逐步执行程序"></a>3. 逐步执行程序</h4><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-2.jpg" alt=""></p><ul><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-3.jpg" alt=""> <strong>step over</strong> —— 步过，如果当前行断点是一个方法，则不进入当前方法体内</li><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-4.jpg" alt=""> <strong>step into</strong> —— 步入，如果当前行断点是一个方法，则进入当前方法体内，一般用于进入自定义方法内，不会进入官方类库的方法</li><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-5.jpg" alt=""> <strong>force step into</strong> <code>Shift+Alt+F7</code> ——  强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法</li><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-6.jpg" alt=""> <strong>step out</strong>  <code>Shift+F8</code> —— 步出， 从步入的方法内退出到方法调用处</li><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-7.jpg" alt=""> <strong>Drop frame</strong> —— 回退到上一步</li><li><img src="https://gitee.com/wjxyzs/img/raw/master/img/small-8.jpg" alt=""> <strong>Run to cursor</strong>  <code>Alt+F9</code>  ——  运行到光标处，可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点</li></ul><p>断点这块有好多功能，可以分析JVM中堆对象、Java8的Stream操作，留个传送门。。。TODO</p><p>某大佬总结的： <strong><a href="https://www.cnblogs.com/chiangchou/p/idea-debug.html" target="_blank" rel="noopener">在Intellij IDEA中使用Debug</a></strong></p><p>官方教程： <strong><a href="https://www.jetbrains.com/help/idea/debugging-code.html" target="_blank" rel="noopener">www.jetbrains.com/help/idea/d…</a></strong></p><h2 id="配置Tomcat远程调试"><a href="#配置Tomcat远程调试" class="headerlink" title="配置Tomcat远程调试"></a>配置Tomcat远程调试</h2><p>有时候会有一些服务器差异问题导致的问题，不好排查，这个时候就想远程调试下服务器上的代码。</p><p>① 配置tomcat， 在tomcat/bin下的 catalina.sh 上边添加下边的一段设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xdebug -Xnoagent -Djava.compiler=NONE </span><br><span class="line">-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=<span class="number">9527</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99ee95d81b.jpg" alt=""></p><p>② IDEA设置</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99f2f33fe3.jpg" alt=""></p><p>③ 在IDEA上启动远程 tomcat后，就能debug了</p><p>还有一种复制Startup/Connection 中的内容到 JAVA_OPTS 中，没有尝试</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99f4b668a5.jpg" alt=""></p><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p>书签在翻看源码或者大佬代码的时候，可以方便记录代码的调用链路。</p><p>书签有匿名书签（可以有无数个）和标记书签（有数字或者字母助记符的书签）两种</p><p>操作书签：<strong>Navigate | Bookmarks</strong> 可以创建匿名书签 Toggle Bookmark。创建标技书签 Toggle Bookmark With Mnemonic，查看标签 Show Bookmarks</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99f588d675.jpg" alt=""></p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li><p><strong>Lombok</strong> —— 开发神器，可以简化你的实体类</p></li><li><p><strong>Maven Helper</strong> ——  方便显示maven的依赖树，处理冲突的好帮手</p></li><li><p>.<strong>ignore</strong> —— 忽略不需要提交的文件</p></li><li><p><strong>FindBugs-IDEA</strong> ——  代码审查</p></li><li><p><strong>Alibaba Java Coding Guidelines</strong> ——  阿里的开发设计规范</p></li><li><p><strong>Alibaba Cloud Toolkit</strong> ——  帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器或云端；并且还内置了 Arthas 诊断、Dubbo工具、Terminal 终端、文件上传、函数计算和 MySQL 执行器等工具</p></li><li><p><strong>Easy Code</strong> ——  支持自定义模板的代码生成插件</p></li><li><p><strong>RestfulToolkit</strong> ——  RESTful 服务开发辅助工具集（安利，可以直接在右侧的RestServices查看，所有项目的restful接口，还可以通过 <code>Ctrl \</code> 全局搜索 ）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d99f6f87218.jpg" alt=""></p></li></ul><p>IDEA 主题和插件排行榜： <strong><a href="https://plugins.jetbrains.com/search?orderBy=downloads&products=idea" target="_blank" rel="noopener">plugins.jetbrains.com/search?orde…</a></strong></p><h2 id="激活"><a href="#激活" class="headerlink" title="激活"></a>激活</h2><p>仅供个人学习使用~~</p><ol><li><p>下载补丁文件 <strong><code>jetbrains-agent.jar</code></strong> 并将它放置到 Idea安装目录的bin目录下，<a href="https://pan.baidu.com/s/1Zy-vQGOdKoqDdB8sWIcQOg" target="_blank" rel="noopener"><strong>pan.baidu.com/s/1Zy-vQGOd…</strong></a></p></li><li><p>免费试用，进入IDEA, 点击最上面的菜单栏中的 *<em>Help - Edit Custom VM Options *</em>，在<code>idea.exw.vmoptionos</code>文件中加入<code>-javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2019.2.4\bin\jetbrains-agent.jar</code>(换成你的jar包目录)，重启</p></li><li><p>重启IDEA 后，打开*<em>Help — Register *</em>，在License Server 填上， <a href="http://jetbrains-license-server/" target="_blank" rel="noopener">http://jetbrains-license-server</a> ，失败的话就输入下边的注册码</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">520E5894</span>E2-eyJsaWNlbnNlSWQiOiI1MjBFNTg5NEUyIiwibGljZW5zZWVOYW1lIjoicGlnNiIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-DZ/oNHBfyho0XrrCJJvAOKg5Q1tLBgOdbCmzCKwkuM+Yryce0RoOi3OOmH6Ba/uTcCh/L37meyD0FJdJIprv59y4+n+k2kIeF/XKrKqg0dEsDUQRw0lUqqMt99ohqa+zmbJ44Yufdwwx/F1CtoRGvEQ2Mn0QjuqRoZJZ3wiT5Am22JiJW8MaNUl3wg9YPj+OPGARKKJUdUJ0NGUDQBcBAv5ds8LhbSbJSbPkbkwH/a1QMz4nEdn6lRDKI1aFIn43QhBSCFqvUq6TPJlbIJ0ZjE+PyZjHFBKCgkry0DHPXU2BbtIZPsksQnN3fx240a9K6sN7peZnLpEoMoq23FEz4g==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/<span class="number">1</span>nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+<span class="number">8</span>utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/<span class="number">40</span>BjpMUrDRCeKuiBahC0DCoU/<span class="number">4</span>+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>Help — About</strong>，搞定</li></ol><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16fc5d9a19720b1f.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>IntelliJ IDEA 2019.3官方指南 <strong><a href="https://www.jetbrains.com/help/idea/installation-guide.html" target="_blank" rel="noopener">www.jetbrains.com/help/idea/i…</a></strong></p><p>idea2019激活 <strong><a href="https://segmentfault.com/a/1190000021488264" target="_blank" rel="noopener">segmentfault.com/a/119000002…</a></strong></p>]]></content>
    
    <summary type="html">
    
      工欲善其事，必先利其器 ，当下有数不清的 Java 程序员将石器时代的 Eclipse 替换成了现代化的智能开发工具 InteliJ IDEA ，写代码的小日子过得不亦乐乎...
    
    </summary>
    
    
      <category term="技能get" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BDget/"/>
    
    
      <category term="IDEA" scheme="http://yoursite.com/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>[用PicGo+Gitee（码云）搭建Markdown图床]</title>
    <link href="http://yoursite.com/2020/07/08/%E7%94%A8PicGo-Gitee%EF%BC%88%E7%A0%81%E4%BA%91%EF%BC%89%E6%90%AD%E5%BB%BAMarkdown%E5%9B%BE%E5%BA%8A/"/>
    <id>http://yoursite.com/2020/07/08/%E7%94%A8PicGo-Gitee%EF%BC%88%E7%A0%81%E4%BA%91%EF%BC%89%E6%90%AD%E5%BB%BAMarkdown%E5%9B%BE%E5%BA%8A/</id>
    <published>2020-07-08T12:50:38.000Z</published>
    <updated>2020-07-08T12:50:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用PicGo-Gitee（码云）搭建Markdown图床"><a href="#用PicGo-Gitee（码云）搭建Markdown图床" class="headerlink" title="用PicGo+Gitee（码云）搭建Markdown图床"></a>用PicGo+Gitee（码云）搭建Markdown图床</h1><h2 id="一：引言"><a href="#一：引言" class="headerlink" title="一：引言"></a>一：引言</h2><p>图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种。</p><p>简单来说，图床就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 Electron-vue 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，<a href="http://sm.ms/" target="_blank" rel="noopener">SM.MS</a>，imgur 等8种常用图床，功能强大，简单易用，同时，它也支持Gitee（码云）。</p><h2 id="二：需要用到的软件"><a href="#二：需要用到的软件" class="headerlink" title="二：需要用到的软件"></a>二：需要用到的软件</h2><h3 id="1-Typora（Markdown文本编辑软件）"><a href="#1-Typora（Markdown文本编辑软件）" class="headerlink" title="1.Typora（Markdown文本编辑软件）"></a><strong>1.Typora（Markdown文本编辑软件）</strong></h3><h3 id="Typora-是一款支持实时预览的-Markdown-文本编辑器，并且完全免费。"><a href="#Typora-是一款支持实时预览的-Markdown-文本编辑器，并且完全免费。" class="headerlink" title="Typora 是一款支持实时预览的 Markdown 文本编辑器，并且完全免费。"></a><strong>Typora 是一款支持实时预览的 Markdown 文本编辑器，并且完全免费。</strong></h3><h3 id="下载地址：https-www-typora-io"><a href="#下载地址：https-www-typora-io" class="headerlink" title="下载地址：https://www.typora.io/"></a><strong>下载地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></strong></h3><h3 id="使用教程：https-www-cnblogs-com-xuexianqi-p-13260516-html"><a href="#使用教程：https-www-cnblogs-com-xuexianqi-p-13260516-html" class="headerlink" title="使用教程：https://www.cnblogs.com/xuexianqi/p/13260516.html"></a><strong>使用教程：<a href="https://www.cnblogs.com/xuexianqi/p/13260516.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuexianqi/p/13260516.html</a></strong></h3><h3 id="进入下载地址后，根据系统来选择安装包，下载完成后，直接无脑下一步即可，路径默认"><a href="#进入下载地址后，根据系统来选择安装包，下载完成后，直接无脑下一步即可，路径默认" class="headerlink" title="进入下载地址后，根据系统来选择安装包，下载完成后，直接无脑下一步即可，路径默认"></a><strong>进入下载地址后，根据系统来选择安装包，下载完成后，直接无脑下一步即可，路径默认</strong></h3><p><img src="/images/o_20070611481801.png" alt="o_20070611481801.png"></p><h3 id="2-PicGo（图床软件）"><a href="#2-PicGo（图床软件）" class="headerlink" title="2.PicGo（图床软件）"></a><strong>2.PicGo（图床软件）</strong></h3><h3 id="一个图床，一个用于快速上传图片并获取图片URL链接的工具，也完全免费。"><a href="#一个图床，一个用于快速上传图片并获取图片URL链接的工具，也完全免费。" class="headerlink" title="一个图床，一个用于快速上传图片并获取图片URL链接的工具，也完全免费。"></a><strong>一个图床，一个用于快速上传图片并获取图片URL链接的工具，也完全免费。</strong></h3><h3 id="官方指南：https-picgo-github-io-PicGo-Doc-zh-guide"><a href="#官方指南：https-picgo-github-io-PicGo-Doc-zh-guide" class="headerlink" title="官方指南：https://picgo.github.io/PicGo-Doc/zh/guide/"></a><strong>官方指南：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/" target="_blank" rel="noopener">https://picgo.github.io/PicGo-Doc/zh/guide/</a></strong></h3><h3 id="下载地址：https-github-com-Molunerfinn-PicGo-releases"><a href="#下载地址：https-github-com-Molunerfinn-PicGo-releases" class="headerlink" title="下载地址：https://github.com/Molunerfinn/PicGo/releases"></a><strong>下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases" target="_blank" rel="noopener">https://github.com/Molunerfinn/PicGo/releases</a></strong></h3><h3 id="GitHub网站进不去的点这里：https-www-cnblogs-com-xuexianqi-p-13219719-html"><a href="#GitHub网站进不去的点这里：https-www-cnblogs-com-xuexianqi-p-13219719-html" class="headerlink" title="GitHub网站进不去的点这里：https://www.cnblogs.com/xuexianqi/p/13219719.html"></a><strong>GitHub网站进不去的点这里：<a href="https://www.cnblogs.com/xuexianqi/p/13219719.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuexianqi/p/13219719.html</a></strong></h3><h3 id="进入下载地址后，选择最新版本，Windows系统点击-exe文件进行下载，安装直接无脑下一步，路径默认即可（MacOS系统点击-dmg文件，Linux系统点击tar-gz下载）"><a href="#进入下载地址后，选择最新版本，Windows系统点击-exe文件进行下载，安装直接无脑下一步，路径默认即可（MacOS系统点击-dmg文件，Linux系统点击tar-gz下载）" class="headerlink" title="进入下载地址后，选择最新版本，Windows系统点击.exe文件进行下载，安装直接无脑下一步，路径默认即可（MacOS系统点击.dmg文件，Linux系统点击tar.gz下载）"></a><strong>进入下载地址后，选择最新版本，Windows系统点击.exe文件进行下载，安装直接无脑下一步，路径默认即可（MacOS系统点击.dmg文件，Linux系统点击tar.gz下载）</strong></h3><p><img src="/images/o_20070611482102.png" alt="o_20070611482102.png"></p><h3 id="3-Gitee（码云）"><a href="#3-Gitee（码云）" class="headerlink" title="3.Gitee（码云）"></a><strong>3.Gitee（码云）</strong></h3><h3 id="码云，一款基于-Git-的代码托管和研发协作平台官方，又称为国内的github。"><a href="#码云，一款基于-Git-的代码托管和研发协作平台官方，又称为国内的github。" class="headerlink" title="码云，一款基于 Git 的代码托管和研发协作平台官方，又称为国内的github。"></a><strong>码云，一款基于 Git 的代码托管和研发协作平台官方，又称为国内的github。</strong></h3><h3 id="官方网站：https-gitee-com"><a href="#官方网站：https-gitee-com" class="headerlink" title="官方网站：https://gitee.com/"></a><strong>官方网站：<a href="https://gitee.com/" target="_blank" rel="noopener">https://gitee.com/</a></strong></h3><h3 id="注册网址：https-gitee-com-signup"><a href="#注册网址：https-gitee-com-signup" class="headerlink" title="注册网址：https://gitee.com/signup"></a><strong>注册网址：<a href="http://www.baidu.com/link?url=Q9yIAdEvisuJfrmu8LQ_LZt3jRfQICY7Q4jyCEKyPdkDfh2x1FcKkIfyg-7bkdLc" target="_blank" rel="noopener">https://gitee.com/signup</a></strong></h3><h1 id="三：搭建教程"><a href="#三：搭建教程" class="headerlink" title="三：搭建教程"></a><strong>三：搭建教程</strong></h1><h3 id="1-创建好Gitee账号后，点击右上角加号-“-”，点击：新建仓库"><a href="#1-创建好Gitee账号后，点击右上角加号-“-”，点击：新建仓库" class="headerlink" title="1.创建好Gitee账号后，点击右上角加号 “+”，点击：新建仓库"></a>1.创建好Gitee账号后，点击右上角加号 “+”，点击：新建仓库</h3><h3 id="2-仓库名称（自定义）-路径（自定义）-公开-使用Readme文件初始化这个仓库-创建"><a href="#2-仓库名称（自定义）-路径（自定义）-公开-使用Readme文件初始化这个仓库-创建" class="headerlink" title="2.仓库名称（自定义） - 路径（自定义） - 公开 - 使用Readme文件初始化这个仓库 - 创建"></a>2.仓库名称（自定义） - 路径（自定义） - 公开 - 使用Readme文件初始化这个仓库 - 创建</h3><p><img src="/images/o_20070710300302.png" alt="o_20070710300302.png"></p><h3 id="3-点击右上角用户头像右边的下拉框，点击：设置"><a href="#3-点击右上角用户头像右边的下拉框，点击：设置" class="headerlink" title="3.点击右上角用户头像右边的下拉框，点击：设置"></a>3.点击右上角用户头像右边的下拉框，点击：设置</h3><h3 id="4-点击左侧-：私人令牌"><a href="#4-点击左侧-：私人令牌" class="headerlink" title="4.点击左侧 ：私人令牌"></a>4.点击左侧 ：私人令牌</h3><h3 id="5-点击：生成新令牌"><a href="#5-点击：生成新令牌" class="headerlink" title="5.点击：生成新令牌"></a>5.点击：生成新令牌</h3><h3 id="6-私人令牌描述（自定义）-选择-“peojects”-提交"><a href="#6-私人令牌描述（自定义）-选择-“peojects”-提交" class="headerlink" title="6.私人令牌描述（自定义） - 选择 “peojects” - 提交"></a>6.私人令牌描述（自定义） - 选择 “peojects” - 提交</h3><p><img src="/images/o_20070710303206.png" alt="o_20070710303206.png"></p><h3 id="7-Note-自定义一个名称，repo-打上-√"><a href="#7-Note-自定义一个名称，repo-打上-√" class="headerlink" title="7.Note 自定义一个名称，repo 打上 √"></a>7.Note 自定义一个名称，repo 打上 √</h3><h3 id="8-输入登录码云的密码，点击：验证"><a href="#8-输入登录码云的密码，点击：验证" class="headerlink" title="8.输入登录码云的密码，点击：验证"></a>8.输入登录码云的密码，点击：验证</h3><p><img src="/images/o_20070710303507.png" alt="o_20070710303507.png"></p><h3 id="9-现在生成的是一串Token，只会在现在显示一次，所以要妥善保管好，点击：复制-打勾“我已经了解…”-确认并关闭"><a href="#9-现在生成的是一串Token，只会在现在显示一次，所以要妥善保管好，点击：复制-打勾“我已经了解…”-确认并关闭" class="headerlink" title="9.现在生成的是一串Token，只会在现在显示一次，所以要妥善保管好，点击：复制 - 打勾“我已经了解…” - 确认并关闭"></a>9.现在生成的是一串Token，只会在现在显示一次，所以要妥善保管好，点击：复制 - 打勾“我已经了解…” - 确认并关闭</h3><p><img src="/images/o_20070710303808.png" alt="o_20070710303808.png"></p><h3 id="10-打开PicGo，点击左侧-插件设置-搜索框输入：gitee-点击右边的gitee-uploader：安装"><a href="#10-打开PicGo，点击左侧-插件设置-搜索框输入：gitee-点击右边的gitee-uploader：安装" class="headerlink" title="10.打开PicGo，点击左侧 - 插件设置 - 搜索框输入：gitee - 点击右边的gitee-uploader：安装"></a>10.打开PicGo，点击左侧 - 插件设置 - 搜索框输入：gitee - 点击右边的gitee-uploader：安装</h3><p><img src="/images/o_20070710304309.png" alt="o_20070710304309.png"></p><h3 id="11-点击左侧：图床设置-gitee，进行如下设置"><a href="#11-点击左侧：图床设置-gitee，进行如下设置" class="headerlink" title="11.点击左侧：图床设置 - gitee，进行如下设置"></a>11.点击左侧：图床设置 - gitee，进行如下设置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">repo：  填写用户名/仓库名</span><br><span class="line"></span><br><span class="line">branch：  填写：master</span><br><span class="line"></span><br><span class="line">token：  填写刚才生成的那一串token</span><br><span class="line"></span><br><span class="line">path：  填写：img</span><br><span class="line"></span><br><span class="line">customPath：  默认即可，不用填写</span><br><span class="line"></span><br><span class="line">customUrl：  默认即可，不用填写</span><br></pre></td></tr></table></figure><p><img src="/images/1594124775(1).png" alt="1594124775(1).png"></p><h2 id="四：图片上传至图库的方法1（推荐）"><a href="#四：图片上传至图库的方法1（推荐）" class="headerlink" title="四：图片上传至图库的方法1（推荐）"></a><strong>四：图片上传至图库的方法1（推荐）</strong></h2><h3 id="1-打开Typora，点击左上角：文件-偏好设置"><a href="#1-打开Typora，点击左上角：文件-偏好设置" class="headerlink" title="1.打开Typora，点击左上角：文件 - 偏好设置"></a><strong>1.打开Typora，点击左上角：文件 - 偏好设置</strong></h3><h3 id="2-点击：图像-插入图片时（下拉选择：上传图片）-对网络位置的图片应用上述规则（可选可不选，选中就是图片也会复制到本地）-允许根据YAML设置自动上传图片-上传服务：下拉后选择-PicGo（app）-选择PicGo路径"><a href="#2-点击：图像-插入图片时（下拉选择：上传图片）-对网络位置的图片应用上述规则（可选可不选，选中就是图片也会复制到本地）-允许根据YAML设置自动上传图片-上传服务：下拉后选择-PicGo（app）-选择PicGo路径" class="headerlink" title="2.点击：图像 - 插入图片时（下拉选择：上传图片） - 对网络位置的图片应用上述规则（可选可不选，选中就是图片也会复制到本地） - 允许根据YAML设置自动上传图片 - 上传服务：下拉后选择 PicGo（app） - 选择PicGo路径"></a>2.点击：图像 - 插入图片时（下拉选择：上传图片） - 对网络位置的图片应用上述规则（可选可不选，选中就是图片也会复制到本地） - 允许根据YAML设置自动上传图片 - 上传服务：下拉后选择 PicGo（app） - 选择PicGo路径</h3><p><img src="/images/o_20070612482223.png" alt="o_20070612482223.png"></p><h3 id="3-找到PicGo的安装路径，默认是C-Program-Files-PicGo点击：打开"><a href="#3-找到PicGo的安装路径，默认是C-Program-Files-PicGo点击：打开" class="headerlink" title="3.找到PicGo的安装路径，默认是C:\Program Files\PicGo点击：打开"></a>3.找到PicGo的安装路径，默认是C:\Program Files\PicGo点击：打开</h3><p><img src="/images/o_20070612104519.png" alt="o_20070612104519.png"></p><h3 id="4-点击：验证图片上传选项，显示绿色字-“成功上床图片并获得新的URL”，点击：OK"><a href="#4-点击：验证图片上传选项，显示绿色字-“成功上床图片并获得新的URL”，点击：OK" class="headerlink" title="4.点击：验证图片上传选项，显示绿色字 “成功上床图片并获得新的URL”，点击：OK"></a>4.点击：验证图片上传选项，显示绿色字 “成功上床图片并获得新的URL”，点击：OK</h3><p><img src="/images/20200707184938.png" alt="20200707184938.png"></p><h3 id="5-此时，截完图之后，直接按粘贴快捷键（Ctrl-V）即可将图片上传到图库"><a href="#5-此时，截完图之后，直接按粘贴快捷键（Ctrl-V）即可将图片上传到图库" class="headerlink" title="5.此时，截完图之后，直接按粘贴快捷键（Ctrl+V）即可将图片上传到图库"></a>5.此时，截完图之后，直接按粘贴快捷键（Ctrl+V）即可将图片上传到图库</h3><h3 id="6-也成功显示出来了"><a href="#6-也成功显示出来了" class="headerlink" title="6.也成功显示出来了"></a>6.也成功显示出来了</h3><p><img src="/images/20200707185045.png" alt="20200707185045.png"></p><h1 id="五：图片上传至图库的方法2"><a href="#五：图片上传至图库的方法2" class="headerlink" title="五：图片上传至图库的方法2"></a><strong>五：图片上传至图库的方法2</strong></h1><h3 id="1-设置快捷键"><a href="#1-设置快捷键" class="headerlink" title="1.设置快捷键"></a>1.设置快捷键</h3><p><img src="/images/o_20070611485712.png" alt="o_20070611485712.png"></p><h3 id="2-点击：编辑"><a href="#2-点击：编辑" class="headerlink" title="2.点击：编辑"></a>2.点击：编辑</h3><p><img src="/images/o_20070611490013.png" alt="o_20070611490013.png"></p><h3 id="3-同时按住Ctrl、Shift、V-组合键（当然，也可以自定义），点击：确定"><a href="#3-同时按住Ctrl、Shift、V-组合键（当然，也可以自定义），点击：确定" class="headerlink" title="3.同时按住Ctrl、Shift、V 组合键（当然，也可以自定义），点击：确定"></a>3.同时按住Ctrl、Shift、V 组合键（当然，也可以自定义），点击：确定</h3><p><img src="/images/o_20070611490414.png" alt="o_20070611490414.png"></p><h3 id="4-我们截完图之后，直接按下快捷键（Ctrl-Shift-V）就把截图上传到图库了，并且自动复制了图片的外链，然后我们直接按下快捷键（Ctr-V）就可以粘贴了"><a href="#4-我们截完图之后，直接按下快捷键（Ctrl-Shift-V）就把截图上传到图库了，并且自动复制了图片的外链，然后我们直接按下快捷键（Ctr-V）就可以粘贴了" class="headerlink" title="4.我们截完图之后，直接按下快捷键（Ctrl+Shift+V）就把截图上传到图库了，并且自动复制了图片的外链，然后我们直接按下快捷键（Ctr+V）就可以粘贴了"></a>4.我们截完图之后，直接按下快捷键（Ctrl+Shift+V）就把截图上传到图库了，并且自动复制了图片的外链，然后我们直接按下快捷键（Ctr+V）就可以粘贴了</h3><p><img src="/images/20200707185135.png" alt="20200707185135.png"></p><h3 id="5-单击图片即可看到图片的外链"><a href="#5-单击图片即可看到图片的外链" class="headerlink" title="5.单击图片即可看到图片的外链"></a>5.单击图片即可看到图片的外链</h3><p><img src="/images/20200707185144.png" alt="20200707185144.png"></p><h2 id="Ending…"><a href="#Ending…" class="headerlink" title="Ending…."></a>Ending….</h2>]]></content>
    
    <summary type="html">
    
      一：引言,图床一般是指储存图片的服务器，有国内和国外之分。国外的图床由于有空间距离等因素决定访问速度很慢影响图片显示速度。国内也分为单线空间、多线空间和cdn加速三种...
    
    </summary>
    
    
      <category term="技能get" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BDget/"/>
    
    
      <category term="图床制作" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BA%8A%E5%88%B6%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>[用Hexo+Github搭建个人博客]</title>
    <link href="http://yoursite.com/2020/07/08/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2020/07/08/%E7%94%A8Hexo-Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2020-07-08T12:50:38.000Z</published>
    <updated>2020-07-10T12:50:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hexo框架搭建个人博客"><a href="#hexo框架搭建个人博客" class="headerlink" title="hexo框架搭建个人博客"></a>hexo框架搭建个人博客</h1><h2 id="1-github配置"><a href="#1-github配置" class="headerlink" title="1. github配置"></a>1. github配置</h2><h3 id="下载安装git"><a href="#下载安装git" class="headerlink" title="下载安装git"></a>下载安装git</h3><h3 id="https-git-scm-com"><a href="#https-git-scm-com" class="headerlink" title="https://git-scm.com/"></a><a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a></h3><h3 id="桌面右击打开Git-Bash-Here"><a href="#桌面右击打开Git-Bash-Here" class="headerlink" title="桌面右击打开Git Bash Here"></a>桌面右击打开Git Bash Here</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"用户名"</span></span><br><span class="line"></span><br><span class="line">$ git config --global user.email <span class="string">"邮箱"</span></span><br></pre></td></tr></table></figure><h3 id="登录github"><a href="#登录github" class="headerlink" title="登录github"></a>登录github</h3><p><img src="/images/github.png" alt="github.png"></p><h3 id="创建新仓库"><a href="#创建新仓库" class="headerlink" title="创建新仓库"></a>创建新仓库</h3><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041.png" alt="hexo%20b6a26e944b45432b84f717029640e041.png"></p><h3 id="仓库名是固定的，用户名-github-io，这边已经创建过，所以飘红"><a href="#仓库名是固定的，用户名-github-io，这边已经创建过，所以飘红" class="headerlink" title="仓库名是固定的，用户名+github.io，这边已经创建过，所以飘红"></a>仓库名是固定的，用户名+github.io，这边已经创建过，所以飘红</h3><p><img src="/images/2.png" alt="2.png"></p><h3 id="生成key，在到ssh-key位置"><a href="#生成key，在到ssh-key位置" class="headerlink" title="生成key，在到ssh-key位置"></a>生成key，在到ssh-key位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t -rsa -C <span class="string">"fastsword66@gmail.com"</span></span><br></pre></td></tr></table></figure><p><img src="/images/ssh-keygen.png" alt="ssh-keygen.png"></p><h3 id="找到ssh-keygen目录，复制id-rsa-pub中的内容"><a href="#找到ssh-keygen目录，复制id-rsa-pub中的内容" class="headerlink" title="找到ssh-keygen目录，复制id_rsa.pub中的内容"></a>找到ssh-keygen目录，复制id_rsa.pub中的内容</h3><p><img src="/images/ssh-keygen%201.png" alt="ssh-keygen%201.png"></p><h3 id="到github的settings中设置ssh-keys，把复制的内容copy进去"><a href="#到github的settings中设置ssh-keys，把复制的内容copy进去" class="headerlink" title="到github的settings中设置ssh-keys，把复制的内容copy进去"></a>到github的settings中设置ssh-keys，把复制的内容copy进去</h3><p><img src="/images/ssh.png" alt="ssh.png"></p><p><img src="/images/copy-key.png" alt="copy-key.png"></p><h3 id="确认key是否能够使用"><a href="#确认key是否能够使用" class="headerlink" title="确认key是否能够使用"></a>确认key是否能够使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><h2 id="2-hexo框架"><a href="#2-hexo框架" class="headerlink" title="2. hexo框架"></a>2. hexo框架</h2><h3 id="查看npm版本号"><a href="#查看npm版本号" class="headerlink" title="查看npm版本号"></a>查看npm版本号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><h3 id="如果有就通过npm安装hexo"><a href="#如果有就通过npm安装hexo" class="headerlink" title="如果有就通过npm安装hexo"></a>如果有就通过npm安装hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p><img src="/images/hexo.png" alt="hexo.png"></p><h3 id="选个位置创建个新文件夹myblog，在文件夹中右键打开Git-Bash-Here，初始化hexo"><a href="#选个位置创建个新文件夹myblog，在文件夹中右键打开Git-Bash-Here，初始化hexo" class="headerlink" title="选个位置创建个新文件夹myblog，在文件夹中右键打开Git Bash Here，初始化hexo"></a>选个位置创建个新文件夹myblog，在文件夹中右键打开Git Bash Here，初始化hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><h3 id="安装hexo-deploy-git，方便以后用hexo-deoloy去部署网站"><a href="#安装hexo-deploy-git，方便以后用hexo-deoloy去部署网站" class="headerlink" title="安装hexo-deploy-git，方便以后用hexo-deoloy去部署网站"></a>安装hexo-deploy-git，方便以后用hexo-deoloy去部署网站</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="本地测试是否能预览博客，复制地址"><a href="#本地测试是否能预览博客，复制地址" class="headerlink" title="本地测试是否能预览博客，复制地址"></a>本地测试是否能预览博客，复制地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041%201.png" alt="hexo%20b6a26e944b45432b84f717029640e041%201.png"></p><h3 id="打开-config设置deployment"><a href="#打开-config设置deployment" class="headerlink" title="打开_config设置deployment"></a>打开_config设置deployment</h3><p><img src="/images/deployment.png" alt="deployment.png"></p><h3 id="repository从你的仓库中copy"><a href="#repository从你的仓库中copy" class="headerlink" title="repository从你的仓库中copy"></a>repository从你的仓库中copy</h3><p><img src="/images/1593523025(1).png" alt="1593523025(1).png"></p><h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctrl+c 退出server</span><br><span class="line"></span><br><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h2 id="3-更换主题"><a href="#3-更换主题" class="headerlink" title="3. 更换主题"></a>3. 更换主题</h2><h3 id="到hexo官网：-https-hexo-io-zh-cn"><a href="#到hexo官网：-https-hexo-io-zh-cn" class="headerlink" title="到hexo官网： https://hexo.io/zh-cn/"></a>到hexo官网： <a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></h3><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041%202.png" alt="hexo%20b6a26e944b45432b84f717029640e041%202.png"></p><p><img src="/images/2%201.png" alt="2%201.png"></p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041%203.png" alt="hexo%20b6a26e944b45432b84f717029640e041%203.png"></p><h3 id="解压后放到myblog中的themes"><a href="#解压后放到myblog中的themes" class="headerlink" title="解压后放到myblog中的themes"></a>解压后放到myblog中的themes</h3><p><img src="/images/1593525431(1).png" alt="1593525431(1).png"></p><h3 id="打开-config设置主题，名称是主题文件夹名字，可以更改"><a href="#打开-config设置主题，名称是主题文件夹名字，可以更改" class="headerlink" title="打开_config设置主题，名称是主题文件夹名字，可以更改"></a>打开_config设置主题，名称是主题文件夹名字，可以更改</h3><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041%204.png" alt="hexo%20b6a26e944b45432b84f717029640e041%204.png"></p><h3 id="生成静态文件-1"><a href="#生成静态文件-1" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><h3 id="部署发布"><a href="#部署发布" class="headerlink" title="部署发布"></a>部署发布</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="完成，是不是非常简单"><a href="#完成，是不是非常简单" class="headerlink" title="完成，是不是非常简单"></a>完成，是不是非常简单</h3><p><img src="/images/hexo%20b6a26e944b45432b84f717029640e041%205.png" alt="hexo%20b6a26e944b45432b84f717029640e041%205.png"></p><h2 id="Ending…"><a href="#Ending…" class="headerlink" title="Ending…"></a>Ending…</h2>]]></content>
    
    <summary type="html">
    
      hexo框架搭建个人博客 1. github配置,下载安装git,桌面右击打开Git Bash Here 创建新仓库,仓库名是固定的，用户名+github.io，这边已经创建过，所以飘红...
    
    </summary>
    
    
      <category term="技能get" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BDget/"/>
    
    
      <category term="博客搭建" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>[客户端使用]</title>
    <link href="http://yoursite.com/2020/06/22/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/06/22/%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/</id>
    <published>2020-06-22T06:23:33.000Z</published>
    <updated>2020-06-22T06:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-Python客户端"><a href="#一-Python客户端" class="headerlink" title="一 Python客户端"></a>一 Python客户端</h2><h3 id="1-Python操作Redis之普通连接"><a href="#1-Python操作Redis之普通连接" class="headerlink" title="1 Python操作Redis之普通连接"></a>1 Python操作Redis之普通连接</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1 pip3 install redis</span></span><br><span class="line"><span class="comment"># 简单使用</span></span><br><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> Redis</span><br><span class="line"><span class="comment"># conn=Redis()</span></span><br><span class="line"><span class="comment"># 连接对象</span></span><br><span class="line">conn=Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</span><br><span class="line">ret=conn.get(<span class="string">'name'</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><h3 id="2-Python操作Redis之连接池"><a href="#2-Python操作Redis之连接池" class="headerlink" title="2 Python操作Redis之连接池"></a>2 Python操作Redis之连接池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># t_redis_pool.py</span></span><br><span class="line"><span class="comment"># redis连接池</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># pool必须是单例的</span></span><br><span class="line">POOL = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>,max_connections=<span class="number">100</span>)  <span class="comment"># 造一个池子,最多能放100个连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># t_redis_conn.py</span></span><br><span class="line"><span class="comment"># redis连接池</span></span><br><span class="line"><span class="comment"># import redis</span></span><br><span class="line"><span class="comment"># pool必须是单例的</span></span><br><span class="line"><span class="comment"># pool = redis.ConnectionPool(host='127.0.0.1', port=6379,max_connections=100)  # 造一个池子,最多能放100个连接</span></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="comment"># 包内的py文件，如果想右键运行，导包的时候不能带点</span></span><br><span class="line"><span class="keyword">from</span> t_redis_pool <span class="keyword">import</span> POOL  <span class="comment"># pycharm提示的错</span></span><br><span class="line">r = redis.Redis(connection_pool=POOL)  <span class="comment"># 只要执行这一句话，就是从池中拿出一个连接</span></span><br><span class="line">ret=r.get(<span class="string">'name'</span>)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><h3 id="3-操作之String操作"><a href="#3-操作之String操作" class="headerlink" title="3 操作之String操作"></a>3 操作之String操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串操作</span></span><br><span class="line"><span class="comment"># 1 set的用法</span></span><br><span class="line"><span class="comment"># conn.set('height',180) #基本使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.set('height','190',nx=True)</span></span><br><span class="line"><span class="comment"># conn.set('height','190',xx=True)</span></span><br><span class="line"><span class="comment"># conn.set('height1','190',xx=True)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">ex，过期时间（秒）</span></span><br><span class="line"><span class="string">     px，过期时间（毫秒）</span></span><br><span class="line"><span class="string">     nx，如果设置为True，则只有name不存在时，当前set操作才执行,值存在，就修改不了，执行没效果</span></span><br><span class="line"><span class="string">     xx，如果设置为True，则只有name存在时，当前set操作才执行，值存在才能修改，值不存在，不会设置新值</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># setnx(name, value)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置值，只有name不存在时，执行设置操作（添加）,如果存在，不会修改</span></span><br><span class="line"><span class="comment"># setex(name, value, time)</span></span><br><span class="line"><span class="comment"># 设置值</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line"><span class="comment"># time，过期时间（数字秒 或 timedelta对象）</span></span><br><span class="line"><span class="comment"># psetex(name, time_ms, value)</span></span><br><span class="line"><span class="comment"># 设置值</span></span><br><span class="line"><span class="comment"># 参数：</span></span><br><span class="line"><span class="comment"># time_ms，过期时间（数字毫秒 或 timedelta对象）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># mset</span></span><br><span class="line"><span class="comment"># conn.mset(&#123;'name1':'11','name3':'dasfd'&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.mget(['name1','name','name3'])</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.getset('name1', '999')</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.getrange('name1',0,0) # 前闭后闭区间</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.setrange('name1',1,88888)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.getbit('name1',9)</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#incr ：统计网站访问量，页面访问量，接口访问量</span></span><br><span class="line"><span class="comment"># conn.incr('name1')  # 只要一执行，数字加1</span></span><br><span class="line"><span class="comment"># conn.incr('name1')  # 只要一执行，数字加1</span></span><br><span class="line"><span class="comment"># conn.incr('name1')  # 只要一执行，数字加1</span></span><br><span class="line"><span class="comment"># conn.incr('name1')  # 只要一执行，数字加1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#decr</span></span><br><span class="line"><span class="comment"># conn.incr('name1',-2)</span></span><br><span class="line"><span class="comment"># conn.decr('name1',3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.append('name1','oo')</span></span><br><span class="line"><span class="comment"># conn.incr('name1')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##重点：</span></span><br><span class="line"><span class="comment">#set :很多参数</span></span><br><span class="line"><span class="comment">#get</span></span><br><span class="line"><span class="comment">#mset</span></span><br><span class="line"><span class="comment">#mget</span></span><br><span class="line"><span class="comment">#incr</span></span><br><span class="line"><span class="comment">#decr</span></span><br><span class="line"><span class="comment">#append</span></span><br></pre></td></tr></table></figure><h3 id="4-操作之Hash操作"><a href="#4-操作之Hash操作" class="headerlink" title="4 操作之Hash操作"></a>4 操作之Hash操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># hash操作</span></span><br><span class="line"><span class="comment"># conn.hset('hash1','name','lqz')</span></span><br><span class="line"><span class="comment"># conn.hset('hash1','name2','lqz')</span></span><br><span class="line"><span class="comment"># conn.hset('hash1','name','lqz444')  # key不可以重复，</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.hget('hash1','name')  #只能取一个</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.hmset('hash2',&#123;'key1':'value1','key2':'value2'&#125;)</span></span><br><span class="line"><span class="comment"># ret=conn.hmget('hash1','name','name2')</span></span><br><span class="line"><span class="comment"># ret=conn.hmget('hash1',['name','name2'])</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.hgetall('hash1')  # 尽量少用</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.hlen('hash1')</span></span><br><span class="line"><span class="comment"># ret=conn.hkeys('hash1')</span></span><br><span class="line"><span class="comment"># ret=conn.hexists('hash1','name1')</span></span><br><span class="line"><span class="comment"># ret=conn.hdel('hash1','name')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># conn.hset('hash1','name',12)</span></span><br><span class="line"><span class="comment"># ret=conn.hincrby('hash1','name')</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以后想取出hash类型内所有的数据，不建议用hgetall，建议用hscan_iter</span></span><br><span class="line"><span class="comment"># 一次性先取一部分回来（假设有1w条，先取回100条，把这100条做成了生成器）</span></span><br><span class="line"><span class="comment"># ret=conn.hscan_iter('hash1')</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"><span class="comment"># for i in ret:</span></span><br><span class="line"><span class="comment">#     print(i)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##重点掌握</span></span><br><span class="line"><span class="comment"># hset</span></span><br><span class="line"><span class="comment"># hget</span></span><br><span class="line"><span class="comment">#hmset</span></span><br><span class="line"><span class="comment">#hmget</span></span><br><span class="line"><span class="comment"># hincrby</span></span><br><span class="line"><span class="comment"># 区分hgetall和hscan_iter</span></span><br></pre></td></tr></table></figure><h3 id="5-操作之List操作"><a href="#5-操作之List操作" class="headerlink" title="5 操作之List操作"></a>5 操作之List操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 列表操作</span></span><br><span class="line"><span class="comment"># ret=conn.lpush('list1',1,2,3,4,5)</span></span><br><span class="line"><span class="comment"># ret=conn.rpush('list1',999)</span></span><br><span class="line"><span class="comment"># ret=conn.lpushx('list2',1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lpushx('list1',888)  # 必须有这个key才能放</span></span><br><span class="line"><span class="comment"># ret=conn.rpushx('list1',666)  # 我们猜，返回总长度</span></span><br><span class="line"><span class="comment"># ret=conn.llen('list1')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.linsert('list1','before','3','77777777')</span></span><br><span class="line"><span class="comment"># ret=conn.linsert('list1','after','3','66666666')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lset('list1',3,'22222')  #从0开始计数</span></span><br><span class="line"><span class="comment"># ret=conn.lset('list1',0,'11111')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lrem('list1',2,'5')  # 从前往后删除两个5</span></span><br><span class="line"><span class="comment"># ret=conn.lrem('list1',-1,'5') # 从后往前删除1个5</span></span><br><span class="line"><span class="comment"># ret=conn.lrem('list1',0,'5')   # 删除所有5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lpop('list1')</span></span><br><span class="line"><span class="comment"># ret=conn.rpop('list1')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lindex('list1',0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.lrange('list1',0,2)  # 前闭后闭</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.ltrim('list1',1,2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重点block,阻塞,可以写一个超时时间</span></span><br><span class="line"><span class="comment"># ret=conn.blpop('list1',timeout=10)</span></span><br><span class="line"><span class="comment"># print(ret)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定制分批取列表的数据</span></span><br><span class="line"><span class="comment"># conn.lpush('test',*[1,2,3,4,45,5,6,7,7,8,43,5,6,768,89,9,65,4,23,54,6757,8,68])</span></span><br><span class="line"><span class="comment"># conn.flushall()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan_list</span><span class="params">(name,count=<span class="number">2</span>)</span>:</span></span><br><span class="line">    index=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data_list=conn.lrange(name,index,count+index<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data_list:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index+=count</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> data_list:</span><br><span class="line">            <span class="keyword">yield</span> item</span><br><span class="line"><span class="comment"># print(conn.lrange('test',0,100))</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> scan_list(<span class="string">'test'</span>,<span class="number">5</span>):</span><br><span class="line">    print(<span class="string">'---'</span>)</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 重点</span></span><br><span class="line">lpush</span><br><span class="line">lpop</span><br><span class="line">blpop</span><br><span class="line">lrange</span><br><span class="line">llen</span><br></pre></td></tr></table></figure><h3 id="5-redsi的其他使用"><a href="#5-redsi的其他使用" class="headerlink" title="5 redsi的其他使用"></a>5 redsi的其他使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其他操作</span></span><br><span class="line"><span class="comment"># conn.delete('list1')</span></span><br><span class="line"><span class="comment"># ret=conn.delete('hash1')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.exists('hash2')</span></span><br><span class="line"><span class="comment"># ret=conn.keys('cache*')  #查询以cache开头的所有key</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.expire('hash2',2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ret=conn.type('name3')</span></span><br><span class="line"><span class="comment"># ret=conn.type('test')</span></span><br><span class="line"><span class="comment"># ret=conn.type('test')</span></span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure><h2 id="二-Go客户端"><a href="#二-Go客户端" class="headerlink" title="二 Go客户端"></a>二 Go客户端</h2>]]></content>
    
    <summary type="html">
    
      Python操作Redis之普通连接 1 pip3 install redis,简单使用from redis import Redis,conn=Redis()连接对象conn=Redis(host=&#39;127.0.0.1&#39;, port=6379),ret=conn.get(&#39;name&#39;)...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[「直击面试」MySQL三万字精华总结]</title>
    <link href="http://yoursite.com/2020/06/22/MySQL%E4%B8%89%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/06/22/MySQL%E4%B8%89%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-21T23:46:33.000Z</published>
    <updated>2020-06-21T23:46:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/mysql%E6%94%BB%E7%95%A5.png" alt=""></p><blockquote><p>写在之前：不建议那种上来就是各种面试题罗列，然后背书式的去记忆，对技术的提升帮助很小，对正经面试也没什么帮助，有点东西的面试官深挖下就懵逼了。</p><p>个人建议把面试题看作是费曼学习法中的回顾、简化的环节，准备面试的时候，跟着题目先自己讲给自己听，看看自己会满意吗，不满意就继续学习这个点，如此反复，好的offer离你不远的，奥利给</p><p>……</p></blockquote><blockquote><p>成长手册，<strong>GitHub</strong> <a href="https://github.com/rogerXS80/roger" target="_blank" rel="noopener">Lupinus</a> ，N线互联网开发必备技能兵器谱</p></blockquote><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff308f75df1.jpg" alt=""></p><h2 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a>一、MySQL架构</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff308eb9e2d.jpg" alt=""></p><ul><li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li><li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等</li><li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li><li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li></ul><blockquote><p>画出 MySQL 架构图，这种变态问题都能问的出来MySQL 的查询流程具体是？or  一条SQL语句在MySQL中如何执行的？</p></blockquote><p>客户端请求 —&gt; 连接器（验证用户身份，给予权限） —&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作） —&gt; 分析器（对SQL进行词法分析和语法分析操作） —&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法） —&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） —&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff309fc730f.jpg" alt=""></p><hr><blockquote><p>说说MySQL有哪些存储引擎？都有哪些区别？</p></blockquote><h2 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h2><p>存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。</p><p>使用哪一种引擎可以灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能 。</p><p>MySQL服务器使用<strong>可插拔</strong>的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。</p><h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看支持的存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ENGINES</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看默认存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'storage_engine'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tablename</span><br><span class="line"></span><br><span class="line"><span class="comment">--准确查看某个数据库中的某一表所使用的存储引擎</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'tablename'</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span> <span class="keyword">database</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"tablename"</span></span><br></pre></td></tr></table></figure><h3 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表时指定存储引擎。默认的就是INNODB，不需要设置</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = CSV;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = <span class="keyword">MEMORY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改存储引擎</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎</span></span><br><span class="line"><span class="keyword">SET</span> default_storage_engine=NDBCLUSTER;</span><br></pre></td></tr></table></figure><p>默认情况下，每当 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用 <code>NO_ENGINE_SUBSTITUTION SQL</code> 模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表</p><h3 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h3><p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p><p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键</strong></p><h3 id="文件存储结构对比"><a href="#文件存储结构对比" class="headerlink" title="文件存储结构对比"></a>文件存储结构对比</h3><p>在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 <code>.frm</code> 文件，<code>.frm</code> 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有<code>.frm</code>文件，命名方式为 数据表名.frm，如user.frm。</p><p>查看MySQL 数据保存在哪里：<code>show variables like &#39;data%&#39;</code></p><p>MyISAM 物理文件结构为：</p><ul><li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据</li><li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息</li></ul><p>InnoDB 物理文件结构为：</p><ul><li><p><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</p></li><li><p><code>.ibd</code> 文件或 <code>.ibdata</code> 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。</p><p>独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件 共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</p></li></ul><h3 id="面试这么回答"><a href="#面试这么回答" class="headerlink" title="面试这么回答"></a>面试这么回答</h3><ol><li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li><li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li><li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li></ol><table><thead><tr><th align="center">对比项</th><th align="center">MyISAM</th><th align="center">InnoDB</th></tr></thead><tbody><tr><td align="center">主外键</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">单元格</td><td align="center">单元格</td><td align="center">单元格</td></tr><tr><td align="center">事务</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">行表锁</td><td align="center">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td align="center">行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td align="center">缓存</td><td align="center">只缓存索引，不缓存真实数据</td><td align="center">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td align="center">表空间</td><td align="center">小</td><td align="center">大</td></tr><tr><td align="center">关注点</td><td align="center">性能</td><td align="center">事务</td></tr><tr><td align="center">默认安装</td><td align="center">是</td><td align="center">是</td></tr></tbody></table><blockquote><p>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p></blockquote><p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p><p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p><blockquote><p>哪个存储引擎执行 select count(*) 更快，为什么?</p></blockquote><p>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。</p><ul><li>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li><li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li></ul><p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p><h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h2><p>主要包括以下五大类：</p><ul><li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li><li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li><li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li><li>日期类型：Date、DateTime、TimeStamp、Time、Year</li><li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li></ul><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff30a28cf0d.jpg" alt=""></p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff309f9eea0.jpg" alt=""></p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff30a5e00fe.jpg" alt=""></p><blockquote><p>CHAR 和 VARCHAR 的区别？</p></blockquote><p>char是固定长度，varchar长度可变：</p><p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p><p>存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间</p><p>相同点：</p><ol><li>char(n)，varchar(n)中的n都代表字符的个数</li><li>超过char，varchar最大长度n的限制后，字符串会被截断。</li></ol><p>不同点：</p><ol><li>char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0&lt;=length&lt;255）或加2（length&gt;255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。</li><li>能存储的最大空间限制不一样：char的存储上限为255字节。</li><li>char在存储时会截断尾部的空格，而varchar不会。</li></ol><p>char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</p><blockquote><p>列的字符串类型可以是什么？</p></blockquote><p>字符串类型是：SET、BLOB、ENUM、CHAR、TEXT、VARCHAR</p><blockquote><p>BLOB和TEXT有什么区别？</p></blockquote><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB</p><p>TEXT是一个不区分大小写的BLOB。四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。</p><p>BLOB 保存二进制数据，TEXT 保存字符数据。</p><hr><h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><blockquote><p>说说你对 MySQL 索引的理解？数据库索引的原理，为什么要用 B+树，为什么不用二叉树？聚集索引与非聚集索引的区别？InnoDB引擎中的索引策略，了解过吗？创建索引的方式有哪些？聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p></blockquote><ul><li><p>MYSQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong></p></li><li><p>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。</p></li><li><p>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，<font color=red size=3><strong>数据库还维护者一个满足特定查找算法的数据结构</strong></font>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff356f9f2f0.jpg" alt=""></p><p>左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址</p><p>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。</p></li><li><p>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></p></li><li><p>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</p></li></ul><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><ul><li><p>创建：</p><ul><li><p>创建索引：<font color=red size=3><code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code></font></p><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p></li><li><p>修改表结构(添加索引)：<font color=red size=3><code>ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</code></font></p></li></ul></li><li><p>删除：<font color=red size=3><code>DROP INDEX [indexName] ON mytable;</code></font></p></li><li><p>查看：<font color=red size=3><code>SHOW INDEX FROM table_name\\G</code></font> –可以通过添加 \G 来格式化输出信息。</p></li><li><p>使用ALERT命令</p><ul><li><font color=red size=3><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code></font> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li><li><font color=red size=3><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code></font> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li><li><font color=red size=3><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code></font> 添加普通索引，索引值可出现多次。</li><li><font color=red size=3><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code></font>该语句指定了索引为 FULLTEXT ，用于全文索引。</li></ul></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><strong>提高数据检索效率，降低数据库IO成本</strong></li><li><strong>降低数据排序的成本，降低CPU的消耗</strong></li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</li></ul><h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3><h3 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h3><ul><li>B+树索引</li><li>Hash索引</li><li>Full-Text全文索引</li><li>R-Tree索引</li></ul><h3 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h3><ul><li><p>聚集索引（clustered index）</p></li><li><p>非聚集索引（non-clustered index），也叫辅助索引（secondary index）</p><p>聚集索引和非聚集索引都是B+树结构</p></li></ul><h3 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h3><ul><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li><li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>唯一索引或者非唯一索引</li><li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。 MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</li></ul><blockquote><p>为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？使用索引查询一定能提高查询的性能吗？为什么?</p></blockquote><h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h3><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。</p><p><strong>先了解下 B-Tree 和 B+Tree 的区别</strong></p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。</p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></p><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p>一棵m阶的B-Tree有如下特性：</p><ol><li>每个节点最多有m个孩子</li><li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li><li>若根节点不是叶子节点，则至少有2个孩子</li><li>所有叶子节点都在同一层，且不包含其它关键字信息</li><li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li><li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li><li>ki(i=1,…n)为关键字，且关键字升序排序</li><li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li></ol><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff356b40f0d.jpg" alt=""></p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><p>模拟查找关键字29的过程：</p><ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ol><p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</p><p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上</strong>，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p>B+Tree相对于B-Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息；</li><li>所有叶子节点之间都有一个链指针；</li><li>数据记录都存放在叶子节点中</li></ol><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff3498c6715.jpg" alt=""></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p><p>B+Tree性质</p><ol><li>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li><li>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li></ol><h3 id="MyISAM主键索引与辅助索引的结构"><a href="#MyISAM主键索引与辅助索引的结构" class="headerlink" title="MyISAM主键索引与辅助索引的结构"></a>MyISAM主键索引与辅助索引的结构</h3><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”<strong>非聚簇索引</strong>“。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff35bbbf112.jpg" alt=""></p><p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。</p><p>主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。</p><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p><h3 id="InnoDB主键索引与辅助索引的结构"><a href="#InnoDB主键索引与辅助索引的结构" class="headerlink" title="InnoDB主键索引与辅助索引的结构"></a>InnoDB主键索引与辅助索引的结构</h3><p><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为”“聚簇索引”，一个表只能有一个聚簇索引。</p><h3 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h3><p>我们知道InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff337681c17.jpg" alt=""></p><p>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启<font color=red size=3><code>innodb_file_per_table)</code></font>，切分后存放在<font color=red size=3><code>xxx.ibd</code></font>中，默认不切分，存放在<font color=red size=3><code>xxx.ibdata</code></font>中。</p><h3 id="辅助（非主键）索引："><a href="#辅助（非主键）索引：" class="headerlink" title="辅助（非主键）索引："></a>辅助（非主键）索引：</h3><p>这次我们以示例中学生表中的name列建立辅助索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是辅助索引，按照ASCII码进行排序，第二行的整数是主键的值。</p><p>这就意味着，对name列进行条件搜索，需要两个步骤：</p><p>① 在辅助索引上检索name，到达其叶子节点获取对应的主键；</p><p>② 使用主键在主索引上再进行对应的检索操作</p><p>这也就是所谓的“<strong>回表查询</strong>”</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff365f39d10.jpg" alt=""></p><p><strong>InnoDB 索引结构需要注意的点</strong></p><ol><li>数据文件本身就是索引文件</li><li>表数据文件本身就是按 B+Tree 组织的一个索引结构文件</li><li>聚集索引中叶节点包含了完整的数据记录</li><li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li></ol><p>正如我们上面介绍 InnoDB 存储结构，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p><blockquote><p>那为什么推荐使用整型自增主键而不是选择UUID？</p></blockquote><ul><li>UUID是字符串，比整型消耗更多的存储空间；</li><li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li><li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句。</li><li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li></ul><blockquote><p>为什么非主键索引结构叶子节点存储的是主键值？</p></blockquote><p>保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。</p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><ul><li><p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p><p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p><p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p></li></ul><h3 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h3><ul><li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li><li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li><li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应Btree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li></ul><h3 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h3><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p><blockquote><p>为什么Mysql索引要用B+树不是B树？</p></blockquote><p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p><blockquote><p>面试官：为何不采用Hash方式？</p></blockquote><p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p><p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p><h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li><li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li><li>查询中统计或分组字段</li></ol><h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h3><ol><li>表记录太少</li><li>经常增删改的表</li><li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li><li>频繁更新的字段不适合创建索引（会加重IO负担）</li><li>where条件里用不到的字段不创建索引</li></ol><h3 id="MySQL高效索引"><a href="#MySQL高效索引" class="headerlink" title="MySQL高效索引"></a>MySQL高效索引</h3><p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 也就是平时所说的不需要回表操作</p><ul><li><p>就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</p></li><li><p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</p></li><li><p><strong>判断标准</strong></p><p>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</p></li></ul><h2 id="五、MySQL查询"><a href="#五、MySQL查询" class="headerlink" title="五、MySQL查询"></a>五、MySQL查询</h2><hr><blockquote><p>count(*) 和 count(1)和count(列名)区别   ps：这道题说法有点多</p></blockquote><p>执行效果上：</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li><li>count(1)包括了所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul><p>执行效率上：</p><ul><li>列名为主键，count(列名)会比count(1)快</li><li>列名不为主键，count(1)会比count(列名)快</li><li>如果表多个列并且没有主键，则 count(1) 的执行效率优于 count(*)</li><li>如果有主键，则 select count（主键）的执行效率是最优的</li><li>如果表只有一个字段，则 select count(*) 最优。</li></ul><blockquote><p>MySQL中 in和 exists 的区别？</p></blockquote><ul><li>exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false</li><li>in：in查询相当于多个or条件的叠加</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">from</span> B <span class="keyword">WHERE</span> B.id = A.id);</span><br></pre></td></tr></table></figure><p><strong>如果查询的两个表大小相当，那么用in和exists差别不大</strong>。</p><p>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：</p><blockquote><p>UNION和UNION ALL的区别?</p></blockquote><p>UNION和UNION ALL都是将两个结果集合并为一个，<strong>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</strong></p><ul><li>UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；</li><li>UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；</li></ul><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><ul><li><p>手写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">JOIN</span>  &lt;right_table&gt; <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure></li><li><p>机读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM  &lt;left_table&gt;</span><br><span class="line">ON &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; JOIN  &lt;right_table&gt; </span><br><span class="line">WHERE  &lt;where_condition&gt;</span><br><span class="line">GROUP BY  &lt;group_by_list&gt;</span><br><span class="line">HAVING &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure></li><li><p>总结</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff368752ece.jpg" alt=""></p></li></ul><blockquote><p>mysql 的内连接、左连接、右连接有什么区别？什么是内连接、外连接、交叉连接、笛卡尔积呢？</p></blockquote><h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff37ac0e7f6.jpg" alt=""></p><hr><h2 id="六、MySQL-事务"><a href="#六、MySQL-事务" class="headerlink" title="六、MySQL 事务"></a>六、MySQL 事务</h2><hr><blockquote><p>事务的隔离级别有哪些？MySQL的默认隔离级别是什么？什么是幻读，脏读，不可重复读呢？MySQL事务的四大特性以及实现原理MVCC熟悉吗，它的底层原理？</p></blockquote><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><h3 id="ACID-—-事务基本要素"><a href="#ACID-—-事务基本要素" class="headerlink" title="ACID — 事务基本要素"></a>ACID — 事务基本要素</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff377ece423.jpg" alt=""></p><p>事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。</p><ul><li><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li><li><strong>C (Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</li><li><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li><li><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li></ul><p><strong>并发事务处理带来的问题</strong></p><ul><li>更新丢失（Lost Update)： 事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li><li>脏读(Dirty Reads)：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li><li>幻读（Phantom Reads)：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>幻读和不可重复读的区别：</strong></p><ul><li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li><li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li></ul><p><strong>并发事务处理带来的问题的解决办法：</strong></p><ul><li>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</li><li>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：<ul><li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 <strong>MVCC</strong> 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</li></ul></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库事务的隔离级别有4种，由低到高分别为</p><ul><li><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><p>查看当前数据库的事务隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'tx_isolation'</span></span><br></pre></td></tr></table></figure><p>下面通过事例一一阐述在事务的并发操作中可能会出现脏读，不可重复读，幻读和事务隔离级别的联系。</p><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p><h3 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h3><p>读未提交，就是一个事务可以读取另一个未提交事务的数据。</p><p>事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p><p>分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。</p><p>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p><h3 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h3><p>读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p><p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是<strong>不可重复读</strong>。</p><p>那怎么解决可能的不可重复读问题？Repeatable read ！</p><h3 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h3><p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。 <strong>MySQL的默认事务隔离级别</strong></p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p><p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，<strong>不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作</strong>。</p><p><strong>什么时候会出现幻读？</strong></p><p>事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p><p>那怎么解决幻读问题？Serializable！</p><h3 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h3><p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table><thead><tr><th>事务隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>最低级被，只能保证不读取物理上损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交（read-committed）</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<font color=red size=3><code>SELECT @@tx_isolation;</code></font>命令来查看，MySQL 8.0 该命令改为<font color=red size=3><code>SELECT @@transaction_isolation;</code></font></p><p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong>事务隔离级别下使用的是Next-Key Lock 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong>隔离级别，而且保留了比较好的并发性能。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读已提交):</strong>，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h3><p>MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。</p><p>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p><p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。</p><p>典型的MVCC实现方式，分为<strong>乐观（optimistic）并发控制和悲观（pressimistic）并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p><p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p><ul><li><p>SELECT</p><p>InnoDB会根据以下两个条件检查每行记录：</p><ul><li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li><li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li></ul><p>只有符合上述两个条件的才会被查询出来</p></li><li><p>INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p></li><li><p>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p></li><li><p>UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p></li></ul><p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p><p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。</p><p>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。</p><p>InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p><p>InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。</p><p>InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。</p><p>事务日志可以帮助提高事务效率：</p><ul><li>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li><li>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。</li><li>事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。</li><li>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li></ul><p>目前来说，大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong>（Write-Ahead Logging），修改数据需要写两次磁盘。</p><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。</p><p>事务的实现就是如何实现ACID特性。</p><p>事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。</p><blockquote><p>事务是如何通过日志来实现的，说得越深入越好。</p></blockquote><p>事务日志包括：<strong>重做日志redo</strong>和<strong>回滚日志undo</strong></p><ul><li><p><strong>redo log（重做日志</strong>） 实现持久化和原子性</p><p>在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</p><p>在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。</p></li><li><p><strong>undo log（回滚日志）</strong> 实现一致性</p><p>undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</p><p>Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</p></li></ul><p>二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p><blockquote><p>又引出个问题：你知道MySQL 有多少种日志吗？</p></blockquote><ul><li><strong>错误日志</strong>：记录出错信息，也记录一些警告信息或者正确的信息。</li><li><strong>查询日志</strong>：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li><li><strong>慢查询日志</strong>：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li><li><strong>二进制日志</strong>：记录对数据库执行更改的所有操作。</li><li><strong>中继日志</strong>：中继日志也是二进制日志，用来给slave 库恢复</li><li><strong>事务日志</strong>：重做日志redo和回滚日志undo</li></ul><blockquote><p>分布式事务相关问题，可能还会问到 2PC、3PC，，，</p></blockquote><h3 id="MySQL对分布式事务的支持"><a href="#MySQL对分布式事务的支持" class="headerlink" title="MySQL对分布式事务的支持"></a>MySQL对分布式事务的支持</h3><p>分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。</p><p>MySQL 从 5.0.3 InnoDB 存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p><p>在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff37e532a33.jpg" alt=""></p><p>如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:</p><ul><li>应用程序：定义了事务的边界，指定需要做哪些事务；</li><li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li><li>事务管理器：协调参与了全局事务中的各个事务。</li></ul><p>分布式事务采用两段式提交（two-phase commit）的方式：</p><ul><li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li><li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li></ul><h2 id="七、MySQL锁机制"><a href="#七、MySQL锁机制" class="headerlink" title="七、MySQL锁机制"></a>七、MySQL锁机制</h2><hr><blockquote><p>数据库的乐观锁和悲观锁？MySQL 中有哪几种锁，列举一下？MySQL中InnoDB引擎的行锁是怎么实现的？MySQL 间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的 sql 语句，死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁</p></blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。</p><p>打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题？这里肯定要用到事物，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。</p><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p><strong>从对数据操作的类型分类</strong>：</p><ul><li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li><li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li></ul><p><strong>从对数据操作的粒度分类</strong>：</p><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p><ul><li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li><li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li><li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><table><thead><tr><th>行锁</th><th>表锁</th><th>页锁</th><th></th></tr></thead><tbody><tr><td>MyISAM</td><td></td><td>√</td><td></td></tr><tr><td>BDB</td><td></td><td>√</td><td>√</td></tr><tr><td>InnoDB</td><td>√</td><td>√</td><td></td></tr><tr><td>Memory</td><td></td><td>√</td><td></td></tr></tbody></table><h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 的表锁有两种模式：</p><ul><li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li></ul><p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。</p><p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p><h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><p><strong>索引失效会导致行锁变表锁</strong>。比如 vchar 查询不写单引号的情况。</p><h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong></p><p>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</p><p>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></p><h3 id="锁模式-InnoDB有三种行锁的算法"><a href="#锁模式-InnoDB有三种行锁的算法" class="headerlink" title="锁模式(InnoDB有三种行锁的算法)"></a>锁模式(InnoDB有三种行锁的算法)</h3><ul><li><p><strong>记录锁(Record Locks)</strong>： 单个行记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行</p><p>在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id 列为主键列或唯一索引列</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">SET</span> age = <span class="number">50</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>间隙锁（Gap Locks）</strong>： 当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。</p><p>InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</p><p>对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</p><p>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的<font color=red size=3><code>Next-Key Locking</code></font> 算法，请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> BETWEN <span class="number">1</span> <span class="keyword">AND</span> <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>即所有在<font color=red size=3><code>（1，10）</code></font>区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</p><p>GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况</p></li><li><p><strong>临键锁(Next-key Locks)</strong>： <strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。(临键锁的主要目的，也是为了避免<strong>幻读</strong>(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。)</p><p>Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。通过<strong>临建锁</strong>可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，<code>InnoDB</code> 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p><p>对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p></li></ul><blockquote><p>select for update有什么含义，会锁表还是锁行还是其他</p></blockquote><p>for update 仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。</p><p>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 假设有个表单 products ，里面有id跟name二个栏位，id是主键。</p><ul><li>明确指定主键，并且有此笔资料，row lock</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'3'</span> <span class="keyword">and</span> <span class="keyword">type</span>=<span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><ul><li>明确指定主键，若查无此笔资料，无lock</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><ul><li>无主键，table lock</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Mouse'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><ul><li>主键不明确，table lock</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;&gt;<span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><ul><li>主键不明确，table lock</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">LIKE</span> <span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p><strong>注1</strong>: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。 <strong>注2</strong>: 要测试锁定的状况，可以利用MySQL的Command Mode ，开二个视窗来做测试。</p><blockquote><p>MySQL 遇到过死锁问题吗，你是如何解决的？</p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生</strong>：</p><ul><li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li><li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li><li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li></ul><p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p><p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p><p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p><p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖<code>innodb_lock_wait_timeout</code>设置进行事务回滚。</p><p><strong>MyISAM避免死锁</strong>：</p><ul><li>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</li></ul><p><strong>InnoDB避免死锁</strong>：</p><ul><li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用<code>SELECT ... FOR UPDATE</code>语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li><li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li><li>通过<font color=red size=3><code>SELECT ... LOCK IN SHARE MODE</code></font>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li><li>改变事务隔离级别</li></ul><p>如果出现死锁，可以用 <font color=red size=3><code>show engine innodb status;</code></font>命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p><hr><h2 id="八、MySQL调优"><a href="#八、MySQL调优" class="headerlink" title="八、MySQL调优"></a>八、MySQL调优</h2><hr><blockquote><p>日常工作中你是怎么优化SQL的？SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？如何写sql能够有效的使用到复合索引？一条sql执行过长的时间，你如何优化，从哪些方面入手？什么是最左前缀原则？什么是最左匹配原则？</p></blockquote><h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a>影响mysql的性能因素</h3><ul><li>业务需求对MySQL的影响(合适合度)</li><li>存储定位对MySQL的影响<ul><li>不适合放进MySQL的数据<ul><li>二进制多媒体数据</li><li>流水队列数据</li><li>超大文本数据</li></ul></li><li>需要放进缓存的数据<ul><li>系统各种配置及规则数据</li><li>活跃用户的基本信息数据</li><li>活跃用户的个性化定制信息数据</li><li>准实时的统计信息数据</li><li>其他一些访问频繁但变更较少的数据</li></ul></li></ul></li><li>Schema设计对系统的性能影响<ul><li>尽量减少对数据库访问的请求</li><li>尽量减少无用数据的查询请求</li></ul></li><li>硬件环境对系统性能的影响</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h3 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h3><ol><li>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）</li><li>当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimize r时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。</li></ol><h3 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h3><ul><li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li><li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li><li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li></ul><h3 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h3><ul><li>查询语句写的烂</li><li>索引失效（单值、复合）</li><li>关联查询太多join（设计缺陷或不得已的需求）</li><li>服务器调优及各个参数设置（缓冲、线程数等）</li></ul><h3 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a>MySQL常见性能分析手段</h3><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p><h3 id="性能瓶颈定位"><a href="#性能瓶颈定位" class="headerlink" title="性能瓶颈定位"></a>性能瓶颈定位</h3><p>我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Mysql&gt; show status ——显示状态信息（扩展show status like ‘XXX’）</span><br><span class="line"></span><br><span class="line">Mysql&gt; show variables ——显示系统变量（扩展show variables like ‘XXX’）</span><br><span class="line"></span><br><span class="line">Mysql&gt; show innodb status ——显示InnoDB存储引擎的状态</span><br><span class="line"></span><br><span class="line">Mysql&gt; show processlist ——查看当前SQL执行，包括执行状态、是否锁表等</span><br><span class="line"></span><br><span class="line">Shell&gt; mysqladmin variables -u username -p password——显示系统变量</span><br><span class="line"></span><br><span class="line">Shell&gt; mysqladmin extended-status -u username -p password——显示状态信息</span><br></pre></td></tr></table></figure><h3 id="Explain-执行计划"><a href="#Explain-执行计划" class="headerlink" title="Explain(执行计划)"></a>Explain(执行计划)</h3><p>是什么：使用 <strong>Explain</strong> 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈</p><p>能干吗：</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p>怎么玩：</p><ul><li>Explain + SQL语句</li><li>执行计划包含的信息（如果有分区表的话还会有<strong>partitions</strong>）</li></ul><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff38d5d8333.jpg" alt=""></p><p>各字段解释</p><ul><li><p><strong>id</strong>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）</p><ul><li>id相同，执行顺序从上往下</li><li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li></ul></li><li><p><strong>select_type</strong>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</p><ul><li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION</li><li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li><li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li><li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li><li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li><li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li></ul></li><li><p><strong>table</strong>（显示这一行的数据是关于哪张表的）</p></li><li><p><strong>type</strong>（显示查询使用了那种类型，从最好到最差依次排列    <strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> ）</p><ul><li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现</li><li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li><li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li><li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li><li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li><li>ALL：Full Table Scan，将遍历全表找到匹配的行</li></ul><p>tip: 一般来说，得保证查询至少达到range级别，最好到达ref</p></li><li><p><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</p></li><li><p><strong>key</strong></p><ul><li>实际使用的索引，如果为NULL，则没有使用索引</li><li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li></ul></li></ul><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff38f6a6955.jpg" alt=""></p><ul><li><p>key_len</p><ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</li><li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li></ul></li><li><p><strong>ref</strong> （显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</p></li><li><p><strong>rows</strong> （根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</p></li><li><p>Extra</p><p>（包含不适合在其他列中显示但十分重要的额外信息）</p><ol><li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中</li><li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li><li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li><li>using where：使用了where过滤</li><li>using join buffer：使用了连接缓存</li><li>impossible where：where子句的值总是false，不能用来获取任何元祖</li><li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li><li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li></ol></li></ul><p><strong>case</strong>:</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff39882383d.jpg" alt=""></p><ol><li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select <a href="http://d1.name" target="_blank" rel="noopener">d1.name</a>……】</li><li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column=’’】</li><li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li><li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li><li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li></ol><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <font color=red size=3><code>long_query_time</code></font> 值的 SQL，则会被记录到慢查询日志中。</p><ul><li><font color=red size=3><code>long_query_time</code></font>  的默认值为10，意思是运行10秒以上的语句</li><li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启</li></ul><p><strong>查看开启状态</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%slow_query_log%'</span></span><br></pre></td></tr></table></figure><p><strong>开启慢查询日志</strong></p><ul><li>临时配置：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log='ON';</span><br><span class="line">mysql&gt; set global slow_query_log_file='/var/lib/mysql/hostname-slow.log';</span><br><span class="line">mysql&gt; set global long_query_time=2;</span><br><span class="line">也可<span class="keyword">set</span>文件位置，系统会默认给一个缺省文件host_name-slow.log</span><br><span class="line"></span><br><span class="line">使用<span class="keyword">set</span>操作开启慢查询日志只对当前数据库生效，如果MySQL重启则会失效。</span><br></pre></td></tr></table></figure><ul><li><p>永久配置</p><p>修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = ON</span><br><span class="line">slow_query_log_file = /var/lib/mysql/hostname-slow.log</span><br><span class="line">long_query_time = 3</span><br></pre></td></tr></table></figure><p>注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time=2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。</p><p>可以用 <font color=red size=3><code>select sleep(4)</code></font> 验证是否成功开启。</p><p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p><p>通过 mysqldumpslow –help 查看操作帮助信息</p><ul><li><p>得到返回记录集最多的10个SQL</p><p><font color=red size=3><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log</code></font></p></li><li><p>得到访问次数最多的10个SQL</p><p><font color=red size=3><code>mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log</code></font></p></li><li><p>得到按照时间排序的前10条里面含有左连接的查询语句</p><p><font color=red size=3><code>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/hostname-slow.log</code></font></p></li><li><p>也可以和管道配合使用</p><p><font color=red size=3><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more</code></font></p></li></ul><p><strong>也可使用 pt-query-digest 分析 RDS MySQL 慢查询日志</strong></p><h3 id="Show-Profile-分析查询"><a href="#Show-Profile-分析查询" class="headerlink" title="Show Profile 分析查询"></a>Show Profile 分析查询</h3><p>通过慢日志查询可以知道哪些 SQL 语句执行效率低下，通过 explain 我们可以得知 SQL 语句的具体执行情况，索引使用等，还可以结合<font color=red size=3><code>Show Profile</code></font>命令查看执行状态。</p><ul><li><p>Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p></li><li><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p></li><li><p>分析步骤</p><ul><li><p>是否支持，看看当前的mysql版本是否支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;Show  variables like &#39;profiling&#39;;  --默认是关闭，使用前需要开启</span><br></pre></td></tr></table></figure></li><li><p>开启功能，默认是关闭，使用前需要开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;set profiling&#x3D;1;</span><br></pre></td></tr></table></figure></li><li><p>运行SQL</p></li><li><p>查看结果</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------+</span></span><br><span class="line">| Query_ID | Duration | Query |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------+</span></span><br><span class="line">| 1 | 0.00385450 | <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"profiling"</span> |</span><br><span class="line">| <span class="number">2</span> | <span class="number">0.00170050</span> | <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"profiling"</span> |</span><br><span class="line">| <span class="number">3</span> | <span class="number">0.00038025</span> | <span class="keyword">select</span> * <span class="keyword">from</span> t_base_user |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------+</span></span><br></pre></td></tr></table></figure><ul><li>诊断SQL，show profile cpu,block io for query id(上一步前面的问题SQL数字号码)</li><li>日常开发需要注意的结论<ul><li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</li><li>create tmp table 创建临时表，这个要注意</li><li>Copying to tmp table on disk 把内存临时表复制到磁盘</li><li>locked</li></ul></li></ul></li></ul><blockquote><p>查询中哪些情况不会使用索引？</p></blockquote><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ol><li>全值匹配我最爱</li><li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li><li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li><li>is null ,is not null 也无法使用索引</li><li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li><li>字符串不加单引号索引失效</li><li>少用or，用它来连接时会索引失效</li><li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li></ol><p><strong>一般性建议</strong></p><ul><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li><li>少用Hint强制索引</li></ul><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p><strong>永远小标驱动大表（小的数据集驱动大的数据集）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slect * from A where id in (select id from B)`等价于</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> A.id=B.id</span><br></pre></td></tr></table></figure><p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id<span class="string">`</span></span><br></pre></td></tr></table></figure><p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p><p>注意：A表与B表的ID字段应建立索引。</p><p><strong>order by关键字优化</strong></p><ul><li>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</li><li>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</li><li>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</li><li>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</li><li>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序<ul><li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</li><li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li></ul></li><li>优化策略<ul><li>增大sort_buffer_size参数的设置</li><li>增大max_lencth_for_sort_data参数的设置</li></ul></li></ul><p><strong>GROUP BY关键字优化</strong></p><ul><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了</li></ul><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p><ul><li><p>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p><p>简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</p></li><li><p>尽量避免NULL：通常情况下最好指定列为NOT NULL</p></li></ul><hr><h2 id="九、分区、分表、分库"><a href="#九、分区、分表、分库" class="headerlink" title="九、分区、分表、分库"></a>九、分区、分表、分库</h2><hr><h3 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h3><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p><p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率</p><p><strong>能干嘛</strong></p><ul><li>逻辑数据分割</li><li>提高单一的写和读应用速度</li><li>提高分区范围读查询的速度</li><li>分割数据能够有多个不同的物理文件路径</li><li>高效的保存历史数据</li></ul><p><strong>怎么玩</strong></p><p>首先查看当前数据库是否支持分区</p><ul><li><p>MySQL5.6以及之前版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;%partition%&#39;;</span><br></pre></td></tr></table></figure></li><li><p>MySQL5.6：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show plugins;</span><br></pre></td></tr></table></figure></li></ul><p><strong>分区类型及操作</strong></p><ul><li><p><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。</p><p>按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。</p><p>range 来分，好处在于说，扩容的时候很简单。</p></li><li><p><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</p></li><li><p><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。</p><p>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</p></li><li><p><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</p></li></ul><p><strong>看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？</strong></p><ul><li>分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁</li><li>一旦数据并发量上来，如果在分区表实施关联，就是一个灾难</li><li>自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控</li></ul><blockquote><p>随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办？</p></blockquote><p>这个时候就出现了<strong>数据分片</strong>，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。</p><p>区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。</p><blockquote><p>说说分库与分表的设计</p></blockquote><h3 id="MySQL分表"><a href="#MySQL分表" class="headerlink" title="MySQL分表"></a>MySQL分表</h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p><ul><li><p><strong>垂直拆分</strong></p><p>垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p></li><li><p><strong>水平拆分(数据分片)</strong></p><p>单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。</p><p>水平分割的几种方法：</p><ul><li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</li><li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li><li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li><li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li></ul></li></ul><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff39ffffdd1.jpg" alt=""></p><h3 id="MySQL分库"><a href="#MySQL分库" class="headerlink" title="MySQL分库"></a>MySQL分库</h3><blockquote><p>为什么要分库?</p></blockquote><p>数据库集群环境后都是多台 slave，基本满足了读取操作; 但是写入或者说大数据、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。</p><blockquote><p>分库是什么？</p></blockquote><p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</p><p>优点：</p><ul><li>减少增量数据写入时的锁对查询的影响</li><li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li></ul><p>但是它无法解决单表数据量太大的问题</p><p><strong>分库分表后的难题</strong></p><p>分布式事务的问题，数据的完整性和一致性问题。</p><p>数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。 跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。</p><blockquote><p>配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道</p></blockquote><h2 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h2><hr><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><ul><li><p>slave 会从 master 读取 binlog 来进行数据同步</p></li><li><p>三个步骤</p><ol><li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li><li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li><li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li></ol><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff3c7c7b231.jpg" alt=""></p></li></ul><h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul><li>每个 slave只有一个 master</li><li>每个 salve只能有一个唯一的服务器 ID</li><li>每个master可以有多个salve</li></ul><h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><ul><li>延时</li></ul><hr><h2 id="十一、其他问题"><a href="#十一、其他问题" class="headerlink" title="十一、其他问题"></a>十一、其他问题</h2><hr><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul><li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li><li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li><li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y</li></ul><h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h2 id="参考与感谢："><a href="#参考与感谢：" class="headerlink" title="参考与感谢："></a>参考与感谢：</h2><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/29150809</a></p><p><a href="https://juejin.im/post/5e3eb616f265da570d734dcb#heading-105" target="_blank" rel="noopener">juejin.im/post/5e3eb6…</a></p><p><a href="https://blog.csdn.net/yin767833376/article/details/81511377" target="_blank" rel="noopener">blog.csdn.net/yin76783337…</a></p>]]></content>
    
    <summary type="html">
    
      和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数...
    
    </summary>
    
    
      <category term="直击面试" scheme="http://yoursite.com/categories/%E7%9B%B4%E5%87%BB%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>[「直击面试」搞定计算机网络]</title>
    <link href="http://yoursite.com/2020/06/22/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/06/22/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2020-06-21T23:45:33.000Z</published>
    <updated>2020-06-21T23:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在浏览器中输入一个 URL 至页面呈现，网络上都发生了什么事？</p><p>能说说 ISO 七层模型和 TCP/IP 四层模型吗？</p><p>TCP/IP 与 HTTP 有什么关系吗？</p><p>TCP协议与UDP协议的区别？</p><p>请详细介绍一下 TCP 的三次握手机制，为什么要三次握手？挥手却又是四次呢？</p><p>详细讲一下TCP的滑动窗口？知道流量控制和拥塞控制吗？</p><p>说一下对称加密与非对称加密？</p><p>状态码 206 是什么意思？</p><p>你们用的 https 是吧，https 工作原理是什么？</p><p>……</p></blockquote><blockquote><p>成长手册，<strong>GitHub</strong> <a href="https://github.com/rogerXS80/roger" target="_blank" rel="noopener">Lupinus</a> ，N线互联网开发必备技能兵器谱</p></blockquote><h2 id="一、计算机网络"><a href="#一、计算机网络" class="headerlink" title="一、计算机网络"></a>一、计算机网络</h2><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>通信协议（communications protocol）是指双方实体完成通信或服务所必须遵循的规则和约定。通过通信信道和设备互连起来的多个不同地理位置的数据通信系统，要使其能协同工作实现信息交换和资源共享，它们之间必须具有共同的语言。交流什么、怎样交流及何时交流，都必须遵循某种互相都能接受的规则。这个规则就是通信协议。</p><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>随着技术的发展，计算机的应用越来越广泛，计算机之间的通信开始了百花齐放的状态，每个具有独立计算服务体系的信息技术公司都会建立自己的计算机通信规则，而这种情况会导致异构计算机之间无法通信，极大的阻碍了网络通信的发展，至此为了解决这个问题，国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，OSI模型把网络通信的工作分为7层，分别是<strong>物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</strong>。</p><p>这七层模型是设计层面的概念，每一层都有固定要完成的职责和功能，分层的好处在于清晰和功能独立性，但分层过多会使层次变的更加复杂，虽然不需要实现本层的功能，但是也需要构造本层的上下文，空耗系统资源，所以在落地实施网络通信模型的时候将这七层模型简化合并为四层模型分别是<strong>应用层、传输层、网络层、网络接口层</strong>（各层之间的模型、协议统称为：<strong>TCP/IP协议簇</strong>）。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed7719799d.jpg" alt=""></p><p>从上图可以看到，TCP/IP模型合并了OSI模型的应用层、表示层和会话层，将OSI模型的数据链路层和物理层合并为网络访问层。</p><p>上图还列出了各层模型对应TCP/IP协议栈中的协议以及各层协议之间的关系。比如DNS协议是建立在TCP和UDP协议的基础上，FTP、HTTP、TELNET协议建立在TCP协议的基础上，NTP、TFTP、SNMP建立在UDP协议的基础上，而TCP、UDP协议又建立在IP协议的基础上，以此类推….</p><table><thead><tr><th align="left">OSI中的层</th><th>功能</th><th align="left">TCP/IP协议族</th></tr></thead><tbody><tr><td align="left"><strong>应用层</strong></td><td>文件传输，电子邮件，文件服务，虚拟终端</td><td align="left">TFTP，HTTP，SNMP，FTP，SMTP，DNS，RIP，Telnet</td></tr><tr><td align="left"><strong>表示层</strong></td><td>数据格式化，代码转换，数据加密</td><td align="left">无</td></tr><tr><td align="left"><strong>会话层</strong></td><td>控制应用程序之间会话能力；如不同软件数据分发给不同软件</td><td align="left">ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets</td></tr><tr><td align="left"><strong>传输层</strong></td><td>端到端传输数据的基本功能</td><td align="left">TCP、UDP</td></tr><tr><td align="left"><strong>网络层</strong></td><td>定义IP编址，定义路由功能；如不同设备的数据转发</td><td align="left">IP，ICMP，RIP，OSPF，BGP，IGMP</td></tr><tr><td align="left"><strong>数据链路层</strong></td><td>定义数据的基本格式，如何传输，如何标识</td><td align="left">SLIP，CSLIP，PPP，ARP，RARP，MTU</td></tr><tr><td align="left"><strong>物理层</strong></td><td>以<strong>二进制</strong>数据形式在物理媒体上传输数据</td><td align="left">ISO2110，IEEE802</td></tr></tbody></table><p>当我们某一个网站上不去的时候。通常会ping一下这个网站</p><p><code>ping</code> 可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用<code>ping</code>命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p><h2 id="二、TCP-IP"><a href="#二、TCP-IP" class="headerlink" title="二、TCP/IP"></a>二、TCP/IP</h2><p>数据在网络中传输最终一定是通过物理介质传输。物理介质就是把电脑连接起来的物理手段，常见的有光纤、双绞线，以及无线电波，它决定了电信号(0和1)的传输方式，物理介质的不同决定了电信号的传输带宽、速率、传输距离以及抗干扰性等等。网络数据传输就像快递邮寄，数据就是快件。只有路打通了，你的”快递”才能送到，因此物理介质是网络通信的基石。</p><p>寄快递首先得称重、确认体积(确认数据大小)，贵重物品还得层层包裹填充物确保安全，封装，然后填写发件地址(源主机地址)和收件地址(目标主机地址)，确认快递方式。对于偏远地区，快递不能直达，还需要中途转发。网络通信也是一样的道理，只不过把这些步骤都规定成了各种协议。</p><p>TCP/IP的模型的每一层都需要下一层所提供的协议来完成自己的目的。我们来看下数据是怎么通过TCP/IP协议模型从一台主机发送到另一台主机的。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed76faefb0.jpg" alt=""></p><p>当用户通过HTTP协议发起一个请求，应用层、传输层、网络互联层和网络访问层的相关协议依次对该请求进行包装并携带对应的首部，最终在网络访问层生成以太网数据包，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。</p><h3 id="TCP-IP-与-HTTP"><a href="#TCP-IP-与-HTTP" class="headerlink" title="TCP/IP 与 HTTP"></a>TCP/IP 与 HTTP</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP 协议不仅仅指的是 TCP 和 IP 两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。</p><p><strong>而HTTP是应用层协议，主要解决如何包装数据。</strong></p><p>“IP”代表网际协议，TCP 和 UDP 使用该协议从一个网络传送数据包到另一个网络。把<strong>IP想像成一种高速公路</strong>，它允许其它协议在上面行驶并找到到其它电脑的出口。<strong>TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP</strong>，文件传输协议FTP这样的协议等。</p><h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><p>都属于传输层协议。</p><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须有三次握手、四次挥手。</p><p>UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上</p><table><thead><tr><th align="left"></th><th align="left">TCP</th><th align="left">UDP</th></tr></thead><tbody><tr><td align="left">连接性</td><td align="left">面向连接</td><td align="left">面向非连接</td></tr><tr><td align="left">传输可靠性</td><td align="left">可靠</td><td align="left">不可靠</td></tr><tr><td align="left">报文</td><td align="left">面向字节流</td><td align="left">面向报文</td></tr><tr><td align="left">效率</td><td align="left">传输效率低</td><td align="left">传输效率高</td></tr><tr><td align="left">流量控制</td><td align="left">滑动窗口</td><td align="left">无</td></tr><tr><td align="left">拥塞控制</td><td align="left">慢开始、拥塞避免、快重传、快恢复</td><td align="left">无</td></tr><tr><td align="left">传输速度</td><td align="left">慢</td><td align="left">快</td></tr><tr><td align="left">应用场合</td><td align="left">对效率要求低，对准确性要求高或要求有连接的场景</td><td align="left">对效率要求高，对准确性要求低</td></tr></tbody></table><p>TCP和UDP协议的一些应用</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed76fa926f.jpg" alt=""></p><h3 id="TCP连接的建立与终止"><a href="#TCP连接的建立与终止" class="headerlink" title="TCP连接的建立与终止"></a>TCP连接的建立与终止</h3><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能体现在它首部中的各字段的作用。</p><p>TCP报文段首部的前20个字节是固定的（下图），后面有4n字节是根据需要而增加的选项（n是整数）。因此TCP首部的最小长度是20字节。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed764405fc.jpg" alt=""></p><h4 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h4><ul><li><p>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</p></li><li><p><strong>序列号</strong>（Sequence number），占4字节。序号范围是【0，2^32 - 1】，共2^32个序号。序号增加到 2^32-1后，下一个序号就又回到 0。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是301，而接待的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”;</p></li><li><p><strong>确认号</strong>（Acknowledge number），占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</p></li><li><p>数据偏移，占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。</p></li><li><p>保留，占6位，保留为今后使用，但目前应置为0；</p></li><li><p>紧急URG（URGent），当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</p></li><li><p>确认ACK（ACKnowledgment），仅当ACK=1时，确认号字段才有效。<strong>TCP规定，在连接建立后所有报文的传输都必须把ACK置1</strong>；</p></li><li><p>推送PSH（PuSH） ，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</p></li><li><p>复位RST（ReSeT），当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</p></li><li><p>同步SYN（SYNchronization），在连接建立时用来同步序号。<strong>当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1</strong>；</p></li><li><p>终止FIN（FINis），用来释放连接。</p><p>当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放</p><p>；</p><ul><li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li></ul></li><li><p>检验和，占2字节，校验首部和数据这两部分；</p></li><li><p>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</p></li><li><p>选项，长度可变，定义一些其他的可选的参数</p></li></ul><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/16/17180bed7721f0c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><p><strong>第一次握手</strong>(SYN=1, seq=x)</p><p>建立连接。客户端发送连接请求报文段，这是报文首部中的同步位SYN=1，同时选择一个初始序列号 seq=x ，此时，客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号；</p></li><li><p><strong>第二次握手</strong>(SYN=1, ACK=1, seq=y, ACKnum=x+1)</p><p>服务器收到客户端的SYN报文段，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号ACKnum=x+1，同时，自己还要发送SYN请求信息，SYN=1，为自己初始化一个序列号 seq=y，服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号</p></li><li><p><strong>第三次握手</strong>(ACK=1，ACKnum=y+1)</p><p>客户端收到服务器的SYN+ACK报文段，再次发送确认包(ACK)，<strong>SYN 标志位为0</strong>，ACK 标志位为1，确认号 ACKnum = y+1，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED（已建立连接）状态，完成TCP三次握手。</p></li></ul><blockquote><p>为什么需要三次握手呢？两次不行吗？</p></blockquote><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。<strong>客户端或服务器均可主动发起挥手动作</strong>。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed772ce689.jpg" alt=""></p><ul><li><p>第一次挥手(FIN=1，seq=x)red</p><p>主机1（可以使客户端，也可以是服务器端），设置seq=x，向主机2发送一个FIN报文段；此时，主机1进入<font color=red size=4><code>FIN_WAIT_1</code></font>状态；这表示主机1没有数据要发送给主机2了；</p></li><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknnum=x+1，主机1进入<font color=red size=4><code>FIN_WAIT_2</code></font>状态；主机2告诉主机1，我“同意”你的关闭请求；</p></li><li><p>第三次挥手(FIN=1，seq=y)</p><p>主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入<code>LAST_ACK</code> 状态</p></li><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入<font color=red size=4><code>TIME_WAIT</code></font>状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，<strong>主机1等待2MSL后依然没有收到回复</strong>，则证明Server端已正常关闭，那好，主机1也可以关闭连接了，进入 <font color=red size=4><code>CLOSED</code></font> 状态。</p><p>主机 1 等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <font color=red size=4><code>CLOSED</code></font>  状态。</p></li></ul><blockquote><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p></blockquote><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。</p><blockquote><p><strong>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p></blockquote><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><p>还有一个原因，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h3 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h3><p>对于可靠性，TCP通过以下方式进行保证：</p><ul><li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li><li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li><li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li><li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li><li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ul><blockquote><p>详细讲一下TCP的滑动窗口</p></blockquote><h3 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h3><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓<strong>流量控制</strong>就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9bb2cb0c.jpg" alt=""></p><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p><p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方，我们现在假设一个发送方向接收方发送数据的场景来讲解流量控制。首先我们的接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p><p>假设应用程序最后读走的数据序号是 lastByteRead，接收缓存中接收到的最后一个数据序号是 lastByteRcv，接收缓存的大小为 RcvSize，那么必须要满足 lastByteRcv - lastByteRead &lt;= RcvSize 才能保证接收缓存不会溢出，所以我们定义流量窗口为接收缓存剩余的空间，也就是Rcv = RcvSize - (lastByteRcv - lastByteRead)。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时/三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p><h3 id="TCP的拥塞处理"><a href="#TCP的拥塞处理" class="headerlink" title="TCP的拥塞处理"></a>TCP的拥塞处理</h3><p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：</p><ol><li>慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</li><li>拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。          </li><li>快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。         </li><li>快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</li></ol><h3 id="服务器出现了大量CLOSE-WAIT状态如何解决"><a href="#服务器出现了大量CLOSE-WAIT状态如何解决" class="headerlink" title="服务器出现了大量CLOSE_WAIT状态如何解决"></a>服务器出现了大量CLOSE_WAIT状态如何解决</h3><p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。</p><h3 id="讲一讲SYN超时，洪泛攻击，以及解决策略"><a href="#讲一讲SYN超时，洪泛攻击，以及解决策略" class="headerlink" title="讲一讲SYN超时，洪泛攻击，以及解决策略"></a>讲一讲SYN超时，洪泛攻击，以及解决策略</h3><p>什么 SYN 是洪泛攻击？ 在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。服务器接收到 SYN 报文段后会为该TCP分配缓存和变量，如果攻击分子大量地往服务器发送 SYN 报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。</p><p>解决策略： 当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源Id，目的Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源Id，目的Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源</p><p>这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。</p><h2 id="三、HTTP"><a href="#三、HTTP" class="headerlink" title="三、HTTP"></a>三、HTTP</h2><blockquote><p>HTTP1.0、HTTP1.1、HTTP2.0 的区别</p><p>post 和 get 的区别</p></blockquote><p>HTTP全称是 HyperText Transfer Protocal，即：超文本传输协议。是互联网上应用最为广泛的一种<strong>网络通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。目前我们使用的是<strong>HTTP/1.1 版本</strong>。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext），这成为了HTTP超文本传输协议标准架构的发展根基。</p><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><p>每个Web 服务器资源都有一个名字，这样客户端就可以说明他们感兴趣的资源是什么了，服务器资源名被称为统一资源标识符（Uniform Resource Identifier,URI）。URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源。</p><p>统一资源定位符（URL）是资源标识符最常见的形式。 URL 描述了一台特定服务器上某资源的特定位置。</p><p>现在几乎所有的 URI 都是 URL。</p><p>URI 的第二种形式就是统一资源名（URN）。URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。 </p><h3 id="HTTP消息的结构"><a href="#HTTP消息的结构" class="headerlink" title="HTTP消息的结构"></a>HTTP消息的结构</h3><p><strong>事务和报文</strong></p><p>客户端是怎样通过HTTP与Web服务器及其资源进行事务处理的呢？一个<strong>HTTP事务</strong>由一条请求命令（从客户端发往服务器）和一个响应（从服务器发回客户端）结果组成。这种通信是通过名为<strong>HTTP报文</strong>（HTTP Message）的格式化数据块进行的。</p><h4 id="HTTP事务："><a href="#HTTP事务：" class="headerlink" title="HTTP事务："></a>HTTP事务：</h4><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9d208228.jpg" alt=""></p><h4 id="报文："><a href="#报文：" class="headerlink" title="报文："></a>报文：</h4><p>HTTP 报文是纯文本，不是二进制代码。从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180beda8938bd4.jpg" alt=""></p><p>HTTP 报文包括三部分：</p><ul><li>起始行</li><li>首部字段</li><li>主体</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是<strong>GET,POST,PUT,DELETE</strong>. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</p><ul><li>GET</li><li>HEAD</li><li>PUT</li><li>POST</li><li>TRACE</li><li>OPTIONS</li><li>DELETE</li></ul><h3 id="Get与POST的区别"><a href="#Get与POST的区别" class="headerlink" title="Get与POST的区别"></a>Get与POST的区别</h3><p>GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：</p><ol><li>从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</li><li>从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</li><li>从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。</li><li>就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。</li><li>从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</li></ol><p>HTTP请求结构： 请求方式 + 请求URI + 协议及其版本</p><p>HTTP响应结构： 状态码 + 原因短语 + 协议及其版本</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>每条HTTP响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是都需要采取其他动作。</p><ul><li>1xx：表明服务端接收了客户端请求，客户端继续发送请求；</li><li>2xx：客户端发送的请求被服务端成功接收并成功进行了处理；</li><li>3xx：服务端给客户端返回用于重定向的信息；</li><li>4xx：客户端的请求有非法内容；</li><li>5xx：服务端未能正常处理客户端的请求而出现意外错误。</li><li><strong>200 OK</strong>：表示从客户端发送给服务器的请求被正常处理并返回；</li><li><strong>204 No Content</strong>：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）</li><li><strong>206 Patial Content</strong>：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。</li><li><strong>301 Moved Permanently</strong>：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；</li><li><strong>302 Found</strong>：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；</li><li><strong>303 See Other</strong>：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源</li><li>304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；</li><li><strong>400 Bad Request</strong>:表示请求报文中存在语法错误；</li><li><strong>401 Unauthorized</strong>：经许可，需要通过HTTP认证；</li><li><strong>403 Forbidden</strong>：服务器拒绝该次访问（访问权限出现问题）</li><li><strong>404 Not Found</strong>：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</li><li><strong>500 Inter Server Error</strong>：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</li><li><strong>503 Server Unavailable</strong>：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</li></ul><p>HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节，而是把这些细节都交给了通用可靠的因特网传输协议 TCP/IP。</p><p>在 HTTP 客户端向服务器发送报文之前，需要用网络协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条 TCP/IP 协议。而 IP 地址就是通过 URL 提供的，像<font color=red size=4><code>http://207.200.21.11:80/index.html</code></font> ，还有使用域名服务（Domain Name Services，DNS）的 <font color=red size=4><code>http://www.lazyegg.net</code></font>。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9f762409.jpg" alt=""></p><h3 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h3><ul><li><p><strong>HTTP/0.9</strong></p><p>HTTP协议的最初版本，功能简陋，仅支持 GET 方法，并且仅能请求访问 HTML 格式的资源</p></li><li><p><strong>HTTP/1.0</strong></p><ul><li>增加了请求方式 POST 和 HEAD</li><li>不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等</li><li>同时也开始支持 cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可</li><li>HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等</li><li>但是1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive</li></ul></li><li><p><strong>HTTP/1.0+</strong></p><p>在20世纪90年代中叶，为满足飞快发展的万维网，很多流行的 Web 客户端和服务器飞快的向 HTTP 中添加各种特性，包括持久的 keep-alive 连接、虚拟主机支持，以及代理连接支持都被假如到 HTTP 中，并称为非官方的事实标准。这种非正式的 HTTP 扩展版本通常称为 HTTP/1.0+</p></li><li><p><strong>HTTP/1.1</strong></p><ul><li>http1.1是目前最为主流的http协议版本，从1997年发布至今，仍是主流的http协议版本。</li><li>引入了持久连接，或叫长连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</li><li>引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。</li><li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</li><li>http协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度。</li></ul></li><li><p><strong>HTTP/2.0（又名 HTTP-NG）</strong></p><ul><li>http/2发布于2015年，目前应用还比较少。</li><li>http/2是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</li><li>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了队头堵塞的问题,此双向的实时通信称为多工（ Multiplexing）。</li><li>HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li><li>引入头信息压缩机制（ header compression） ,头信息使用gzip或compress压缩后再发送。</li></ul></li></ul><h2 id="四、HTTPS"><a href="#四、HTTPS" class="headerlink" title="四、HTTPS"></a>四、HTTPS</h2><p>HTTP缺点：</p><ol><li>通信使用明文不对数据进行加密（内容容易被窃听）</li><li>不验证通信方身份（容易伪装）</li><li>无法确定报文完整性（内容易被篡改）</li></ol><p>因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL（安全套接层）协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p><strong>与 SSL（安全套接层）组合使用的 HTTP 就是 HTTPS</strong></p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedb27f3f29.jpg" alt=""></p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedb8848bf2.jpg" alt=""></p><h3 id="HTTP和HTTPS对比"><a href="#HTTP和HTTPS对比" class="headerlink" title="HTTP和HTTPS对比"></a>HTTP和HTTPS对比</h3><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><p>主要的加密方法分为两种：一种是共享密钥加密（对称密钥加密），一种是公开密钥加密（非对称密钥加密）</p><h4 id="共享密钥加密-对称秘钥加密"><a href="#共享密钥加密-对称秘钥加密" class="headerlink" title="共享密钥加密(对称秘钥加密)"></a>共享密钥加密(对称秘钥加密)</h4><p>加密与解密使用同一个密钥，常见的对称加密算法：DES，AES，3DES等。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedbd853fe2.jpg" alt=""></p><p>也就是说在加密的同时，也会把密钥发送给对方。在发送密钥过程中可能会造成密钥被窃取，那么如何解决这一问题呢？</p><h4 id="公开密钥（非对称密钥）"><a href="#公开密钥（非对称密钥）" class="headerlink" title="公开密钥（非对称密钥）"></a>公开密钥（非对称密钥）</h4><p>公开密钥使用一对非对称密钥。一把叫私有密钥，另一把叫公开密钥。私有密钥不让任何人知道，公有密钥随意发送。公钥加密的信息，只有私钥才能解密。常见的非对称加密算法：RSA，ECC等。</p><p>也就是说，发送密文方使用对方的公开密钥进行加密，对方接受到信息后，使用私有密钥进行解密。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bede10f9420.jpg" alt=""></p><p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。</p><p>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。</p><p>为了解决这一问题，https采用对称加密与非对称加密的混合加密方式。</p><h3 id="SSL-TSL"><a href="#SSL-TSL" class="headerlink" title="SSL/TSL"></a>SSL/TSL</h3><p>SSL（Secure Sockets Layer），中文叫做“安全套接层”。它是在上世纪90年代中期，由网景公司设计的。</p><p>SSL 协议就是用来解决 HTTP 传输过程的不安全问题，到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。</p><p>很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。</p><p>SSL/TLS协议的基本思路是采用<a href="http://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有两个问题。</p><ul><li><p><strong>如何保证公钥不被篡改？</strong></p><p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p></li><li><p><strong>公钥加密计算量太大，如何减少耗用的时间？</strong></p><p>每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p></li></ul><p>因此，SSL/TLS协议的基本过程是这样的：</p><ol><li>服务端将非对称加密的公钥发送给客户端；</li><li>客户端拿着服务端发来的公钥，对对称加密的key做加密并发给服务端；</li><li>服务端拿着自己的私钥对发来的密文解密，从来获取到对称加密的key；</li><li>二者利用对称加密的key对需要传输的消息做加解密传输。</li></ol><p>HTTPS相比HTTP，在请求前多了一个「握手」的环节。</p><p>握手过程中确定了数据加密的密码。在握手过程中，网站会向浏览器发送 SSL 证书，SSL 证书和我们日常用的身份证类似，是一个支持 HTTPS 网站的身份证明，SSL 证书里面包含了网站的域名，证书有效期，证书的颁发机构以及用于加密传输密码的公钥等信息，由于公钥加密的密码只能被在申请证书时生成的私钥解密，因此浏览器在生成密码之前需要先核对当前访问的域名与证书上绑定的域名是否一致，同时还要对证书的颁发机构进行验证，如果验证失败浏览器会给出证书错误的提示。</p><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedc063a776.jpg" alt=""></p><p>实际上，我们使用的证书分很多种类型，SSL证书只是其中的一种。证书的格式是由 X.509 标准定义。SSL 证书负责传输公钥，是一种PKI（Public Key Infrastructure，公钥基础结构）证书。</p><p>我们常见的证书根据用途不同大致有以下几种：</p><ol><li>SSL证书，用于加密HTTP协议，也就是HTTPS。</li><li>代码签名证书，用于签名二进制文件，比如Windows内核驱动，Firefox插件，Java代码签名等等。</li><li>客户端证书，用于加密邮件。</li><li>双因素证书，网银专业版使用的USB Key里面用的就是这种类型的证书。</li></ol><p>这些证书都是由受认证的证书颁发机构——我们称之为CA（Certificate Authority）机构来颁发，针对企业与个人的不同，可申请的证书的类型也不同，价格也不同。CA机构颁发的证书都是受信任的证书，对于 SSL 证书来说，如果访问的网站与证书绑定的网站一致就可以通过浏览器的验证而不会提示错误。</p><p><strong>为什么服务端要发送证书给客户端</strong></p><p>互联网有太多的服务需要使用证书来验证身份，以至于客户端(操作系统或浏览器等)无法内置所有证书，需要通过服务端将证书发送给客户端。</p><p><strong>客户端为什么要验证接收到的证书</strong></p><p>中间人攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端&lt;------------攻击者&lt;------------服务端</span><br><span class="line">        伪造证书            拦截请求</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>客户端如何验证接收到的证书</strong></p><p>为了回答这个问题，需要引入数字签名(Digital Signature)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| A digital signature |</span><br><span class="line">|(not to be confused  |</span><br><span class="line">|with a digital       |</span><br><span class="line">|certificate)         |            +---------+              +--------+</span><br><span class="line">| is a mathematical   |----哈希---&gt;| 消息摘要  |---私钥加密---&gt;| 数字签名 |</span><br><span class="line">|technique used       |            +---------+              +--------+</span><br><span class="line">|to validate the      |</span><br><span class="line">|authenticity and     |</span><br><span class="line">|integrity of a       |</span><br><span class="line">|message, software    |</span><br><span class="line">|or digital document. |</span><br><span class="line">+---------------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>将一段文本通过哈希（hash）和私钥加密处理后生成数字签名。</p><p>假设消息传递在Bob，Susan和Pat三人之间发生。Susan将消息连同数字签名一起发送给Bob，Bob接收到消息后，可以这样验证接收到的消息就是Susan发送的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| A digital signature |</span><br><span class="line">|(not to be confused  |</span><br><span class="line">|with a digital       |</span><br><span class="line">|certificate)         |            +---------+</span><br><span class="line">| is a mathematical   |----哈希---&gt;|  消息摘要 |</span><br><span class="line">|technique used       |            +---------+</span><br><span class="line">|to validate the      |                 |</span><br><span class="line">|authenticity and     |                 |</span><br><span class="line">|integrity of a       |                 |</span><br><span class="line">|message, software    |                 对</span><br><span class="line">|or digital document. |                 比</span><br><span class="line">+---------------------+                 |</span><br><span class="line">                                        |</span><br><span class="line">                                        |</span><br><span class="line">          +--------+               +---------+</span><br><span class="line">          | 数字签名 |---公钥解密---&gt;|  消息摘要 |</span><br><span class="line">          +--------+               +---------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当然，这个前提是Bob知道Susan的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Bob。此时就引入了<a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener">证书颁发机构</a>（Certificate Authority，简称CA），CA数量并不多，Bob客户端内置了所有受信任CA的证书。CA对Susan的公钥（和其他信息）数字签名后生成证书。</p><p>Susan将证书发送给Bob后，Bob通过CA证书的公钥验证证书签名。</p><p>Bob信任CA，CA信任Susan 使得 Bob信任Susan，<a href="https://en.wikipedia.org/wiki/Chain_of_trust" target="_blank" rel="noopener">信任链</a>（Chain Of Trust）就是这样形成的。</p><p>事实上，Bob客户端内置的是CA的根证书(Root Certificate)，HTTPS协议中服务器会发送证书链（Certificate Chain）给客户端。</p><h3 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h3><ol><li>Client 使用https的URL访问 Server，要求与 Server 建立 SSL 连接</li><li>Server 把事先配置好的公钥证书返回给客户端。</li><li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</li><li>Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</li><li>Server使用对称密钥加密“明文内容A”，发送给Client。</li><li>Client使用对称密钥解密响应的密文，得到“明文内容A”。</li><li>Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</li></ol><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedeeb2c715.jpg" alt=""></p><h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><ol><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li></ol><h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><ol><li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li><li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li><li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li><li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li><li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li></ol><h3 id="HTTP-切换到-HTTPS"><a href="#HTTP-切换到-HTTPS" class="headerlink" title="HTTP 切换到 HTTPS"></a>HTTP 切换到 HTTPS</h3><p>如果需要将网站从http切换到https到底该如何实现呢？</p><p>这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="http://www.baidu.com改为https://www.baidu.com" target="_blank" rel="noopener">www.baidu.com改为https://www.baidu.com</a></p><p>BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将 <a href="http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。" target="_blank" rel="noopener">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p><h3 id="什么是Cookie，Cookie的使用过程是怎么样的？"><a href="#什么是Cookie，Cookie的使用过程是怎么样的？" class="headerlink" title="什么是Cookie，Cookie的使用过程是怎么样的？"></a>什么是Cookie，Cookie的使用过程是怎么样的？</h3><p>由于 http 协议是无状态协议，如果客户通过浏览器访问 web 应用时没有一个保存用户访问状态的机制，那么将不能持续跟踪应用的操作。比如当用户往购物车中添加了商品，web 应用必须在用户浏览别的商品的时候仍保存购物车的状态，以便用户继续往购物车中添加商品。</p><p>cookie 是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。由于下面一题会讲到session，所以这里要强调cookie会将会话保存在客户端（session则是把会话保存在服务端）</p><p>这里以最常见的登陆案例讲解cookie的使用过程：</p><ol><li>首先用户在客户端浏览器向服务器发起登陆请求</li><li>登陆成功后，服务端会把登陆的用户信息设置 cookie 中，返回给客户端浏览器</li><li>客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）</li><li>以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了</li></ol><h3 id="什么是session，有哪些实现session的机制？"><a href="#什么是session，有哪些实现session的机制？" class="headerlink" title="什么是session，有哪些实现session的机制？"></a>什么是session，有哪些实现session的机制？</h3><p>session 是一种维持客户端与服务器端会话的机制。但是与 <strong>cookie 把会话信息保存在客户端本地不一样，session 把会话保留在浏览器端。</strong></p><p>我们同样以登陆案例为例子讲解 session 的使用过程：</p><ol><li>首先用户在客户端浏览器发起登陆请求</li><li>登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 session 标识给客户端浏览器。</li><li>客户端浏览器会把这个唯一的 session 标识保存在起来</li><li>以后再次访问 web 应用时，客户端浏览器会把这个唯一的 session 标识带上，这样服务端就能根据这个唯一标识找到用户信息。</li></ol><p>看到这里可能会引起疑问：把唯一的 session 标识返回给客户端浏览器，然后保存起来，以后访问时带上，这难道不是 cookie 吗？</p><p>没错，<strong>session 只是一种会话机制，在许多 web 应用中，session 机制就是通过 cookie 来实现的</strong>。也就是说它只是使用了 cookie 的功能，并不是使用 cookie 完成会话保存。与 cookie 在保存客户端保存会话的机制相反，session 通过 cookie 的功能把会话信息保存到了服务端。</p><p>进一步地说，session 是一种维持服务端与客户端之间会话的机制，它可以有不同的实现。以现在比较流行的小程序为例，阐述一个 session 的实现方案：</p><ol><li>首先用户登陆后，需要把用户登陆信息保存在服务端，这里我们可以采用 redis。比如说给用户生成一个 userToken，然后以 userId 作为键，以 userToken 作为值保存到 redis 中，并在返回时把 userToken 带回给小程序端。</li><li>小程序端接收到 userToken 后把它缓存起来，以后每当访问后端服务时就把 userToken 带上。</li><li>在后续的服务中服务端只要拿着小程序端带来的 userToken 和 redis 中的 userToken 进行比对，就能确定用户的登陆状态了。</li></ol><h3 id="session和cookie有什么区别"><a href="#session和cookie有什么区别" class="headerlink" title="session和cookie有什么区别"></a>session和cookie有什么区别</h3><p>经过上面两道题的阐述，这道题就很清晰了</p><ol><li>cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话</li><li>session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。</li><li>如果用 cookie 实现会话，那么会话会保存在客户端浏览器中</li><li>而 session 机制提供的会话是保存在服务端的。</li></ol><h2 id="Other-FAQ"><a href="#Other-FAQ" class="headerlink" title="Other FAQ     "></a>Other FAQ     </h2><h3 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程"></a>从输入网址到获得页面的过程</h3><ol><li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ol><h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><p>XSS 是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</p><p>          </p><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p>IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。</p><p>每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：</p><p>A类地址：以0开头，第一个字节范围：0~127；</p><p>B类地址：以10开头，第一个字节范围：128~191；</p><p>C类地址：以110开头，第一个字节范围：192~223；</p><p>D类地址：以1110开头，第一个字节范围为224~239；</p><p>E类地址：以1111开头，保留地址</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedf2021893.jpg" alt=""></p><h2 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h2><ul><li>《HTTP 权威指南》</li><li><a href="https://arch-long.cn/articles/network/OSI模型TCPIP协议栈.html" target="_blank" rel="noopener">arch-long.cn/articles/ne…</a></li><li><a href="https://blog.csdn.net/qq_32998153/article/details/79680704" target="_blank" rel="noopener">blog.csdn.net/qq_32998153…</a></li></ul>]]></content>
    
    <summary type="html">
    
      在浏览器中输入一个 URL 至页面呈现，网络上都发生了什么事？能说说 ISO 七层模型和 TCP/IP 四层模型吗？CP/IP 与 HTTP 有什么关系吗？...
    
    </summary>
    
    
      <category term="直击面试" scheme="http://yoursite.com/categories/%E7%9B%B4%E5%87%BB%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>[缓存的使用和优化]</title>
    <link href="http://yoursite.com/2020/06/21/%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/21/%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/</id>
    <published>2020-06-21T01:12:43.000Z</published>
    <updated>2020-06-21T01:22:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-缓存的收益与成本"><a href="#一-缓存的收益与成本" class="headerlink" title="一 缓存的收益与成本"></a>一 缓存的收益与成本</h2><h3 id="1-1-受益"><a href="#1-1-受益" class="headerlink" title="1.1 受益"></a>1.1 受益</h3><blockquote><p>1 加速读写</p><p>2 降低后端负载：后端服务器通过前端缓存降低负载，业务端使用redis降低后端mysql负载</p></blockquote><h3 id="1-2-成本"><a href="#1-2-成本" class="headerlink" title="1.2 成本"></a>1.2 成本</h3><blockquote><p>1 数据不一致：缓存层和数据层有时间窗口不一致，和更新策略有关</p><p>2 代码维护成本：多了一层缓存逻辑</p><p>3 运维成本：比如使用了Redis Cluster</p></blockquote><h3 id="1-3-使用场景"><a href="#1-3-使用场景" class="headerlink" title="1.3 使用场景"></a>1.3 使用场景</h3><blockquote><p>1 降低后端负载：对高消耗的sql，join结果集/分组统计的结果做缓存</p><p>2 加速请求响应：利用redis优化io响应时间</p><p>3 大量写合并为批量写：如计数器先redis累加再批量写入db</p></blockquote><h2 id="二-缓存更新策略"><a href="#二-缓存更新策略" class="headerlink" title="二 缓存更新策略"></a>二 缓存更新策略</h2><blockquote><p>1 LRU/LFU/FIFO算法剔除：例如maxmemory-policy(到了最大内存，对应的应对策略)</p><p>​        LRU -Least Recently Used,没有被使用时间最长的</p><p>​        LFU -Least Frequenty User,一定时间段内使用次数最少的</p><p>​        FIFO -First In First Out</p><p>​        LIRS (Low Inter-reference Recency  Set)是一个页替换算法，相比于LRU(Least Recently  Used)和很多其他的替换算法，LIRS具有较高的性能。这是通过使用两次访问同一页之间的距离（本距离指中间被访问了多少非重复块）作为一种尺度去动态地将访问页排序，从而去做一个替换的选择</p><p>配置文件中设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment"># LRU配置</span></span><br><span class="line">&gt;maxmemory-policy:volatile-lru</span><br><span class="line">&gt;（<span class="number">1</span>）noeviction: 如果内存使用达到了maxmemory，client还要继续写入数据，那么就直接报错给客户端</span><br><span class="line">&gt;（<span class="number">2</span>）allkeys-lru: 就是我们常说的LRU算法，移除掉最近最少使用的那些keys对应的数据，ps最长用的策略</span><br><span class="line">&gt;（<span class="number">3</span>）volatile-lru: 也是采取LRU算法，但是仅仅针对那些设置了指定存活时间（TTL）的key才会清理掉</span><br><span class="line">&gt;（<span class="number">4</span>）allkeys-random: 随机选择一些key来删除掉</span><br><span class="line">&gt;（<span class="number">5</span>）volatile-random: 随机选择一些设置了TTL的key来删除掉</span><br><span class="line">&gt;（<span class="number">6</span>）volatile-ttl: 移除掉部分keys，选择那些TTL时间比较短的keys</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment"># LFU配置 Redis4.0之后为maxmemory_policy淘汰策略添加了两个LFU模式：</span></span><br><span class="line">&gt;volatile-lfu：对有过期时间的key采用LFU淘汰算法</span><br><span class="line">&gt;allkeys-lfu：对全部key采用LFU淘汰算法</span><br><span class="line">&gt;<span class="comment"># 还有2个配置可以调整LFU算法：</span></span><br><span class="line">&gt;lfu-log-factor <span class="number">10</span></span><br><span class="line">&gt;lfu-decay-time <span class="number">1</span></span><br><span class="line">&gt;<span class="comment"># lfu-log-factor可以调整计数器counter的增长速度，lfu-log-factor越大，counter增长的越慢。</span></span><br><span class="line">&gt;<span class="comment"># lfu-decay-time是一个以分钟为单位的数值，可以调整counter的减少速度</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p>2 超时剔除：例如expire，设置过期时间</p><p>3 主动更新：开发控制生命周期</p></blockquote><table><thead><tr><th>策略</th><th>一致性</th><th>维护成本</th></tr></thead><tbody><tr><td>LRU/LIRS算法剔除</td><td>最差</td><td>低</td></tr><tr><td>超时剔除</td><td>较差</td><td>低</td></tr><tr><td>主动更新</td><td>强</td><td>高</td></tr></tbody></table><p>1 低一致性：最大内存和淘汰策略</p><p>2 高一致性：超时剔除和主动更新结合，最大内存和淘汰策略兜底</p><h2 id="三-缓存粒度控制"><a href="#三-缓存粒度控制" class="headerlink" title="三 缓存粒度控制"></a>三 缓存粒度控制</h2><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gduwyfg8mgj30bm0dsjt6.jpg" alt="image-20200416002406930" style="zoom:50%;" /><blockquote><p>1 从mysql获取用户信息：select * from user where id=100</p><p>2 设置用户信息缓存：set user:100 <code>select * from user where id=100</code></p><p>3 缓存粒度：</p><p>​    缓存全部属性</p><p>​    缓存部分重要属性</p></blockquote><p>1 通用性：全量属性更好</p><p>2 占用空间：部分属性更好</p><p>3 代码维护：表面上全量属性更好</p><h2 id="四-缓存穿透，缓存击穿，缓存雪崩"><a href="#四-缓存穿透，缓存击穿，缓存雪崩" class="headerlink" title="四 缓存穿透，缓存击穿，缓存雪崩"></a>四 缓存穿透，缓存击穿，缓存雪崩</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">###  缓存穿透</span></span><br><span class="line"><span class="comment">#描述：</span></span><br><span class="line">缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“<span class="number">-1</span>”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</span><br><span class="line"><span class="comment">#解决方案：</span></span><br><span class="line"><span class="number">1</span> 接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=<span class="number">0</span>的直接拦截；</span><br><span class="line"><span class="number">2</span> 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如<span class="number">30</span>秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</span><br><span class="line"><span class="number">3</span> 通过布隆过滤器实现</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 缓存击穿</span></span><br><span class="line"><span class="comment">#描述：</span></span><br><span class="line">缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</span><br><span class="line"><span class="comment">#解决方案：</span></span><br><span class="line">设置热点数据永远不过期。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">### 缓存雪崩</span></span><br><span class="line"><span class="comment">#描述：</span></span><br><span class="line">缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，        缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</span><br><span class="line"><span class="comment"># 解决方案：</span></span><br><span class="line"><span class="number">1</span> 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</span><br><span class="line"><span class="number">2</span> 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。</span><br><span class="line"><span class="number">3</span> 设置热点数据永远不过期。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      缓存的收益与成本,加速读写,降低后端负载：后端服务器通过前端缓存降低负载，业务端使用redis降低后端mysql负载...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[Sentinel]</title>
    <link href="http://yoursite.com/2020/06/21/Sentinel/"/>
    <id>http://yoursite.com/2020/06/21/Sentinel/</id>
    <published>2020-06-21T00:58:43.000Z</published>
    <updated>2020-06-21T00:59:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-主从复制高可用"><a href="#一-主从复制高可用" class="headerlink" title="一 主从复制高可用"></a>一 主从复制高可用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#主从复制存在的问题：</span></span><br><span class="line"><span class="comment">#1 主从复制，主节点发生故障，需要做故障转移，可以手动转移：让其中一个slave变成master</span></span><br><span class="line"><span class="comment">#2 主从复制，只能主写数据，所以写能力和存储能力有限</span></span><br></pre></td></tr></table></figure><h2 id="二-架构说明"><a href="#二-架构说明" class="headerlink" title="二 架构说明"></a>二 架构说明</h2><p>可以做故障判断，故障转移，通知客户端（其实是一个进程），客户端直接连接sentinel的地址</p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadzuhodicj30oe0dc0y9.jpg" alt="image-20191229230823911" style="zoom:50%;" /><p>1 多个sentinel发现并确认master有问题</p><p>2 选举触一个sentinel作为领导</p><p>3 选取一个slave作为新的master</p><p>4 通知其余slave成为新的master的slave</p><p>5 通知客户端主从变化</p><p>6 等待老的master复活成为新master的slave</p><h2 id="三-安装配置"><a href="#三-安装配置" class="headerlink" title="三 安装配置"></a>三 安装配置</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 配置开启主从节点</span><br><span class="line"><span class="number">2</span> 配置开启sentinel监控主节点（sentinel是特殊的redis）</span><br><span class="line"><span class="number">3</span> 应该是多台机器</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置开启sentinel监控主节点</span></span><br><span class="line">mkdir -p redis4/conf redis4/data redis5/conf redis5/data redis6/data redis6/conf</span><br><span class="line"></span><br><span class="line">vi sentinel.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">port <span class="number">26379</span></span><br><span class="line">daemonize yes</span><br><span class="line">dir data</span><br><span class="line">protected-mode no</span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">logfile <span class="string">"redis_sentinel.log"</span></span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run -p <span class="number">26379</span>:<span class="number">26379</span> --name redis_26379 -v /home/redis4/conf/sentinel.conf:/etc/redis/sentinel.conf -v /home/redis4/data:/data -d redis redis-sentinel /etc/redis/sentinel.conf</span><br><span class="line"></span><br><span class="line">docker run -p <span class="number">26378</span>:<span class="number">26379</span> --name redis_26378 -v /home/redis5/conf/sentinel.conf:/etc/redis/sentinel.conf -v /home/redis5/data:/data -d redis redis-sentinel /etc/redis/sentinel.conf</span><br><span class="line"></span><br><span class="line">docker run -p <span class="number">26377</span>:<span class="number">26379</span> --name redis_26377 -v /home/redis6/conf/sentinel.conf:/etc/redis/sentinel.conf -v /home/redis6/data:/data -d redis redis-sentinel /etc/redis/sentinel.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">redis-sentinel sentinel.conf</span><br><span class="line"></span><br><span class="line">info</span><br><span class="line">配置会重写，自动发现slave</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span></span><br><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line">告诉sentinel去监听地址为ip:port的一个master，这里的master-name可以自定义，quorum是一个数字，指明当有多少个sentinel认为一个master失效时，master才算真正失效</span><br><span class="line"></span><br><span class="line">sentinel auth-<span class="keyword">pass</span> &lt;master-name&gt; &lt;password&gt;</span><br><span class="line">设置连接master和slave时的密码，注意的是sentinel不能分别为master和slave设置不同的密码，因此master和slave的密码应该设置相同。</span><br><span class="line"></span><br><span class="line">sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </span><br><span class="line">这个配置项指定了需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的。 单位是毫秒，默认为<span class="number">30</span>秒</span><br><span class="line"></span><br><span class="line">sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; </span><br><span class="line">这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 <span class="number">1</span> 来保证每次只有一个slave 处于不能处理命令请求的状态。</span><br><span class="line"></span><br><span class="line">sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">failover-timeout 可以用在以下这些方面：     </span><br><span class="line"><span class="number">1.</span> 同一个sentinel对同一个master两次failover之间的间隔时间。   </span><br><span class="line"><span class="number">2.</span> 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。    </span><br><span class="line"><span class="number">3.</span>当想要取消一个正在进行的failover所需要的时间。    </span><br><span class="line"><span class="number">4.</span>当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 搭一个一主两从</span><br><span class="line"><span class="comment">#创建三个配置文件：</span></span><br><span class="line"><span class="comment">#第一个是主配置文件</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line">port <span class="number">6379</span></span><br><span class="line">dir <span class="string">"/opt/soft/redis/data"</span></span><br><span class="line">logfile “<span class="number">6379.l</span>og”</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二个是从配置文件</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis2.pid</span><br><span class="line">port <span class="number">6378</span></span><br><span class="line">dir <span class="string">"/opt/soft/redis/data2"</span></span><br><span class="line">logfile “<span class="number">6378.l</span>og”</span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"><span class="comment">#第三个是从配置文件</span></span><br><span class="line">daemonize yes</span><br><span class="line">pidfile /var/run/redis3.pid</span><br><span class="line">port <span class="number">6377</span></span><br><span class="line">dir <span class="string">"/opt/soft/redis/data3"</span></span><br><span class="line">logfile “<span class="number">6377.l</span>og”</span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#把三个redis服务都启动起来</span></span><br><span class="line">./src/redis-server redis_6379.conf</span><br><span class="line">./src/redis-server redis_6378.conf</span><br><span class="line">./src/redis-server redis_6377.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> 搭建哨兵</span><br><span class="line"><span class="comment"># sentinel.conf这个文件</span></span><br><span class="line"><span class="comment"># 把哨兵也当成一个redis服务器</span></span><br><span class="line">创建三个配置文件分别叫sentinel_26379.conf sentinel_26378.conf  sentinel_26377.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当前路径下创建 data1 data2 data3 个文件夹</span></span><br><span class="line"><span class="comment">#内容如下(需要修改端口，文件地址日志文件名字)</span></span><br><span class="line">port <span class="number">26379</span></span><br><span class="line">daemonize yes</span><br><span class="line">dir ./data3</span><br><span class="line">protected-mode no</span><br><span class="line">bind <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">logfile <span class="string">"redis_sentinel3.log"</span></span><br><span class="line">sentinel monitor mymaster <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="number">2</span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">30000</span></span><br><span class="line">sentinel parallel-syncs mymaster <span class="number">1</span></span><br><span class="line">sentinel failover-timeout mymaster <span class="number">180000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动三个哨兵</span></span><br><span class="line">./src/redis-sentinel sentinel_26379.conf</span><br><span class="line">./src/redis-sentinel sentinel_26378.conf</span><br><span class="line">./src/redis-sentinel sentinel_26377.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登陆哨兵</span></span><br><span class="line">./src/redis-cli -p <span class="number">26377</span></span><br><span class="line"><span class="comment"># 输入 info</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看哨兵的配置文件被修改了，自动生成的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主动停掉主redis 6379，哨兵会自动选择一个从库作为主库</span></span><br><span class="line">redis-cli -p <span class="number">6379</span></span><br><span class="line">shutdown</span><br><span class="line"><span class="comment">#等待原来的主库启动，该主库会变成从库</span></span><br></pre></td></tr></table></figure><h2 id="四-客户端连接"><a href="#四-客户端连接" class="headerlink" title="四 客户端连接"></a>四 客户端连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> redis.sentinel <span class="keyword">import</span> Sentinel</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接哨兵服务器(主机名也可以用域名)</span></span><br><span class="line"><span class="comment"># 10.0.0.101:26379</span></span><br><span class="line">sentinel = Sentinel([(<span class="string">'10.0.0.101'</span>, <span class="number">26379</span>),</span><br><span class="line">                     (<span class="string">'10.0.0.101'</span>, <span class="number">26378</span>),</span><br><span class="line">                     (<span class="string">'10.0.0.101'</span>, <span class="number">26377</span>)</span><br><span class="line">     ],</span><br><span class="line">                    socket_timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(sentinel)</span><br><span class="line"><span class="comment"># 获取主服务器地址</span></span><br><span class="line">master = sentinel.discover_master(<span class="string">'mymaster'</span>)</span><br><span class="line">print(master)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取从服务器地址</span></span><br><span class="line">slave = sentinel.discover_slaves(<span class="string">'mymaster'</span>)</span><br><span class="line">print(slave)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取主服务器进行写入</span></span><br><span class="line"><span class="comment"># master = sentinel.master_for('mymaster', socket_timeout=0.5)</span></span><br><span class="line"><span class="comment"># w_ret = master.set('foo', 'bar')</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># slave = sentinel.slave_for('mymaster', socket_timeout=0.5)</span></span><br><span class="line"><span class="comment"># r_ret = slave.get('foo')</span></span><br><span class="line"><span class="comment"># print(r_ret)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      主从复制存在的问题：主从复制，主节点发生故障，需要做故障转移，可以手动转移：让其中一个slave变成master,主从复制，只能主写数据，所以写能力和存储能力有限...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[主从复制原理与优化]</title>
    <link href="http://yoursite.com/2020/06/21/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/21/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2020-06-21T00:55:43.000Z</published>
    <updated>2020-06-21T00:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-什么是主从复制"><a href="#一-什么是主从复制" class="headerlink" title="一 什么是主从复制"></a>一 什么是主从复制</h2><p>机器故障；容量瓶颈；QPS瓶颈</p><p>一主一从，一主多从</p><p>做读写分离</p><p>做数据副本</p><p>扩展数据性能</p><p>一个maskter可以有多个slave</p><p>一个slave只能有一个master</p><p>数据流向是单向的，从master到slave</p><h2 id="二-复制的-配置"><a href="#二-复制的-配置" class="headerlink" title="二 复制的 配置"></a>二 复制的 配置</h2><h3 id="2-1-slave-命令"><a href="#2-1-slave-命令" class="headerlink" title="2.1 slave 命令"></a>2.1 slave 命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6380</span>是从，<span class="number">6379</span>是主</span><br><span class="line"></span><br><span class="line">在<span class="number">6380</span>上执行（去从库配置，配置主库）</span><br><span class="line"></span><br><span class="line">slaveof <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379</span> <span class="comment">#异步</span></span><br><span class="line">slaveof no one <span class="comment">#取消复制，不会把之前的数据清除</span></span><br></pre></td></tr></table></figure><h3 id="2-2-配置文件"><a href="#2-2-配置文件" class="headerlink" title="2.2 配置文件"></a>2.2 配置文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">slaveof ip port <span class="comment">#配置从节点ip和端口</span></span><br><span class="line">slave-read-only yes <span class="comment">#从节点只读，因为可读可写，数据会乱</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">mkdir -p redis1/conf redis1/data redis2/conf redis2/data redis3/conf redis3/data</span></span><br><span class="line"><span class="string">vim redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">daemonize no</span></span><br><span class="line"><span class="string">pidfile redis.pid</span></span><br><span class="line"><span class="string">bind 0.0.0.0</span></span><br><span class="line"><span class="string">protected-mode no</span></span><br><span class="line"><span class="string">port 6379</span></span><br><span class="line"><span class="string">timeout 0</span></span><br><span class="line"><span class="string">logfile redis.log</span></span><br><span class="line"><span class="string">dbfilename dump.rdb</span></span><br><span class="line"><span class="string">dir /data</span></span><br><span class="line"><span class="string">slaveof 10.0.0.101 6379</span></span><br><span class="line"><span class="string">slave-read-only yes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cp redis.conf /home/redis2/conf/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker run -p 6379:6379 --name redis_6379 -v /home/redis1/conf/redis.conf:/etc/redis/redis.conf -v /home/redis1/data:/data -d redis redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker run -p 6378:6379 --name redis_6378 -v /home/redis2/conf/redis.conf:/etc/redis/redis.conf -v /home/redis2/data:/data -d redis redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">docker run -p 6377:6379 --name redis_6377 -v /home/redis3/conf/redis.conf:/etc/redis/redis.conf -v /home/redis3/data:/data -d redis redis-server /etc/redis/redis.conf</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">info replication</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="四-故障处理"><a href="#四-故障处理" class="headerlink" title="四 故障处理"></a>四 故障处理</h2><p>slave故障</p><p>master故障</p><h2 id="五-复制常见问题"><a href="#五-复制常见问题" class="headerlink" title="五 复制常见问题"></a>五 复制常见问题</h2><p>1 读写分离</p><p>读流量分摊到从节点</p><p>可能遇到问题：复制数据延迟，读到过期数据，从节点故障</p><p>2 主从配置不一致</p><p>maxmemory不一致：丢失数据</p><p>数据结构优化参数：主节点做了优化，从节点没有设置优化，会出现一些问题</p><p>3 规避全量复制</p><p>第一次全量复制，不可避免：小主节点，低峰(夜间)</p><p>节点运行id不匹配：主节点重启(运行id变化)</p><p>复制挤压缓冲区不足：增大复制缓冲区大小，rel_backlog_size</p><p>4 规避复制风暴</p><p>单主节点复制风暴，主节点重启，所有从节点复制</p>]]></content>
    
    <summary type="html">
    
      什么是主从复制,一主一从，一主多从,做读写分离做数据副本,扩展数据性能,一个maskter可以有多个slave,一个slave只能有一个master,数据流向是单向的...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[使用常见问题]</title>
    <link href="http://yoursite.com/2020/06/21/%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/06/21/%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-20T23:55:43.000Z</published>
    <updated>2020-06-20T23:57:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-子进程开销和优化"><a href="#一-子进程开销和优化" class="headerlink" title="一 子进程开销和优化"></a>一 子进程开销和优化</h2><p>1 cpu</p><p>开销：rdb和aof文件生成，属于cpu密集型</p><p>优化：不做cpu绑定，不和cpu密集型的服务一起部署</p><p>2 内存</p><p>开销：fork内存开销，copy-on-write，</p><p>优化：单机部署尽量少重写</p><p> 3 硬盘</p><p>开销：aof和rdb写入，可以结合分析工具使用</p><p>优化：</p><p>1 不要和高硬盘负载的服务部署在一起：存储服务，消息队列</p><p>2 在aof重写期间，不要对aof进行追加：no-appendfsync-on-rewrite=yes</p><p>3 根据写入量决定磁盘类型：例如ssd</p><p>4 单机多实例持久化考虑分盘</p><h2 id="二-fork操作"><a href="#二-fork操作" class="headerlink" title="二 fork操作"></a>二 fork操作</h2><p>1 fork是同步操作</p><p>2 与内存量嘻嘻相关：内存越大，耗时越长，跟机型也有关系</p><p>3 info：latest_fok_usec:查看持久化执行时间</p><p>改善fork</p><p>1 有限使用无机或高效支持fork操作的虚拟化技术</p><p>2 控制redis实例最大可用内存：maxmemory</p><p>3 合理配置linux内存分配策略</p><p>4 降低fork频率，例如放宽aof重写自动触发时机，不必要的全量复制</p><h2 id="三-aof追加阻塞"><a href="#三-aof追加阻塞" class="headerlink" title="三 aof追加阻塞"></a>三 aof追加阻塞</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadtfor4exj30hu0ke434.jpg" alt="image-20191229192629198"></p><p>aof阻塞：看日志定位</p><p>info Persistence：每次阻塞一次就会+1</p>]]></content>
    
    <summary type="html">
    
      子进程开销和优化,cpu开销：rdb和aof文件生成，属于cpu密集型,cpu优化：不做cpu绑定，不和cpu密集型的服务一起部署...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[持久化]</title>
    <link href="http://yoursite.com/2020/06/21/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2020/06/21/%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-06-20T23:52:23.000Z</published>
    <updated>2020-06-20T23:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-持久化的作用"><a href="#一-持久化的作用" class="headerlink" title="一 持久化的作用"></a>一 持久化的作用</h2><h3 id="1-1-什么是持久化"><a href="#1-1-什么是持久化" class="headerlink" title="1.1 什么是持久化"></a>1.1 什么是持久化</h3><p>redis的所有数据保存在内存中，对数据的更新将异步的保存到硬盘上</p><h3 id="1-2-持久化的实现方式"><a href="#1-2-持久化的实现方式" class="headerlink" title="1.2 持久化的实现方式"></a>1.2 持久化的实现方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">快照：某时某刻数据的一个完成备份，</span><br><span class="line">-mysql的Dump</span><br><span class="line">    -redis的RDB</span><br><span class="line">写日志：任何操作记录日志，要恢复数据，只要把日志重新走一遍即可</span><br><span class="line">-mysql的 Binlog</span><br><span class="line">    -Hhase的 HLog</span><br><span class="line">    -Redis的 AOF</span><br></pre></td></tr></table></figure><h2 id="二-RDB"><a href="#二-RDB" class="headerlink" title="二 RDB"></a>二 RDB</h2><h3 id="2-1-什么是RDB"><a href="#2-1-什么是RDB" class="headerlink" title="2.1 什么是RDB"></a>2.1 什么是RDB</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga9zt9svljj30oo0d644s.jpg" alt="image-20191226120500154"></p><h3 id="2-2-触发机制-主要三种方式"><a href="#2-2-触发机制-主要三种方式" class="headerlink" title="2.2 触发机制-主要三种方式"></a>2.2 触发机制-主要三种方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">save(同步)</span></span><br><span class="line"><span class="string">1 客户端执行save命令----》redis服务端----》同步创建RDB二进制文件</span></span><br><span class="line"><span class="string">2 会造成redis的阻塞（数据量非常大的时候）</span></span><br><span class="line"><span class="string">3 文件策略：如果老的RDB存在，会替换老的</span></span><br><span class="line"><span class="string">4 复杂度 o(n)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bgsave(异步，Backgroud saving started)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1 客户端执行save命令----》redis服务端----》异步创建RDB二进制文件（fork函数生成一个子进程（fork会阻塞reids），执行createRDB，执行成功，返回给reids消息）</span></span><br><span class="line"><span class="string">2 此时访问redis，会正常响应客户端</span></span><br><span class="line"><span class="string">3 文件策略：跟save相同，如果老的RDB存在，会替换老的</span></span><br><span class="line"><span class="string">4 复杂度 o(n)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">自动（通过配置）</span></span><br><span class="line"><span class="string">配置   seconds   changes</span></span><br><span class="line"><span class="string">save   900        1</span></span><br><span class="line"><span class="string">save   300        10</span></span><br><span class="line"><span class="string">save   60         10000</span></span><br><span class="line"><span class="string">如果60s中改变了1w条数据，自动生成rdb</span></span><br><span class="line"><span class="string">如果300s中改变了10条数据，自动生成rdb</span></span><br><span class="line"><span class="string">如果900s中改变了1条数据，自动生成rdb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">以上三条符合任意一条，就自动生成rdb，内部使用bgsave</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置：</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span> <span class="comment">#配置一条</span></span><br><span class="line">save <span class="number">300</span> <span class="number">10</span> <span class="comment">#配置一条</span></span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span> <span class="comment">#配置一条</span></span><br><span class="line">dbfilename dump.rdb  <span class="comment">#rdb文件的名字，默认为dump.rdb</span></span><br><span class="line">dir ./ <span class="comment">#rdb文件存在当前目录</span></span><br><span class="line"></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#如果bgsave出现错误，是否停止写入，默认为yes</span></span><br><span class="line">rdbcompression yes <span class="comment">#采用压缩格式</span></span><br><span class="line">rdbchecksum yes <span class="comment">#是否对rdb文件进行校验和检验</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最佳配置</span></span><br><span class="line">save <span class="number">900</span> <span class="number">1</span> </span><br><span class="line">save <span class="number">300</span> <span class="number">10</span> </span><br><span class="line">save <span class="number">60</span> <span class="number">10000</span> </span><br><span class="line">dbfilename dump-$&#123;port&#125;.rdb  <span class="comment">#以端口号作为文件名，可能一台机器上很多reids，不会乱</span></span><br><span class="line">dir /bigdiskpath <span class="comment">#保存路径放到一个大硬盘位置目录</span></span><br><span class="line">stop-writes-on-bgsave-error yes <span class="comment">#出现错误停止</span></span><br><span class="line">rdbcompression yes <span class="comment">#压缩</span></span><br><span class="line">rdbchecksum yes <span class="comment">#校验</span></span><br></pre></td></tr></table></figure><h3 id="2-3-触发机制-不容忽略的方式"><a href="#2-3-触发机制-不容忽略的方式" class="headerlink" title="2.3 触发机制-不容忽略的方式"></a>2.3 触发机制-不容忽略的方式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 全量复制 <span class="comment">#没有执行save和bgsave没有添加rdb策略，还会生成rdb文件，如果开启主从复制，主会自动生成rdb</span></span><br><span class="line"><span class="number">2</span> debug reload <span class="comment">#debug级别的重启，不会将内存中的数据清空</span></span><br><span class="line"><span class="number">3</span> shutdown save<span class="comment">#关闭会出发rdb的生成</span></span><br></pre></td></tr></table></figure><h3 id="2-4-试验"><a href="#2-4-试验" class="headerlink" title="2.4 试验"></a>2.4 试验</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三-AOF"><a href="#三-AOF" class="headerlink" title="三 AOF"></a>三 AOF</h3><h3 id="3-1-RDB问题"><a href="#3-1-RDB问题" class="headerlink" title="3.1 RDB问题"></a>3.1 RDB问题</h3><p>耗时，耗性能：</p><p>不可控，可能会丢失数据</p><h3 id="3-2-AOF介绍"><a href="#3-2-AOF介绍" class="headerlink" title="3.2 AOF介绍"></a>3.2 AOF介绍</h3><p>客户端每写入一条命令，都记录一条日志，放到日志文件中，如果出现宕机，可以将数据完全恢复</p><h3 id="3-3-AOF的三种策略"><a href="#3-3-AOF的三种策略" class="headerlink" title="3.3 AOF的三种策略"></a>3.3 AOF的三种策略</h3><p>日志不是直接写到硬盘上，而是先放在缓冲区，缓冲区根据一些策略，写到硬盘上</p><p>always：redis–》写命令刷新的缓冲区—》每条命令fsync到硬盘—》AOF文件</p><p>everysec（默认值）：redis——》写命令刷新的缓冲区—》每秒把缓冲区fsync到硬盘–》AOF文件</p><p>no:redis——》写命令刷新的缓冲区—》操作系统决定，缓冲区fsync到硬盘–》AOF文件</p><table><thead><tr><th>命令</th><th>always</th><th>everysec</th><th>no</th></tr></thead><tbody><tr><td>优点</td><td>不丢失数据</td><td>每秒一次fsync，丢失1秒数据</td><td>不用管</td></tr><tr><td>缺点</td><td>IO开销大，一般的sata盘只有几百TPS</td><td>丢1秒数据</td><td>不可控</td></tr></tbody></table><h3 id="3-4-AOF-重写"><a href="#3-4-AOF-重写" class="headerlink" title="3.4 AOF 重写"></a>3.4 AOF 重写</h3><p>随着命令的逐步写入，并发量的变大， AOF文件会越来越大，通过AOF重写来解决该问题</p><table><thead><tr><th>原生AOF</th><th>AOF重写</th></tr></thead><tbody><tr><td>set hello world<br/>set hello java<br/>set hello hehe<br/>incr counter<br/>incr counter<br/>rpush mylist a<br/>rpush mylist b<br/>rpush mylist c<br/>过期数据</td><td>set hello hehe<br/>set counter 2<br/>rpush mylist a b c</td></tr></tbody></table><p>本质就是把过期的，无用的，重复的，可以优化的命令，来优化</p><p>这样可以减少磁盘占用量，加速恢复速度</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><p>bgrewriteaof：</p><p>客户端向服务端发送bgrewriteaof命令，服务端会起一个fork进程，完成AOF重写</p><h4 id="AOF重写配置："><a href="#AOF重写配置：" class="headerlink" title="AOF重写配置："></a>AOF重写配置：</h4><table><thead><tr><th>配置名</th><th>含义</th></tr></thead><tbody><tr><td>auto-aof-rewrite-min-size</td><td>AOF文件重写需要尺寸</td></tr><tr><td>auto-aof-rewrite-percentage</td><td>AOF文件增长率</td></tr></tbody></table><table><thead><tr><th>统计名</th><th>含义</th></tr></thead><tbody><tr><td>aof_current_size</td><td>AOF当前尺寸（单位：字节）</td></tr><tr><td>aof_base_size</td><td>AOF上次启动和重写的尺寸（单位：字节）</td></tr></tbody></table><p>自动触发时机（两个条件同时满足）：</p><p>aof_current_size&gt;auto-aof-rewrite-min-size：当前尺寸大于重写需要尺寸</p><p>(aof_current_size-aof_base_size)/aof_base_size&gt;auto-aof-rewrite-percentage:（增长率）当前尺寸减去上次重写的尺寸，除以上次重写的尺寸如果大于配置中的增长率</p><h4 id="重写流程"><a href="#重写流程" class="headerlink" title="重写流程"></a>重写流程</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gadsmknx2sj30fy0hw78l.jpg" alt="image-20191229185839519"></p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes <span class="comment">#将该选项设置为yes，打开</span></span><br><span class="line">appendfilename <span class="string">"appendonly-$&#123;port&#125;.aof"</span> <span class="comment">#文件保存的名字</span></span><br><span class="line">appendfsync everysec <span class="comment">#采用第二种策略</span></span><br><span class="line">dir /bigdiskpath <span class="comment">#存放的路径</span></span><br><span class="line">no-appendfsync-on-rewrite yes <span class="comment">#在aof重写的时候，是否要做aof的append操作，因为aof重写消耗性能，磁盘消耗，正常aof写磁盘有一定的冲突，这段期间的数据，允许丢失</span></span><br></pre></td></tr></table></figure><h3 id="3-5-AOF-重写演示"><a href="#3-5-AOF-重写演示" class="headerlink" title="3.5 AOF 重写演示"></a>3.5 AOF 重写演示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="四-RDB和AOF的选择"><a href="#四-RDB和AOF的选择" class="headerlink" title="四 RDB和AOF的选择"></a>四 RDB和AOF的选择</h2><h3 id="4-1-rdb和aof的比较"><a href="#4-1-rdb和aof的比较" class="headerlink" title="4.1 rdb和aof的比较"></a>4.1 rdb和aof的比较</h3><table><thead><tr><th>命令</th><th>rdb</th><th>aof</th></tr></thead><tbody><tr><td>启动优先级</td><td>低</td><td>高(挂掉重启，会加载aof的数据)</td></tr><tr><td>体积</td><td>小</td><td>大</td></tr><tr><td>恢复速度</td><td>快</td><td>慢</td></tr><tr><td>数据安全性</td><td>丢数据</td><td>根据策略决定</td></tr><tr><td>轻重</td><td>重</td><td>轻</td></tr></tbody></table><h3 id="4-2-rdb最佳策略"><a href="#4-2-rdb最佳策略" class="headerlink" title="4.2  rdb最佳策略"></a>4.2  rdb最佳策略</h3><p>rdb关掉，主从操作时</p><p>集中管理：按天，按小时备份数据</p><p>主从配置，从节点打开</p><h3 id="4-3-aof最佳策略"><a href="#4-3-aof最佳策略" class="headerlink" title="4.3 aof最佳策略"></a>4.3 aof最佳策略</h3><p>开：缓存和存储，大部分情况都打开，</p><p>aof重写集中管理</p><p>everysec：通过每秒刷新的策略</p><h3 id="4-4-最佳策略"><a href="#4-4-最佳策略" class="headerlink" title="4.4 最佳策略"></a>4.4 最佳策略</h3><p>小分片：每个redis的最大内存为4g</p><p>缓存或存储：根据特性，使用不通策略</p><p>时时监控硬盘，内存，负载网络等</p><p>有足够内存</p>]]></content>
    
    <summary type="html">
    
      什么是持久化,redis的所有数据保存在内存中，对数据的更新将异步的保存到硬盘上,持久化的实现方式,快照：某时某刻数据的一个完成备份...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[高级用法]</title>
    <link href="http://yoursite.com/2020/06/21/%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/21/%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/</id>
    <published>2020-06-20T23:45:33.000Z</published>
    <updated>2020-06-20T23:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-慢查询"><a href="#一-慢查询" class="headerlink" title="一 慢查询"></a>一 慢查询</h2><h3 id="1-1-生命周期"><a href="#1-1-生命周期" class="headerlink" title="1.1 生命周期"></a>1.1 生命周期</h3><p>我们配置一个时间，如果查询时间超过了我们设置的时间，我们就认为这是一个慢查询.</p><p>慢查询发生在第三阶段</p><p>客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga8r6p7tpej30z80k2afq.jpg" alt="image-20191225102102218"></p><h3 id="1-2-两个配置"><a href="#1-2-两个配置" class="headerlink" title="1.2 两个配置"></a>1.2 两个配置</h3><h4 id="1-2-1-slowlog-max-len"><a href="#1-2-1-slowlog-max-len" class="headerlink" title="1.2.1 slowlog-max-len"></a>1.2.1 slowlog-max-len</h4><p>慢查询是一个先进先出的队列</p><p>固定长度</p><p>保存在内存中</p><h4 id="1-2-2-slowlog-max-len"><a href="#1-2-2-slowlog-max-len" class="headerlink" title="1.2.2 slowlog-max-len"></a>1.2.2 slowlog-max-len</h4><p>慢查询阈值（单位：微秒）</p><p>slowlog-log-slower-than=0，记录所有命令</p><p>slowlog-log-slower-than &lt;0,不记录任何命令</p><h4 id="1-2-3-配置方法"><a href="#1-2-3-配置方法" class="headerlink" title="1.2.3 配置方法"></a>1.2.3 配置方法</h4><p><strong>1 默认配置</strong></p><p>config get slowlog-max-len=128</p><p>Config get slowly-log-slower-than=10000</p><p><strong>2 修改配置文件重启</strong></p><p><strong>3 动态配置</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置记录所有命令</span></span><br><span class="line">config set slowlog-log-slower-than <span class="number">0</span></span><br><span class="line"><span class="comment"># 最多记录100条</span></span><br><span class="line">config set slowlog-max-len <span class="number">100</span></span><br><span class="line"><span class="comment"># 持久化到本地配置文件</span></span><br><span class="line">config rewrite</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">config set slowlog-max-len 1000</span></span><br><span class="line"><span class="string">config set slowlog-log-slower-than 1000</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="1-3-三个命令"><a href="#1-3-三个命令" class="headerlink" title="1.3 三个命令"></a>1.3 三个命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">slowlog get [n]  <span class="comment">#获取慢查询队列</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">日志由4个属性组成：</span></span><br><span class="line"><span class="string">1）日志的标识id</span></span><br><span class="line"><span class="string">2）发生的时间戳</span></span><br><span class="line"><span class="string">3）命令耗时</span></span><br><span class="line"><span class="string">4）执行的命令和参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">slowlog len <span class="comment">#获取慢查询队列长度</span></span><br><span class="line"></span><br><span class="line">slowlog reset <span class="comment">#清空慢查询队列</span></span><br></pre></td></tr></table></figure><h3 id="1-4-经验"><a href="#1-4-经验" class="headerlink" title="1.4 经验"></a>1.4 经验</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> slowlog-max-len 不要设置过大，默认<span class="number">10</span>ms，通常设置<span class="number">1</span>ms</span><br><span class="line"><span class="number">2</span> slowlog-log-slower-than不要设置过小，通常设置<span class="number">1000</span>左右</span><br><span class="line"><span class="number">3</span> 理解命令生命周期</span><br><span class="line"><span class="number">4</span> 定期持久化慢查询</span><br></pre></td></tr></table></figure><h2 id="二-pipeline"><a href="#二-pipeline" class="headerlink" title="二 pipeline"></a>二 pipeline</h2><h3 id="2-1-什么是pipeline-管道"><a href="#2-1-什么是pipeline-管道" class="headerlink" title="2.1 什么是pipeline(管道)"></a>2.1 什么是pipeline(管道)</h3><p>Redis的pipeline(管道)功能在命令行中没有，但redis是支持pipeline的，而且在各个语言版的client中都有相应的实现</p><p>将一批命令，批量打包，在redis服务端批量计算(执行)，然后把结果批量返回</p><p>1次pipeline(n条命令)=1次网络时间+n次命令时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipeline期间将“独占”链接，此期间将不能进行非“管道”类型的其他操作，直到pipeline关闭；如果你的pipeline的指令集很庞大，为了不干扰链接中的其他操作，你可以为pipeline操作新建Client链接，让pipeline和其他正常操作分离在<span class="number">2</span>个client中。不过pipeline事实上所能容忍的操作个数，和socket-output缓冲区大小/返回结果的数据尺寸都有很大的关系；同时也意味着每个redis-server同时所能支撑的pipeline链接的个数，也是有限的，这将受限于server的物理内存或网络接口的缓冲能力</span><br></pre></td></tr></table></figure><h3 id="2-2-客户端实现"><a href="#2-2-客户端实现" class="headerlink" title="2.2 客户端实现"></a>2.2 客户端实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'10.211.55.4'</span>, port=<span class="number">6379</span>)</span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"><span class="comment"># pipe = r.pipeline(transaction=False)</span></span><br><span class="line"><span class="comment">#创建pipeline</span></span><br><span class="line">pipe = r.pipeline(transaction=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#开启事务</span></span><br><span class="line">pipe.multi()</span><br><span class="line">pipe.set(<span class="string">'name'</span>, <span class="string">'lqz'</span>)</span><br><span class="line"><span class="comment">#其他代码，可能出异常</span></span><br><span class="line"></span><br><span class="line">pipe.set(<span class="string">'role'</span>, <span class="string">'nb'</span>)</span><br><span class="line"> </span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure><h3 id="2-3-与原生操作对比"><a href="#2-3-与原生操作对比" class="headerlink" title="2.3 与原生操作对比"></a>2.3 与原生操作对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过pipeline提交的多次命令，在服务端执行的时候，可能会被拆成多次执行，而mget等操作，是一次性执行的，所以，pipeline执行的命令并非原子性的</span><br></pre></td></tr></table></figure><h3 id="2-4-使用建议"><a href="#2-4-使用建议" class="headerlink" title="2.4 使用建议"></a>2.4 使用建议</h3><p>1 注意每次pipeline携带的数据量</p><p>2 pipeline每次只能作用在一个Redis的节点上</p><p>3 M(mset，mget….)操作和pipeline的区别</p><h2 id="三-发布订阅"><a href="#三-发布订阅" class="headerlink" title="三 发布订阅"></a>三 发布订阅</h2><h3 id="3-1-角色"><a href="#3-1-角色" class="headerlink" title="3.1 角色"></a>3.1 角色</h3><p><strong>发布者/订阅者/频道</strong></p><p>发布者发布了消息，所有的订阅者都可以收到，就是生产者消费者模型（后订阅了，无法获取历史消息）</p><h3 id="3-2-模型"><a href="#3-2-模型" class="headerlink" title="3.2 模型"></a>3.2 模型</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga923qyr2uj31xp0u0jwt.jpg" alt="image-20191225163659941"></p><h3 id="3-3-API"><a href="#3-3-API" class="headerlink" title="3.3 API"></a>3.3 API</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">publish channel message <span class="comment">#发布命令</span></span><br><span class="line">publish souhu:tv <span class="string">"hello world"</span> <span class="comment">#在souhu:tv频道发布一条hello world  返回订阅者个数</span></span><br><span class="line"></span><br><span class="line">subscribe [channel] <span class="comment">#订阅命令，可以订阅一个或多个</span></span><br><span class="line">subscribe souhu:tv  <span class="comment">#订阅sohu:tv频道</span></span><br><span class="line"></span><br><span class="line">unsubscribe [channel] <span class="comment">#取消订阅一个或多个频道</span></span><br><span class="line">unsubscribe sohu:tv  <span class="comment">#取消订阅sohu:tv频道</span></span><br><span class="line">    </span><br><span class="line">psubscribe [pattern...] <span class="comment">#订阅模式匹配</span></span><br><span class="line">psubscribe c*  <span class="comment">#订阅以c开头的频道</span></span><br><span class="line"></span><br><span class="line">unpsubscribe [pattern...] <span class="comment">#按模式退订指定频道</span></span><br><span class="line"></span><br><span class="line">pubsub channels <span class="comment">#列出至少有一个订阅者的频道,列出活跃的频道</span></span><br><span class="line"></span><br><span class="line">pubsub numsub [channel...] <span class="comment">#列出给定频道的订阅者数量</span></span><br><span class="line"></span><br><span class="line">pubsub numpat <span class="comment">#列出被订阅模式的数量</span></span><br></pre></td></tr></table></figure><h3 id="3-4-发布订阅和消息队列"><a href="#3-4-发布订阅和消息队列" class="headerlink" title="3.4 发布订阅和消息队列"></a>3.4 发布订阅和消息队列</h3><p>发布订阅数全收到，消息队列有个抢的过程，只有一个抢到</p><h2 id="四-Bitmap位图"><a href="#四-Bitmap位图" class="headerlink" title="四 Bitmap位图"></a>四 Bitmap位图</h2><h3 id="4-1-位图是什么"><a href="#4-1-位图是什么" class="headerlink" title="4.1 位图是什么"></a>4.1 位图是什么</h3><p>下面是字符串big对应的二进制（b是98）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga93bk259dj313y0isajp.jpg" alt="image-20191225172053447"></p><h3 id="4-2-相关命令"><a href="#4-2-相关命令" class="headerlink" title="4.2 相关命令"></a>4.2 相关命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">set hello big <span class="comment">#放入key位hello 值为big的字符串</span></span><br><span class="line">getbit hello <span class="number">0</span> <span class="comment">#取位图的第0个位置，返回0</span></span><br><span class="line">getbit hello <span class="number">1</span> <span class="comment">#取位图的第1个位置，返回1 如上图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##我们可以直接操纵位</span></span><br><span class="line">setbit key offset value <span class="comment">#给位图指定索引设置值</span></span><br><span class="line">setbit hello <span class="number">7</span> <span class="number">1</span> <span class="comment">#把hello的第7个位置设为1 这样，big就变成了cig</span></span><br><span class="line"></span><br><span class="line">setbit test <span class="number">50</span> <span class="number">1</span> <span class="comment">#test不存在，在key为test的value的第50位设为1，那其他位都以0补</span></span><br><span class="line"></span><br><span class="line">bitcount key [start end] <span class="comment">#获取位图指定范围(start到end,单位为字节,注意按字节一个字节8个bit为，如果不指定就是获取全部)位值为1的个数</span></span><br><span class="line"></span><br><span class="line">bitop op destkey key [key...] <span class="comment">#做多个Bitmap的and(交集)/or(并集)/not(非)/xor(异或)，操作并将结果保存在destkey中 </span></span><br><span class="line">bitop <span class="keyword">and</span> after_lqz lqz lqz2 <span class="comment">#把lqz和lqz2按位与操作，放到after_lqz中</span></span><br><span class="line"></span><br><span class="line">bitpos key targetBit start end <span class="comment">#计算位图指定范围(start到end，单位为字节，如果不指定是获取全部)第一个偏移量对应的值等于targetBit的位置</span></span><br><span class="line">bitpos lqz <span class="number">1</span> <span class="comment">#big 对应位图中第一个1的位置，在第二个位置上，由于从0开始返回1</span></span><br><span class="line">bitpos lqz <span class="number">0</span> <span class="comment">#big 对应位图中第一个0的位置，在第一个位置上，由于从0开始返回0</span></span><br><span class="line">bitpos lqz <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="comment">#返回9：返回从第一个字节到第二个字节之间 第一个1的位置，看上图，为9</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga93gnif6ej310q0iuwpy.jpg" alt="image-20191225172547661"></p><h3 id="4-3-独立用户统计"><a href="#4-3-独立用户统计" class="headerlink" title="4.3 独立用户统计"></a>4.3 独立用户统计</h3><p>1 使用set和Bitmap对比</p><p>2 1亿用户，5千万独立（1亿用户量，约5千万人访问，统计活跃用户数量）</p><table><thead><tr><th>数据类型</th><th>每个userid占用空间</th><th>需要存储用户量</th><th>全部内存量</th></tr></thead><tbody><tr><td>set</td><td>32位(假设userid是整形，占32位)</td><td>5千万</td><td>32位*5千万=200MB</td></tr><tr><td>bitmap</td><td>1位</td><td>1亿</td><td>1位*1亿=12.5MB</td></tr></tbody></table><p>假设有10万独立用户，使用位图还是占用12.5mb，使用set需要32位*1万=4MB</p><h3 id="4-5-总结"><a href="#4-5-总结" class="headerlink" title="4.5 总结"></a>4.5 总结</h3><p>1 位图类型是string类型，最大512M</p><p>2 使用setbit时偏移量如果过大，会有较大消耗</p><p>3 位图不是绝对好用，需要合理使用</p><h2 id="五-HyperLogLog"><a href="#五-HyperLogLog" class="headerlink" title="五 HyperLogLog"></a>五 HyperLogLog</h2><h3 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h3><p>基于HyperLogLog算法：极小的空间完成独立数量统计</p><p>本质还是字符串</p><h3 id="5-2-三个命令"><a href="#5-2-三个命令" class="headerlink" title="5.2 三个命令"></a>5.2 三个命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pfadd key element <span class="comment">#向hyperloglog添加元素,可以同时添加多个</span></span><br><span class="line">pfcount key <span class="comment">#计算hyperloglog的独立总数</span></span><br><span class="line">pfmerge destroy sourcekey1 sourcekey2<span class="comment">#合并多个hyperloglog，把sourcekey1和sourcekey2合并为destroy</span></span><br><span class="line"></span><br><span class="line">pfadd uuids <span class="string">"uuid1"</span> <span class="string">"uuid2"</span> <span class="string">"uuid3"</span> <span class="string">"uuid4"</span> <span class="comment">#向uuids中添加4个uuid</span></span><br><span class="line">pfcount uuids <span class="comment">#返回4</span></span><br><span class="line">pfadd uuids <span class="string">"uuid1"</span> <span class="string">"uuid5"</span><span class="comment">#有一个之前存在了，其实只把uuid5添加了</span></span><br><span class="line">pfcount uuids <span class="comment">#返回5</span></span><br><span class="line"></span><br><span class="line">pfadd uuids1 <span class="string">"uuid1"</span> <span class="string">"uuid2"</span> <span class="string">"uuid3"</span> <span class="string">"uuid4"</span></span><br><span class="line">pfadd uuids2 <span class="string">"uuid3"</span> <span class="string">"uuid4"</span> <span class="string">"uuid5"</span> <span class="string">"uuid6"</span></span><br><span class="line">pfmerge uuidsall uuids1 uuids2 <span class="comment">#合并</span></span><br><span class="line">pfcount uuidsall <span class="comment">#统计个数 返回6</span></span><br></pre></td></tr></table></figure><h3 id="5-3-内存消耗-amp-总结"><a href="#5-3-内存消耗-amp-总结" class="headerlink" title="5.3 内存消耗&amp;总结"></a>5.3 内存消耗&amp;总结</h3><p>百万级别独立用户统计，百万条数据只占15k</p><p>错误率 0.81%</p><p>无法取出单条数据，只能统计个数</p><h2 id="六-GEO"><a href="#六-GEO" class="headerlink" title="六 GEO"></a>六 GEO</h2><h3 id="6-1-介绍"><a href="#6-1-介绍" class="headerlink" title="6.1 介绍"></a>6.1 介绍</h3><p>GEO（地理信息定位）：存储经纬度，计算两地距离，范围等</p><p>北京：116.28，39.55</p><p>天津：117.12，39.08</p><p>可以计算天津到北京的距离，天津周围50km的城市，外卖等</p><h3 id="6-2-5个城市纬度"><a href="#6-2-5个城市纬度" class="headerlink" title="6.2 5个城市纬度"></a>6.2 5个城市纬度</h3><table><thead><tr><th>城市</th><th>经度</th><th>纬度</th><th>简称</th></tr></thead><tbody><tr><td>北京</td><td>116.28</td><td>39.55</td><td>beijing</td></tr><tr><td>天津</td><td>117.12</td><td>39.08</td><td>tianjin</td></tr><tr><td>石家庄</td><td>114.29</td><td>38.02</td><td>shijiazhuang</td></tr><tr><td>唐山</td><td>118.01</td><td>39.38</td><td>tangshan</td></tr><tr><td>保定</td><td>115.29</td><td>38.51</td><td>baoding</td></tr></tbody></table><h3 id="6-3-相关命令"><a href="#6-3-相关命令" class="headerlink" title="6.3 相关命令"></a>6.3 相关命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member <span class="comment">#增加地理位置信息</span></span><br><span class="line">geoadd cities:locations <span class="number">116.28</span> <span class="number">39.55</span> beijing <span class="comment">#把北京地理信息天津到cities:locations中</span></span><br><span class="line">geoadd cities:locations <span class="number">117.12</span> <span class="number">39.08</span> tianjin</span><br><span class="line">geoadd cities:locations <span class="number">114.29</span> <span class="number">38.02</span> shijiazhuang</span><br><span class="line">geoadd cities:locations <span class="number">118.01</span> <span class="number">39.38</span> tangshan</span><br><span class="line">geoadd cities:locations <span class="number">115.29</span> <span class="number">38.51</span> baoding</span><br><span class="line">    </span><br><span class="line">geopos key member <span class="comment">#获取地理位置信息</span></span><br><span class="line">geopos cities:locations beijing <span class="comment">#获取北京地理信息</span></span><br><span class="line"></span><br><span class="line">geodist key member1 member2 [unit]<span class="comment">#获取两个地理位置的距离 unit:m(米) km(千米) mi(英里) ft(尺)</span></span><br><span class="line">geodist cities:locations beijing tianjin km <span class="comment">#北京到天津的距离，89公里</span></span><br><span class="line"></span><br><span class="line">georadius key logitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line"></span><br><span class="line">georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line"><span class="comment">#获取指定位置范围内的地理位置信息集合</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">withcoord:返回结果中包含经纬度</span></span><br><span class="line"><span class="string">withdist：返回结果中包含距离中心节点位置</span></span><br><span class="line"><span class="string">withhash：返回解雇中包含geohash</span></span><br><span class="line"><span class="string">COUNT count：指定返回结果的数量</span></span><br><span class="line"><span class="string">asc|desc：返回结果按照距离中心店的距离做升序/降序排列</span></span><br><span class="line"><span class="string">store key：将返回结果的地理位置信息保存到指定键</span></span><br><span class="line"><span class="string">storedist key：将返回结果距离中心点的距离保存到指定键</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">georadiusbymember cities:locations beijing <span class="number">150</span> km</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">1) "beijing"</span></span><br><span class="line"><span class="string">2) "tianjin"</span></span><br><span class="line"><span class="string">3) "tangshan"</span></span><br><span class="line"><span class="string">4) "baoding"</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>3.2以后版本才有</p><p>geo本质时zset类型</p><p>可以使用zset的删除，删除指定member：zrem </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member #增加地理位置信息</span><br><span class="line">geoadd cities:locations 116.28 39.55 beijing #把北京地理信息天津到cities:locations中</span><br><span class="line">geoadd cities:locations 117.12 39.08 tianjin</span><br><span class="line">geoadd cities:locations 114.29 38.02 shijiazhuang</span><br><span class="line">geoadd cities:locations 118.01 39.38 tangshan</span><br><span class="line">geoadd cities:locations 115.29 38.51 baoding</span><br><span class="line">    </span><br><span class="line">geopos key member #获取地理位置信息</span><br><span class="line">geopos cities:locations beijing #获取北京地理信息</span><br><span class="line"></span><br><span class="line">geodist key member1 member2 [unit]#获取两个地理位置的距离 unit:m(米) km(千米) mi(英里) ft(尺)</span><br><span class="line">geodist cities:locations beijing tianjin km #北京到天津的距离，89公里</span><br><span class="line"></span><br><span class="line">georadius key logitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line"></span><br><span class="line">georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line">#获取指定位置范围内的地理位置信息集合</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">withcoord:返回结果中包含经纬度</span><br><span class="line">withdist：返回结果中包含距离中心节点位置</span><br><span class="line">withhash：返回解雇中包含geohash</span><br><span class="line">COUNT count：指定返回结果的数量</span><br><span class="line">asc|desc：返回结果按照距离中心店的距离做升序&#x2F;降序排列</span><br><span class="line">store key：将返回结果的地理位置信息保存到指定键</span><br><span class="line">storedist key：将返回结果距离中心点的距离保存到指定键</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">georadiusbymember cities:locations beijing 150 km</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">1) &quot;beijing&quot;</span><br><span class="line">2) &quot;tianjin&quot;</span><br><span class="line">3) &quot;tangshan&quot;</span><br><span class="line">4) &quot;baoding&quot;</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure><h3 id="6-4-总结-1"><a href="#6-4-总结-1" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>3.2以后版本才有</p><p>geo本质时zset类型</p><p>可以使用zset的删除，删除指定member：zrem </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">geoadd key longitude latitude member #增加地理位置信息</span><br><span class="line">geoadd cities:locations 116.28 39.55 beijing #把北京地理信息天津到cities:locations中</span><br><span class="line">geoadd cities:locations 117.12 39.08 tianjin</span><br><span class="line">geoadd cities:locations 114.29 38.02 shijiazhuang</span><br><span class="line">geoadd cities:locations 118.01 39.38 tangshan</span><br><span class="line">geoadd cities:locations 115.29 38.51 baoding</span><br><span class="line">    </span><br><span class="line">geopos key member #获取地理位置信息</span><br><span class="line">geopos cities:locations beijing #获取北京地理信息</span><br><span class="line"></span><br><span class="line">geodist key member1 member2 [unit]#获取两个地理位置的距离 unit:m(米) km(千米) mi(英里) ft(尺)</span><br><span class="line">geodist cities:locations beijing tianjin km #北京到天津的距离，89公里</span><br><span class="line"></span><br><span class="line">georadius key logitude latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line"></span><br><span class="line">georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key][storedist key]</span><br><span class="line">#获取指定位置范围内的地理位置信息集合</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">withcoord:返回结果中包含经纬度</span><br><span class="line">withdist：返回结果中包含距离中心节点位置</span><br><span class="line">withhash：返回解雇中包含geohash</span><br><span class="line">COUNT count：指定返回结果的数量</span><br><span class="line">asc|desc：返回结果按照距离中心店的距离做升序&#x2F;降序排列</span><br><span class="line">store key：将返回结果的地理位置信息保存到指定键</span><br><span class="line">storedist key：将返回结果距离中心点的距离保存到指定键</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">georadiusbymember cities:locations beijing 150 km</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">1) &quot;beijing&quot;</span><br><span class="line">2) &quot;tianjin&quot;</span><br><span class="line">3) &quot;tangshan&quot;</span><br><span class="line">4) &quot;baoding&quot;</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure><h3 id="6-4-总结-2"><a href="#6-4-总结-2" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><p>3.2以后版本才有</p><p>geo本质时zset类型</p><p>可以使用zset的删除，删除指定member：zrem cities:locations beijing</p>]]></content>
    
    <summary type="html">
    
      生命周期,我们配置一个时间，如果查询时间超过了我们设置的时间，我们就认为这是一个慢查询,慢查询发生在第三阶段,客户端超时不一定慢查询，但慢查询是客户端超时的一个可能因素...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
</feed>
