<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lupinus</title>
  
  <subtitle>Re：从零开始的go学习生活(｀・ω・´)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-07-21T23:45:34.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lupinus</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[「直击面试」搞定计算机网络]</title>
    <link href="http://yoursite.com/2022/07/22/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2022/07/22/%E6%90%9E%E5%AE%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</id>
    <published>2022-07-21T23:45:33.000Z</published>
    <updated>2022-07-21T23:45:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在浏览器中输入一个 URL 至页面呈现，网络上都发生了什么事？</p><p>能说说 ISO 七层模型和 TCP/IP 四层模型吗？</p><p>TCP/IP 与 HTTP 有什么关系吗？</p><p>TCP协议与UDP协议的区别？</p><p>请详细介绍一下 TCP 的三次握手机制，为什么要三次握手？挥手却又是四次呢？</p><p>详细讲一下TCP的滑动窗口？知道流量控制和拥塞控制吗？</p><p>说一下对称加密与非对称加密？</p><p>状态码 206 是什么意思？</p><p>你们用的 https 是吧，https 工作原理是什么？</p><p>……</p></blockquote><blockquote><p>成长手册，<strong>GitHub</strong> <a href="https://github.com/rogerXS80/roger" target="_blank" rel="noopener">Lupinus</a> ，N线互联网开发必备技能兵器谱</p></blockquote><h2 id="一、计算机网络"><a href="#一、计算机网络" class="headerlink" title="一、计算机网络"></a>一、计算机网络</h2><h3 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h3><p>通信协议（communications protocol）是指双方实体完成通信或服务所必须遵循的规则和约定。通过通信信道和设备互连起来的多个不同地理位置的数据通信系统，要使其能协同工作实现信息交换和资源共享，它们之间必须具有共同的语言。交流什么、怎样交流及何时交流，都必须遵循某种互相都能接受的规则。这个规则就是通信协议。</p><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>随着技术的发展，计算机的应用越来越广泛，计算机之间的通信开始了百花齐放的状态，每个具有独立计算服务体系的信息技术公司都会建立自己的计算机通信规则，而这种情况会导致异构计算机之间无法通信，极大的阻碍了网络通信的发展，至此为了解决这个问题，国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，OSI模型把网络通信的工作分为7层，分别是<strong>物理层、数据链路层、网络层、传输层、会话层、表示层和应用层</strong>。</p><p>这七层模型是设计层面的概念，每一层都有固定要完成的职责和功能，分层的好处在于清晰和功能独立性，但分层过多会使层次变的更加复杂，虽然不需要实现本层的功能，但是也需要构造本层的上下文，空耗系统资源，所以在落地实施网络通信模型的时候将这七层模型简化合并为四层模型分别是<strong>应用层、传输层、网络层、网络接口层</strong>（各层之间的模型、协议统称为：<strong>TCP/IP协议簇</strong>）。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed7719799d.jpg" alt=""></p><p>从上图可以看到，TCP/IP模型合并了OSI模型的应用层、表示层和会话层，将OSI模型的数据链路层和物理层合并为网络访问层。</p><p>上图还列出了各层模型对应TCP/IP协议栈中的协议以及各层协议之间的关系。比如DNS协议是建立在TCP和UDP协议的基础上，FTP、HTTP、TELNET协议建立在TCP协议的基础上，NTP、TFTP、SNMP建立在UDP协议的基础上，而TCP、UDP协议又建立在IP协议的基础上，以此类推….</p><table><thead><tr><th align="left">OSI中的层</th><th>功能</th><th align="left">TCP/IP协议族</th></tr></thead><tbody><tr><td align="left"><strong>应用层</strong></td><td>文件传输，电子邮件，文件服务，虚拟终端</td><td align="left">TFTP，HTTP，SNMP，FTP，SMTP，DNS，RIP，Telnet</td></tr><tr><td align="left"><strong>表示层</strong></td><td>数据格式化，代码转换，数据加密</td><td align="left">无</td></tr><tr><td align="left"><strong>会话层</strong></td><td>控制应用程序之间会话能力；如不同软件数据分发给不同软件</td><td align="left">ASAP、TLS、SSH、ISO 8327 / CCITT X.225、RPC、NetBIOS、ASP、Winsock、BSD sockets</td></tr><tr><td align="left"><strong>传输层</strong></td><td>端到端传输数据的基本功能</td><td align="left">TCP、UDP</td></tr><tr><td align="left"><strong>网络层</strong></td><td>定义IP编址，定义路由功能；如不同设备的数据转发</td><td align="left">IP，ICMP，RIP，OSPF，BGP，IGMP</td></tr><tr><td align="left"><strong>数据链路层</strong></td><td>定义数据的基本格式，如何传输，如何标识</td><td align="left">SLIP，CSLIP，PPP，ARP，RARP，MTU</td></tr><tr><td align="left"><strong>物理层</strong></td><td>以<strong>二进制</strong>数据形式在物理媒体上传输数据</td><td align="left">ISO2110，IEEE802</td></tr></tbody></table><p>当我们某一个网站上不去的时候。通常会ping一下这个网站</p><p><code>ping</code> 可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用<code>ping</code>命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p><h2 id="二、TCP-IP"><a href="#二、TCP-IP" class="headerlink" title="二、TCP/IP"></a>二、TCP/IP</h2><p>数据在网络中传输最终一定是通过物理介质传输。物理介质就是把电脑连接起来的物理手段，常见的有光纤、双绞线，以及无线电波，它决定了电信号(0和1)的传输方式，物理介质的不同决定了电信号的传输带宽、速率、传输距离以及抗干扰性等等。网络数据传输就像快递邮寄，数据就是快件。只有路打通了，你的”快递”才能送到，因此物理介质是网络通信的基石。</p><p>寄快递首先得称重、确认体积(确认数据大小)，贵重物品还得层层包裹填充物确保安全，封装，然后填写发件地址(源主机地址)和收件地址(目标主机地址)，确认快递方式。对于偏远地区，快递不能直达，还需要中途转发。网络通信也是一样的道理，只不过把这些步骤都规定成了各种协议。</p><p>TCP/IP的模型的每一层都需要下一层所提供的协议来完成自己的目的。我们来看下数据是怎么通过TCP/IP协议模型从一台主机发送到另一台主机的。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed76faefb0.jpg" alt=""></p><p>当用户通过HTTP协议发起一个请求，应用层、传输层、网络互联层和网络访问层的相关协议依次对该请求进行包装并携带对应的首部，最终在网络访问层生成以太网数据包，以太网数据包通过物理介质传输给对方主机，对方接收到数据包以后，然后再一层一层采用对应的协议进行拆包，最后把应用层数据交给应用程序处理。</p><h3 id="TCP-IP-与-HTTP"><a href="#TCP-IP-与-HTTP" class="headerlink" title="TCP/IP 与 HTTP"></a>TCP/IP 与 HTTP</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP 协议不仅仅指的是 TCP 和 IP 两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。</p><p><strong>而HTTP是应用层协议，主要解决如何包装数据。</strong></p><p>“IP”代表网际协议，TCP 和 UDP 使用该协议从一个网络传送数据包到另一个网络。把<strong>IP想像成一种高速公路</strong>，它允许其它协议在上面行驶并找到到其它电脑的出口。<strong>TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP</strong>，文件传输协议FTP这样的协议等。</p><h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><p>都属于传输层协议。</p><p>TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须有三次握手、四次挥手。</p><p>UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上</p><table><thead><tr><th align="left"></th><th align="left">TCP</th><th align="left">UDP</th></tr></thead><tbody><tr><td align="left">连接性</td><td align="left">面向连接</td><td align="left">面向非连接</td></tr><tr><td align="left">传输可靠性</td><td align="left">可靠</td><td align="left">不可靠</td></tr><tr><td align="left">报文</td><td align="left">面向字节流</td><td align="left">面向报文</td></tr><tr><td align="left">效率</td><td align="left">传输效率低</td><td align="left">传输效率高</td></tr><tr><td align="left">流量控制</td><td align="left">滑动窗口</td><td align="left">无</td></tr><tr><td align="left">拥塞控制</td><td align="left">慢开始、拥塞避免、快重传、快恢复</td><td align="left">无</td></tr><tr><td align="left">传输速度</td><td align="left">慢</td><td align="left">快</td></tr><tr><td align="left">应用场合</td><td align="left">对效率要求低，对准确性要求高或要求有连接的场景</td><td align="left">对效率要求高，对准确性要求低</td></tr></tbody></table><p>TCP和UDP协议的一些应用</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed76fa926f.jpg" alt=""></p><h3 id="TCP连接的建立与终止"><a href="#TCP连接的建立与终止" class="headerlink" title="TCP连接的建立与终止"></a>TCP连接的建立与终止</h3><p>TCP虽然是面向字节流的，但TCP传送的数据单元却是报文段。一个TCP报文段分为首部和数据两部分，而TCP的全部功能体现在它首部中的各字段的作用。</p><p>TCP报文段首部的前20个字节是固定的（下图），后面有4n字节是根据需要而增加的选项（n是整数）。因此TCP首部的最小长度是20字节。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed764405fc.jpg" alt=""></p><h4 id="TCP报文首部"><a href="#TCP报文首部" class="headerlink" title="TCP报文首部"></a>TCP报文首部</h4><ul><li><p>源端口和目的端口，各占2个字节，分别写入源端口和目的端口；</p></li><li><p><strong>序列号</strong>（Sequence number），占4字节。序号范围是【0，2^32 - 1】，共2^32个序号。序号增加到 2^32-1后，下一个序号就又回到 0。TCP是面向字节流的。在一个TCP连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是301，而接待的数据共有100字节。这就表明：本报文段的数据的第一个字节的序号是301，最后一个字节的序号是400。显然，下一个报文段（如果还有的话）的数据序号应当从401开始，即下一个报文段的序号字段值应为401。这个字段的序号也叫“报文段序号”;</p></li><li><p><strong>确认号</strong>（Acknowledge number），占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</p></li><li><p>数据偏移，占4位，它指出TCP报文段的数据起始处距离TCP报文段的起始处有多远。</p></li><li><p>保留，占6位，保留为今后使用，但目前应置为0；</p></li><li><p>紧急URG（URGent），当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</p></li><li><p>确认ACK（ACKnowledgment），仅当ACK=1时，确认号字段才有效。<strong>TCP规定，在连接建立后所有报文的传输都必须把ACK置1</strong>；</p></li><li><p>推送PSH（PuSH） ，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；</p></li><li><p>复位RST（ReSeT），当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；</p></li><li><p>同步SYN（SYNchronization），在连接建立时用来同步序号。<strong>当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1</strong>；</p></li><li><p>终止FIN（FINis），用来释放连接。</p><p>当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放</p><p>；</p><ul><li>窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</li></ul></li><li><p>检验和，占2字节，校验首部和数据这两部分；</p></li><li><p>紧急指针，占2字节，指出本报文段中的紧急数据的字节数；</p></li><li><p>选项，长度可变，定义一些其他的可选的参数</p></li></ul><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p><h4 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h4><p>所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/16/17180bed7721f0c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p><ul><li><p><strong>第一次握手</strong>(SYN=1, seq=x)</p><p>建立连接。客户端发送连接请求报文段，这是报文首部中的同步位SYN=1，同时选择一个初始序列号 seq=x ，此时，客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号；</p></li><li><p><strong>第二次握手</strong>(SYN=1, ACK=1, seq=y, ACKnum=x+1)</p><p>服务器收到客户端的SYN报文段，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号ACKnum=x+1，同时，自己还要发送SYN请求信息，SYN=1，为自己初始化一个序列号 seq=y，服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号</p></li><li><p><strong>第三次握手</strong>(ACK=1，ACKnum=y+1)</p><p>客户端收到服务器的SYN+ACK报文段，再次发送确认包(ACK)，<strong>SYN 标志位为0</strong>，ACK 标志位为1，确认号 ACKnum = y+1，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED（已建立连接）状态，完成TCP三次握手。</p></li></ul><blockquote><p>为什么需要三次握手呢？两次不行吗？</p></blockquote><p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p><p>具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p><h4 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h4><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。<strong>客户端或服务器均可主动发起挥手动作</strong>。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed772ce689.jpg" alt=""></p><ul><li><p>第一次挥手(FIN=1，seq=x)red</p><p>主机1（可以使客户端，也可以是服务器端），设置seq=x，向主机2发送一个FIN报文段；此时，主机1进入<font color=red size=4><code>FIN_WAIT_1</code></font>状态；这表示主机1没有数据要发送给主机2了；</p></li><li><p>第二次挥手(ACK=1，ACKnum=x+1)</p><p>主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknnum=x+1，主机1进入<font color=red size=4><code>FIN_WAIT_2</code></font>状态；主机2告诉主机1，我“同意”你的关闭请求；</p></li><li><p>第三次挥手(FIN=1，seq=y)</p><p>主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入<code>LAST_ACK</code> 状态</p></li><li><p>第四次挥手(ACK=1，ACKnum=y+1)</p><p>主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入<font color=red size=4><code>TIME_WAIT</code></font>状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，<strong>主机1等待2MSL后依然没有收到回复</strong>，则证明Server端已正常关闭，那好，主机1也可以关闭连接了，进入 <font color=red size=4><code>CLOSED</code></font> 状态。</p><p>主机 1 等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <font color=red size=4><code>CLOSED</code></font>  状态。</p></li></ul><blockquote><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？</p></blockquote><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。</p><p>由于 TCP 协议是全双工的，也就是说客户端和服务端都可以发起断开连接。两边各发起一次断开连接的申请，加上各自的两次确认，看起来就像执行了四次挥手。</p><blockquote><p><strong>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</strong></p></blockquote><p>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p><p>还有一个原因，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h3 id="TCP协议如何来保证传输的可靠性"><a href="#TCP协议如何来保证传输的可靠性" class="headerlink" title="TCP协议如何来保证传输的可靠性"></a>TCP协议如何来保证传输的可靠性</h3><p>对于可靠性，TCP通过以下方式进行保证：</p><ul><li>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；</li><li>对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；</li><li>丢弃重复数据：对于重复数据，能够丢弃重复数据；</li><li>应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</li><li>超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</li><li>流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。</li></ul><blockquote><p>详细讲一下TCP的滑动窗口</p></blockquote><h3 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h3><p>如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓<strong>流量控制</strong>就是让发送方的发送速率不要太快，要让接收方来得及接收。</p><p>利用<strong>滑动窗口机制</strong>可以很方便地在TCP连接上实现对发送方的流量控制。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9bb2cb0c.jpg" alt=""></p><p>从上面的图可以看到滑动窗口左边的是已发送并且被确认的分组，滑动窗口右边是还没有轮到的分组。滑动窗口里面也分为两块，一块是已经发送但是未被确认的分组，另一块是窗口内等待发送的分组。随着已发送的分组不断被确认，窗口内等待发送的分组也会不断被发送。整个窗口就会往右移动，让还没轮到的分组进入窗口内。</p><p>可以看到滑动窗口起到了一个限流的作用，也就是说当前滑动窗口的大小决定了当前 TCP 发送包的速率，而滑动窗口的大小取决于拥塞控制窗口和流量控制窗口的两者间的最小值。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>TCP 是全双工的，客户端和服务器均可作为发送方或接收方，我们现在假设一个发送方向接收方发送数据的场景来讲解流量控制。首先我们的接收方有一块接收缓存，当数据来到时会先把数据放到缓存中，上层应用等缓存中有数据时就会到缓存中取数据。假如发送方没有限制地不断地向接收方发送数据，接收方的应用程序又没有及时把接收缓存中的数据读走，就会出现缓存溢出，数据丢失的现象，为了解决这个问题，我们引入流量控制窗口。</p><p>假设应用程序最后读走的数据序号是 lastByteRead，接收缓存中接收到的最后一个数据序号是 lastByteRcv，接收缓存的大小为 RcvSize，那么必须要满足 lastByteRcv - lastByteRead &lt;= RcvSize 才能保证接收缓存不会溢出，所以我们定义流量窗口为接收缓存剩余的空间，也就是Rcv = RcvSize - (lastByteRcv - lastByteRead)。只要接收方在响应 ACK 的时候把这个窗口的值带给发送方，发送方就能知道接收方的接收缓存还有多大的空间，进而设置滑动窗口的大小。</p><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>拥塞控制是指发送方先设置一个小的窗口值作为发送速率，当成功发包并接收到ACK时，便以指数速率增大发送窗口的大小，直到遇到丢包（超时/三个冗余ACK），才停止并调整窗口的大小。这么做能最大限度地利用带宽，又不至于让网络环境变得太过拥挤。</p><p>最终滑动窗口的值将设置为流量控制窗口和拥塞控制窗口中的较小值。</p><h3 id="TCP的拥塞处理"><a href="#TCP的拥塞处理" class="headerlink" title="TCP的拥塞处理"></a>TCP的拥塞处理</h3><p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：</p><ol><li>慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</li><li>拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。          </li><li>快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。         </li><li>快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</li></ol><h3 id="服务器出现了大量CLOSE-WAIT状态如何解决"><a href="#服务器出现了大量CLOSE-WAIT状态如何解决" class="headerlink" title="服务器出现了大量CLOSE_WAIT状态如何解决"></a>服务器出现了大量CLOSE_WAIT状态如何解决</h3><p>大量 CLOSE_WAIT 表示程序出现了问题，对方的 socket 已经关闭连接，而我方忙于读或写没有及时关闭连接，需要检查代码，特别是释放资源的代码，或者是处理请求的线程配置。</p><h3 id="讲一讲SYN超时，洪泛攻击，以及解决策略"><a href="#讲一讲SYN超时，洪泛攻击，以及解决策略" class="headerlink" title="讲一讲SYN超时，洪泛攻击，以及解决策略"></a>讲一讲SYN超时，洪泛攻击，以及解决策略</h3><p>什么 SYN 是洪泛攻击？ 在 TCP 的三次握手机制的第一步中，客户端会向服务器发送 SYN 报文段。服务器接收到 SYN 报文段后会为该TCP分配缓存和变量，如果攻击分子大量地往服务器发送 SYN 报文段，服务器的连接资源终将被耗尽，导致内存溢出无法继续服务。</p><p>解决策略： 当服务器接受到 SYN 报文段时，不直接为该 TCP 分配资源，而只是打开一个半开的套接字。接着会使用 SYN 报文段的源Id，目的Id，端口号以及只有服务器自己知道的一个秘密函数生成一个 cookie，并把 cookie 作为序列号响应给客户端。</p><p>如果客户端是正常建立连接，将会返回一个确认字段为 cookie + 1 的报文段。接下来服务器会根据确认报文的源Id，目的Id，端口号以及秘密函数计算出一个结果，如果结果的值 + 1等于确认字段的值，则证明是刚刚请求连接的客户端，这时候才为该 TCP 分配资源</p><p>这样一来就不会为恶意攻击的 SYN 报文段分配资源空间，避免了攻击。</p><h2 id="三、HTTP"><a href="#三、HTTP" class="headerlink" title="三、HTTP"></a>三、HTTP</h2><blockquote><p>HTTP1.0、HTTP1.1、HTTP2.0 的区别</p><p>post 和 get 的区别</p></blockquote><p>HTTP全称是 HyperText Transfer Protocal，即：超文本传输协议。是互联网上应用最为广泛的一种<strong>网络通信协议</strong>，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。目前我们使用的是<strong>HTTP/1.1 版本</strong>。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext），这成为了HTTP超文本传输协议标准架构的发展根基。</p><h3 id="URI-和-URL"><a href="#URI-和-URL" class="headerlink" title="URI 和 URL"></a>URI 和 URL</h3><p>每个Web 服务器资源都有一个名字，这样客户端就可以说明他们感兴趣的资源是什么了，服务器资源名被称为统一资源标识符（Uniform Resource Identifier,URI）。URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源。</p><p>统一资源定位符（URL）是资源标识符最常见的形式。 URL 描述了一台特定服务器上某资源的特定位置。</p><p>现在几乎所有的 URI 都是 URL。</p><p>URI 的第二种形式就是统一资源名（URN）。URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。 </p><h3 id="HTTP消息的结构"><a href="#HTTP消息的结构" class="headerlink" title="HTTP消息的结构"></a>HTTP消息的结构</h3><p><strong>事务和报文</strong></p><p>客户端是怎样通过HTTP与Web服务器及其资源进行事务处理的呢？一个<strong>HTTP事务</strong>由一条请求命令（从客户端发往服务器）和一个响应（从服务器发回客户端）结果组成。这种通信是通过名为<strong>HTTP报文</strong>（HTTP Message）的格式化数据块进行的。</p><h4 id="HTTP事务："><a href="#HTTP事务：" class="headerlink" title="HTTP事务："></a>HTTP事务：</h4><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9d208228.jpg" alt=""></p><h4 id="报文："><a href="#报文：" class="headerlink" title="报文："></a>报文：</h4><p>HTTP 报文是纯文本，不是二进制代码。从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180beda8938bd4.jpg" alt=""></p><p>HTTP 报文包括三部分：</p><ul><li>起始行</li><li>首部字段</li><li>主体</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Http协议定义了很多与服务器交互的方法，最基本的有4种，分别是<strong>GET,POST,PUT,DELETE</strong>. 一个URL地址用于描述一个网络上的资源，而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，改，增，删4个操作。 我们最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</p><ul><li>GET</li><li>HEAD</li><li>PUT</li><li>POST</li><li>TRACE</li><li>OPTIONS</li><li>DELETE</li></ul><h3 id="Get与POST的区别"><a href="#Get与POST的区别" class="headerlink" title="Get与POST的区别"></a>Get与POST的区别</h3><p>GET与POST是我们常用的两种HTTP Method，二者之间的区别主要包括如下五个方面：</p><ol><li>从功能上讲，GET一般用来从服务器上获取资源，POST一般用来更新服务器上的资源；</li><li>从REST服务角度上说，GET是幂等的，即读取同一个资源，总是得到相同的数据，而POST不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</li><li>从请求参数形式上看，GET请求的数据会附在URL之后，即将请求数据放置在HTTP报文的 请求头 中，以?分割URL和传输数据，参数之间以&amp;相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII)；而POST请求会把提交的数据则放置在是HTTP请求报文的 请求体 中。</li><li>就安全性而言，POST的安全性要比GET的安全性高，因为GET请求提交的数据将明文出现在URL上，而且POST请求参数则被包装到请求体中，相对更安全。</li><li>从请求的大小看，GET请求的长度受限于浏览器或服务器对URL长度的限制，允许发送的数据量比较小，而POST请求则是没有大小限制的。</li></ol><p>HTTP请求结构： 请求方式 + 请求URI + 协议及其版本</p><p>HTTP响应结构： 状态码 + 原因短语 + 协议及其版本</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>每条HTTP响应报文返回时都会携带一个状态码。状态码是一个三位数字的代码，告知客户端请求是否成功，或者是都需要采取其他动作。</p><ul><li>1xx：表明服务端接收了客户端请求，客户端继续发送请求；</li><li>2xx：客户端发送的请求被服务端成功接收并成功进行了处理；</li><li>3xx：服务端给客户端返回用于重定向的信息；</li><li>4xx：客户端的请求有非法内容；</li><li>5xx：服务端未能正常处理客户端的请求而出现意外错误。</li><li><strong>200 OK</strong>：表示从客户端发送给服务器的请求被正常处理并返回；</li><li><strong>204 No Content</strong>：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）</li><li><strong>206 Patial Content</strong>：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。</li><li><strong>301 Moved Permanently</strong>：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；</li><li><strong>302 Found</strong>：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；</li><li><strong>303 See Other</strong>：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源</li><li>304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；</li><li><strong>400 Bad Request</strong>:表示请求报文中存在语法错误；</li><li><strong>401 Unauthorized</strong>：经许可，需要通过HTTP认证；</li><li><strong>403 Forbidden</strong>：服务器拒绝该次访问（访问权限出现问题）</li><li><strong>404 Not Found</strong>：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；</li><li><strong>500 Inter Server Error</strong>：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；</li><li><strong>503 Server Unavailable</strong>：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；</li></ul><p>HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节，而是把这些细节都交给了通用可靠的因特网传输协议 TCP/IP。</p><p>在 HTTP 客户端向服务器发送报文之前，需要用网络协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条 TCP/IP 协议。而 IP 地址就是通过 URL 提供的，像<font color=red size=4><code>http://207.200.21.11:80/index.html</code></font> ，还有使用域名服务（Domain Name Services，DNS）的 <font color=red size=4><code>http://www.lazyegg.net</code></font>。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bed9f762409.jpg" alt=""></p><h3 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h3><ul><li><p><strong>HTTP/0.9</strong></p><p>HTTP协议的最初版本，功能简陋，仅支持 GET 方法，并且仅能请求访问 HTML 格式的资源</p></li><li><p><strong>HTTP/1.0</strong></p><ul><li>增加了请求方式 POST 和 HEAD</li><li>不再局限于0.9版本的HTML格式，根据Content-Type可以支持多种数据格式，即MIME多用途互联网邮件扩展，例如text/html、image/jpeg等</li><li>同时也开始支持 cache，就是当客户端在规定时间内访问统一网站，直接访问cache即可</li><li>HTTP请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等</li><li>但是1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive</li></ul></li><li><p><strong>HTTP/1.0+</strong></p><p>在20世纪90年代中叶，为满足飞快发展的万维网，很多流行的 Web 客户端和服务器飞快的向 HTTP 中添加各种特性，包括持久的 keep-alive 连接、虚拟主机支持，以及代理连接支持都被假如到 HTTP 中，并称为非官方的事实标准。这种非正式的 HTTP 扩展版本通常称为 HTTP/1.0+</p></li><li><p><strong>HTTP/1.1</strong></p><ul><li>http1.1是目前最为主流的http协议版本，从1997年发布至今，仍是主流的http协议版本。</li><li>引入了持久连接，或叫长连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。</li><li>引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。</li><li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</li><li>http协议不带有状态，每次请求都必须附上所有信息。请求的很多字段都是重复的，浪费带宽，影响速度。</li></ul></li><li><p><strong>HTTP/2.0（又名 HTTP-NG）</strong></p><ul><li>http/2发布于2015年，目前应用还比较少。</li><li>http/2是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</li><li>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，避免了队头堵塞的问题,此双向的实时通信称为多工（ Multiplexing）。</li><li>HTTP/2 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li><li>引入头信息压缩机制（ header compression） ,头信息使用gzip或compress压缩后再发送。</li></ul></li></ul><h2 id="四、HTTPS"><a href="#四、HTTPS" class="headerlink" title="四、HTTPS"></a>四、HTTPS</h2><p>HTTP缺点：</p><ol><li>通信使用明文不对数据进行加密（内容容易被窃听）</li><li>不验证通信方身份（容易伪装）</li><li>无法确定报文完整性（内容易被篡改）</li></ol><p>因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p><p>为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议 HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL（安全套接层）协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><p><strong>与 SSL（安全套接层）组合使用的 HTTP 就是 HTTPS</strong></p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedb27f3f29.jpg" alt=""></p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedb8848bf2.jpg" alt=""></p><h3 id="HTTP和HTTPS对比"><a href="#HTTP和HTTPS对比" class="headerlink" title="HTTP和HTTPS对比"></a>HTTP和HTTPS对比</h3><p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p><p>HTTPS和HTTP的区别主要如下：</p><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><h3 id="对称加密与非对称加密"><a href="#对称加密与非对称加密" class="headerlink" title="对称加密与非对称加密"></a>对称加密与非对称加密</h3><p>主要的加密方法分为两种：一种是共享密钥加密（对称密钥加密），一种是公开密钥加密（非对称密钥加密）</p><h4 id="共享密钥加密-对称秘钥加密"><a href="#共享密钥加密-对称秘钥加密" class="headerlink" title="共享密钥加密(对称秘钥加密)"></a>共享密钥加密(对称秘钥加密)</h4><p>加密与解密使用同一个密钥，常见的对称加密算法：DES，AES，3DES等。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedbd853fe2.jpg" alt=""></p><p>也就是说在加密的同时，也会把密钥发送给对方。在发送密钥过程中可能会造成密钥被窃取，那么如何解决这一问题呢？</p><h4 id="公开密钥（非对称密钥）"><a href="#公开密钥（非对称密钥）" class="headerlink" title="公开密钥（非对称密钥）"></a>公开密钥（非对称密钥）</h4><p>公开密钥使用一对非对称密钥。一把叫私有密钥，另一把叫公开密钥。私有密钥不让任何人知道，公有密钥随意发送。公钥加密的信息，只有私钥才能解密。常见的非对称加密算法：RSA，ECC等。</p><p>也就是说，发送密文方使用对方的公开密钥进行加密，对方接受到信息后，使用私有密钥进行解密。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bede10f9420.jpg" alt=""></p><p>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。</p><p>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。</p><p>为了解决这一问题，https采用对称加密与非对称加密的混合加密方式。</p><h3 id="SSL-TSL"><a href="#SSL-TSL" class="headerlink" title="SSL/TSL"></a>SSL/TSL</h3><p>SSL（Secure Sockets Layer），中文叫做“安全套接层”。它是在上世纪90年代中期，由网景公司设计的。</p><p>SSL 协议就是用来解决 HTTP 传输过程的不安全问题，到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。</p><p>很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。</p><p>SSL/TLS协议的基本思路是采用<a href="http://en.wikipedia.org/wiki/Public-key_cryptography" target="_blank" rel="noopener">公钥加密法</a>，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p><p>但是，这里有两个问题。</p><ul><li><p><strong>如何保证公钥不被篡改？</strong></p><p>解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。</p></li><li><p><strong>公钥加密计算量太大，如何减少耗用的时间？</strong></p><p>每一次对话（session），客户端和服务器端都生成一个”对话密钥”（session key），用它来加密信息。由于”对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”对话密钥”本身，这样就减少了加密运算的消耗时间。</p></li></ul><p>因此，SSL/TLS协议的基本过程是这样的：</p><ol><li>服务端将非对称加密的公钥发送给客户端；</li><li>客户端拿着服务端发来的公钥，对对称加密的key做加密并发给服务端；</li><li>服务端拿着自己的私钥对发来的密文解密，从来获取到对称加密的key；</li><li>二者利用对称加密的key对需要传输的消息做加解密传输。</li></ol><p>HTTPS相比HTTP，在请求前多了一个「握手」的环节。</p><p>握手过程中确定了数据加密的密码。在握手过程中，网站会向浏览器发送 SSL 证书，SSL 证书和我们日常用的身份证类似，是一个支持 HTTPS 网站的身份证明，SSL 证书里面包含了网站的域名，证书有效期，证书的颁发机构以及用于加密传输密码的公钥等信息，由于公钥加密的密码只能被在申请证书时生成的私钥解密，因此浏览器在生成密码之前需要先核对当前访问的域名与证书上绑定的域名是否一致，同时还要对证书的颁发机构进行验证，如果验证失败浏览器会给出证书错误的提示。</p><h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedc063a776.jpg" alt=""></p><p>实际上，我们使用的证书分很多种类型，SSL证书只是其中的一种。证书的格式是由 X.509 标准定义。SSL 证书负责传输公钥，是一种PKI（Public Key Infrastructure，公钥基础结构）证书。</p><p>我们常见的证书根据用途不同大致有以下几种：</p><ol><li>SSL证书，用于加密HTTP协议，也就是HTTPS。</li><li>代码签名证书，用于签名二进制文件，比如Windows内核驱动，Firefox插件，Java代码签名等等。</li><li>客户端证书，用于加密邮件。</li><li>双因素证书，网银专业版使用的USB Key里面用的就是这种类型的证书。</li></ol><p>这些证书都是由受认证的证书颁发机构——我们称之为CA（Certificate Authority）机构来颁发，针对企业与个人的不同，可申请的证书的类型也不同，价格也不同。CA机构颁发的证书都是受信任的证书，对于 SSL 证书来说，如果访问的网站与证书绑定的网站一致就可以通过浏览器的验证而不会提示错误。</p><p><strong>为什么服务端要发送证书给客户端</strong></p><p>互联网有太多的服务需要使用证书来验证身份，以至于客户端(操作系统或浏览器等)无法内置所有证书，需要通过服务端将证书发送给客户端。</p><p><strong>客户端为什么要验证接收到的证书</strong></p><p>中间人攻击</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">客户端&lt;------------攻击者&lt;------------服务端</span><br><span class="line">        伪造证书            拦截请求</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p><strong>客户端如何验证接收到的证书</strong></p><p>为了回答这个问题，需要引入数字签名(Digital Signature)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| A digital signature |</span><br><span class="line">|(not to be confused  |</span><br><span class="line">|with a digital       |</span><br><span class="line">|certificate)         |            +---------+              +--------+</span><br><span class="line">| is a mathematical   |----哈希---&gt;| 消息摘要  |---私钥加密---&gt;| 数字签名 |</span><br><span class="line">|technique used       |            +---------+              +--------+</span><br><span class="line">|to validate the      |</span><br><span class="line">|authenticity and     |</span><br><span class="line">|integrity of a       |</span><br><span class="line">|message, software    |</span><br><span class="line">|or digital document. |</span><br><span class="line">+---------------------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>将一段文本通过哈希（hash）和私钥加密处理后生成数字签名。</p><p>假设消息传递在Bob，Susan和Pat三人之间发生。Susan将消息连同数字签名一起发送给Bob，Bob接收到消息后，可以这样验证接收到的消息就是Susan发送的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| A digital signature |</span><br><span class="line">|(not to be confused  |</span><br><span class="line">|with a digital       |</span><br><span class="line">|certificate)         |            +---------+</span><br><span class="line">| is a mathematical   |----哈希---&gt;|  消息摘要 |</span><br><span class="line">|technique used       |            +---------+</span><br><span class="line">|to validate the      |                 |</span><br><span class="line">|authenticity and     |                 |</span><br><span class="line">|integrity of a       |                 |</span><br><span class="line">|message, software    |                 对</span><br><span class="line">|or digital document. |                 比</span><br><span class="line">+---------------------+                 |</span><br><span class="line">                                        |</span><br><span class="line">                                        |</span><br><span class="line">          +--------+               +---------+</span><br><span class="line">          | 数字签名 |---公钥解密---&gt;|  消息摘要 |</span><br><span class="line">          +--------+               +---------+</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>当然，这个前提是Bob知道Susan的公钥。更重要的是，和消息本身一样，公钥不能在不安全的网络中直接发送给Bob。此时就引入了<a href="https://en.wikipedia.org/wiki/Certificate_authority" target="_blank" rel="noopener">证书颁发机构</a>（Certificate Authority，简称CA），CA数量并不多，Bob客户端内置了所有受信任CA的证书。CA对Susan的公钥（和其他信息）数字签名后生成证书。</p><p>Susan将证书发送给Bob后，Bob通过CA证书的公钥验证证书签名。</p><p>Bob信任CA，CA信任Susan 使得 Bob信任Susan，<a href="https://en.wikipedia.org/wiki/Chain_of_trust" target="_blank" rel="noopener">信任链</a>（Chain Of Trust）就是这样形成的。</p><p>事实上，Bob客户端内置的是CA的根证书(Root Certificate)，HTTPS协议中服务器会发送证书链（Certificate Chain）给客户端。</p><h3 id="HTTPS的工作原理"><a href="#HTTPS的工作原理" class="headerlink" title="HTTPS的工作原理"></a>HTTPS的工作原理</h3><ol><li>Client 使用https的URL访问 Server，要求与 Server 建立 SSL 连接</li><li>Server 把事先配置好的公钥证书返回给客户端。</li><li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</li><li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</li><li>Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</li><li>Server使用对称密钥加密“明文内容A”，发送给Client。</li><li>Client使用对称密钥解密响应的密文，得到“明文内容A”。</li><li>Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</li></ol><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedeeb2c715.jpg" alt=""></p><h3 id="HTTPS的优点"><a href="#HTTPS的优点" class="headerlink" title="HTTPS的优点"></a>HTTPS的优点</h3><p>尽管HTTPS并非绝对安全，掌握根证书的机构、掌握加密算法的组织同样可以进行中间人形式的攻击，但HTTPS仍是现行架构下最安全的解决方案，主要有以下几个好处：</p><ol><li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li><li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li><li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li></ol><h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><p>虽然说HTTPS有很大的优势，但其相对来说，还是存在不足之处的：</p><ol><li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电；</li><li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</li><li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</li><li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</li><li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行。</li></ol><h3 id="HTTP-切换到-HTTPS"><a href="#HTTP-切换到-HTTPS" class="headerlink" title="HTTP 切换到 HTTPS"></a>HTTP 切换到 HTTPS</h3><p>如果需要将网站从http切换到https到底该如何实现呢？</p><p>这里需要将页面中所有的链接，例如js，css，图片等等链接都由http改为https。例如：<a href="http://www.baidu.com改为https://www.baidu.com" target="_blank" rel="noopener">www.baidu.com改为https://www.baidu.com</a></p><p>BTW，这里虽然将http切换为了https，还是建议保留http。所以我们在切换的时候可以做http和https的兼容，具体实现方式是，去掉页面链接中的http头部，这样可以自动匹配http头和https头。例如：将 <a href="http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。" target="_blank" rel="noopener">http://www.baidu.com改为//www.baidu.com。然后当用户从http的入口进入访问页面时，页面就是http，如果用户是从https的入口进入访问页面，页面即使https的。</a></p><h3 id="什么是Cookie，Cookie的使用过程是怎么样的？"><a href="#什么是Cookie，Cookie的使用过程是怎么样的？" class="headerlink" title="什么是Cookie，Cookie的使用过程是怎么样的？"></a>什么是Cookie，Cookie的使用过程是怎么样的？</h3><p>由于 http 协议是无状态协议，如果客户通过浏览器访问 web 应用时没有一个保存用户访问状态的机制，那么将不能持续跟踪应用的操作。比如当用户往购物车中添加了商品，web 应用必须在用户浏览别的商品的时候仍保存购物车的状态，以便用户继续往购物车中添加商品。</p><p>cookie 是浏览器的一种缓存机制，它可用于维持客户端与服务器端之间的会话。由于下面一题会讲到session，所以这里要强调cookie会将会话保存在客户端（session则是把会话保存在服务端）</p><p>这里以最常见的登陆案例讲解cookie的使用过程：</p><ol><li>首先用户在客户端浏览器向服务器发起登陆请求</li><li>登陆成功后，服务端会把登陆的用户信息设置 cookie 中，返回给客户端浏览器</li><li>客户端浏览器接收到 cookie 请求后，会把 cookie 保存到本地（可能是内存，也可能是磁盘，看具体使用情况而定）</li><li>以后再次访问该 web 应用时，客户端浏览器就会把本地的 cookie 带上，这样服务端就能根据 cookie 获得用户信息了</li></ol><h3 id="什么是session，有哪些实现session的机制？"><a href="#什么是session，有哪些实现session的机制？" class="headerlink" title="什么是session，有哪些实现session的机制？"></a>什么是session，有哪些实现session的机制？</h3><p>session 是一种维持客户端与服务器端会话的机制。但是与 <strong>cookie 把会话信息保存在客户端本地不一样，session 把会话保留在浏览器端。</strong></p><p>我们同样以登陆案例为例子讲解 session 的使用过程：</p><ol><li>首先用户在客户端浏览器发起登陆请求</li><li>登陆成功后，服务端会把用户信息保存在服务端，并返回一个唯一的 session 标识给客户端浏览器。</li><li>客户端浏览器会把这个唯一的 session 标识保存在起来</li><li>以后再次访问 web 应用时，客户端浏览器会把这个唯一的 session 标识带上，这样服务端就能根据这个唯一标识找到用户信息。</li></ol><p>看到这里可能会引起疑问：把唯一的 session 标识返回给客户端浏览器，然后保存起来，以后访问时带上，这难道不是 cookie 吗？</p><p>没错，<strong>session 只是一种会话机制，在许多 web 应用中，session 机制就是通过 cookie 来实现的</strong>。也就是说它只是使用了 cookie 的功能，并不是使用 cookie 完成会话保存。与 cookie 在保存客户端保存会话的机制相反，session 通过 cookie 的功能把会话信息保存到了服务端。</p><p>进一步地说，session 是一种维持服务端与客户端之间会话的机制，它可以有不同的实现。以现在比较流行的小程序为例，阐述一个 session 的实现方案：</p><ol><li>首先用户登陆后，需要把用户登陆信息保存在服务端，这里我们可以采用 redis。比如说给用户生成一个 userToken，然后以 userId 作为键，以 userToken 作为值保存到 redis 中，并在返回时把 userToken 带回给小程序端。</li><li>小程序端接收到 userToken 后把它缓存起来，以后每当访问后端服务时就把 userToken 带上。</li><li>在后续的服务中服务端只要拿着小程序端带来的 userToken 和 redis 中的 userToken 进行比对，就能确定用户的登陆状态了。</li></ol><h3 id="session和cookie有什么区别"><a href="#session和cookie有什么区别" class="headerlink" title="session和cookie有什么区别"></a>session和cookie有什么区别</h3><p>经过上面两道题的阐述，这道题就很清晰了</p><ol><li>cookie 是浏览器提供的一种缓存机制，它可以用于维持客户端与服务端之间的会话</li><li>session 指的是维持客户端与服务端会话的一种机制，它可以通过 cookie 实现，也可以通过别的手段实现。</li><li>如果用 cookie 实现会话，那么会话会保存在客户端浏览器中</li><li>而 session 机制提供的会话是保存在服务端的。</li></ol><h2 id="Other-FAQ"><a href="#Other-FAQ" class="headerlink" title="Other FAQ     "></a>Other FAQ     </h2><h3 id="从输入网址到获得页面的过程"><a href="#从输入网址到获得页面的过程" class="headerlink" title="从输入网址到获得页面的过程"></a>从输入网址到获得页面的过程</h3><ol><li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ol><h3 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h3><p>XSS 是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。</p><p>          </p><h3 id="IP地址的分类"><a href="#IP地址的分类" class="headerlink" title="IP地址的分类"></a>IP地址的分类</h3><p>IP地址是指互联网协议地址，是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，其中A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址。</p><p>每个IP地址包括两个标识码（ID），即网络ID和主机ID。同一个物理网络上的所有主机都使用同一个网络ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机ID与其对应。A~E类地址的特点如下：</p><p>A类地址：以0开头，第一个字节范围：0~127；</p><p>B类地址：以10开头，第一个字节范围：128~191；</p><p>C类地址：以110开头，第一个字节范围：192~223；</p><p>D类地址：以1110开头，第一个字节范围为224~239；</p><p>E类地址：以1111开头，保留地址</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/17180bedf2021893.jpg" alt=""></p><h2 id="参考与感谢"><a href="#参考与感谢" class="headerlink" title="参考与感谢"></a>参考与感谢</h2><ul><li>《HTTP 权威指南》</li><li><a href="https://arch-long.cn/articles/network/OSI模型TCPIP协议栈.html" target="_blank" rel="noopener">arch-long.cn/articles/ne…</a></li><li><a href="https://blog.csdn.net/qq_32998153/article/details/79680704" target="_blank" rel="noopener">blog.csdn.net/qq_32998153…</a></li></ul>]]></content>
    
    <summary type="html">
    
      在浏览器中输入一个 URL 至页面呈现，网络上都发生了什么事？能说说 ISO 七层模型和 TCP/IP 四层模型吗？CP/IP 与 HTTP 有什么关系吗？...
    
    </summary>
    
    
      <category term="直击面试" scheme="http://yoursite.com/categories/%E7%9B%B4%E5%87%BB%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>[「直击面试」MySQL三万字精华总结]</title>
    <link href="http://yoursite.com/2022/06/22/MySQL%E4%B8%89%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2022/06/22/MySQL%E4%B8%89%E4%B8%87%E5%AD%97%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-21T23:46:33.000Z</published>
    <updated>2022-06-21T23:46:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://gitee.com/wjxyzs/img/raw/master/img/mysql%E6%94%BB%E7%95%A5.png" alt=""></p><blockquote><p>写在之前：不建议那种上来就是各种面试题罗列，然后背书式的去记忆，对技术的提升帮助很小，对正经面试也没什么帮助，有点东西的面试官深挖下就懵逼了。</p><p>个人建议把面试题看作是费曼学习法中的回顾、简化的环节，准备面试的时候，跟着题目先自己讲给自己听，看看自己会满意吗，不满意就继续学习这个点，如此反复，好的offer离你不远的，奥利给</p><p>……</p></blockquote><blockquote><p>成长手册，<strong>GitHub</strong> <a href="https://github.com/rogerXS80/roger" target="_blank" rel="noopener">Lupinus</a> ，N线互联网开发必备技能兵器谱</p></blockquote><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff308f75df1.jpg" alt=""></p><h2 id="一、MySQL架构"><a href="#一、MySQL架构" class="headerlink" title="一、MySQL架构"></a>一、MySQL架构</h2><p>和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，<strong>插件式的存储引擎架构将查询处理和其它的系统任务以及数据的存储提取相分离</strong>。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff308eb9e2d.jpg" alt=""></p><ul><li><strong>连接层</strong>：最上层是一些客户端和连接服务。<strong>主要完成一些类似于连接处理、授权认证、及相关的安全方案</strong>。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li><li><strong>服务层</strong>：第二层服务层，主要完成大部分的核心服务功能， 包括查询解析、分析、优化、缓存、以及所有的内置函数，所有跨存储引擎的功能也都在这一层实现，包括触发器、存储过程、视图等</li><li><strong>引擎层</strong>：第三层存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取</li><li><strong>存储层</strong>：第四层为数据存储层，主要是将数据存储在运行于该设备的文件系统之上，并完成与存储引擎的交互</li></ul><blockquote><p>画出 MySQL 架构图，这种变态问题都能问的出来MySQL 的查询流程具体是？or  一条SQL语句在MySQL中如何执行的？</p></blockquote><p>客户端请求 —&gt; 连接器（验证用户身份，给予权限） —&gt; 查询缓存（存在缓存则直接返回，不存在则执行后续操作） —&gt; 分析器（对SQL进行词法分析和语法分析操作） —&gt; 优化器（主要对执行的sql优化选择最优的执行方案方法） —&gt; 执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口） —&gt; 去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff309fc730f.jpg" alt=""></p><hr><blockquote><p>说说MySQL有哪些存储引擎？都有哪些区别？</p></blockquote><h2 id="二、存储引擎"><a href="#二、存储引擎" class="headerlink" title="二、存储引擎"></a>二、存储引擎</h2><p>存储引擎是MySQL的组件，用于处理不同表类型的SQL操作。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以获得特定的功能。</p><p>使用哪一种引擎可以灵活选择，<strong>一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求</strong>，使用合适的存储引擎，将会提高整个数据库的性能 。</p><p>MySQL服务器使用<strong>可插拔</strong>的存储引擎体系结构，可以从运行中的 MySQL 服务器加载或卸载存储引擎 。</p><h3 id="查看存储引擎"><a href="#查看存储引擎" class="headerlink" title="查看存储引擎"></a>查看存储引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看支持的存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ENGINES</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看默认存储引擎</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'storage_engine'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--查看具体某一个表所使用的存储引擎，这个默认存储引擎被修改了！</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> tablename</span><br><span class="line"></span><br><span class="line"><span class="comment">--准确查看某个数据库中的某一表所使用的存储引擎</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'tablename'</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">from</span> <span class="keyword">database</span> <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">"tablename"</span></span><br></pre></td></tr></table></figure><h3 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 建表时指定存储引擎。默认的就是INNODB，不需要设置</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = CSV;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t3 (i <span class="built_in">INT</span>) <span class="keyword">ENGINE</span> = <span class="keyword">MEMORY</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改存储引擎</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改默认存储引擎，也可以在配置文件my.cnf中修改默认引擎</span></span><br><span class="line"><span class="keyword">SET</span> default_storage_engine=NDBCLUSTER;</span><br></pre></td></tr></table></figure><p>默认情况下，每当 <code>CREATE TABLE</code> 或 <code>ALTER TABLE</code> 不能使用默认存储引擎时，都会生成一个警告。为了防止在所需的引擎不可用时出现令人困惑的意外行为，可以启用 <code>NO_ENGINE_SUBSTITUTION SQL</code> 模式。如果所需的引擎不可用，则此设置将产生错误而不是警告，并且不会创建或更改表</p><h3 id="存储引擎对比"><a href="#存储引擎对比" class="headerlink" title="存储引擎对比"></a>存储引擎对比</h3><p>常见的存储引擎就 InnoDB、MyISAM、Memory、NDB。</p><p>InnoDB 现在是 MySQL 默认的存储引擎，支持<strong>事务、行级锁定和外键</strong></p><h3 id="文件存储结构对比"><a href="#文件存储结构对比" class="headerlink" title="文件存储结构对比"></a>文件存储结构对比</h3><p>在 MySQL中建立任何一张数据表，在其数据目录对应的数据库目录下都有对应表的 <code>.frm</code> 文件，<code>.frm</code> 文件是用来保存每个数据表的元数据(meta)信息，包括表结构的定义等，与数据库存储引擎无关，也就是任何存储引擎的数据表都必须有<code>.frm</code>文件，命名方式为 数据表名.frm，如user.frm。</p><p>查看MySQL 数据保存在哪里：<code>show variables like &#39;data%&#39;</code></p><p>MyISAM 物理文件结构为：</p><ul><li><code>.frm</code>文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</li><li><code>.MYD</code> (<code>MYData</code>) 文件：MyISAM 存储引擎专用，用于存储MyISAM 表的数据</li><li><code>.MYI</code> (<code>MYIndex</code>)文件：MyISAM 存储引擎专用，用于存储MyISAM 表的索引相关信息</li></ul><p>InnoDB 物理文件结构为：</p><ul><li><p><code>.frm</code> 文件：与表相关的元数据信息都存放在frm文件，包括表结构的定义信息等</p></li><li><p><code>.ibd</code> 文件或 <code>.ibdata</code> 文件： 这两种文件都是存放 InnoDB 数据的文件，之所以有两种文件形式存放 InnoDB 的数据，是因为 InnoDB 的数据存储方式能够通过配置来决定是使用<strong>共享表空间</strong>存放存储数据，还是用<strong>独享表空间</strong>存放存储数据。</p><p>独享表空间存储方式使用<code>.ibd</code>文件，并且每个表一个<code>.ibd</code>文件 共享表空间存储方式使用<code>.ibdata</code>文件，所有表共同使用一个<code>.ibdata</code>文件（或多个，可自己配置）</p></li></ul><h3 id="面试这么回答"><a href="#面试这么回答" class="headerlink" title="面试这么回答"></a>面试这么回答</h3><ol><li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li><li>InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；</li><li>InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li><li>InnoDB 不保存表的具体行数，执行<code>select count(*) from table</code> 时需要全表扫描。而 MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；</li><li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；</li></ol><table><thead><tr><th align="center">对比项</th><th align="center">MyISAM</th><th align="center">InnoDB</th></tr></thead><tbody><tr><td align="center">主外键</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">单元格</td><td align="center">单元格</td><td align="center">单元格</td></tr><tr><td align="center">事务</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">行表锁</td><td align="center">表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td><td align="center">行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td></tr><tr><td align="center">缓存</td><td align="center">只缓存索引，不缓存真实数据</td><td align="center">不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td></tr><tr><td align="center">表空间</td><td align="center">小</td><td align="center">大</td></tr><tr><td align="center">关注点</td><td align="center">性能</td><td align="center">事务</td></tr><tr><td align="center">默认安装</td><td align="center">是</td><td align="center">是</td></tr></tbody></table><blockquote><p>一张表，里面有ID自增主键，当insert了17条记录之后，删除了第15,16,17条记录，再把Mysql重启，再insert一条记录，这条记录的ID是18还是15 ？</p></blockquote><p>如果表的类型是MyISAM，那么是18。因为MyISAM表会把自增主键的最大ID 记录到数据文件中，重启MySQL自增主键的最大ID也不会丢失；</p><p>如果表的类型是InnoDB，那么是15。因为InnoDB 表只是把自增主键的最大ID记录到内存中，所以重启数据库或对表进行OPTION操作，都会导致最大ID丢失。</p><blockquote><p>哪个存储引擎执行 select count(*) 更快，为什么?</p></blockquote><p>MyISAM更快，因为MyISAM内部维护了一个计数器，可以直接调取。</p><ul><li>在 MyISAM 存储引擎中，把表的总行数存储在磁盘上，当执行 select count(*) from t 时，直接返回总数据。</li><li>在 InnoDB 存储引擎中，跟 MyISAM 不一样，没有将总行数存储在磁盘上，当执行 select count(*) from t 时，会先把数据读出来，一行一行的累加，最后返回总数量。</li></ul><p>InnoDB 中 count(*) 语句是在执行的时候，全表扫描统计总数量，所以当数据越来越大时，语句就越来越耗时了，为什么 InnoDB 引擎不像 MyISAM 引擎一样，将总行数存储到磁盘上？这跟 InnoDB 的事务特性有关，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p><h2 id="三、数据类型"><a href="#三、数据类型" class="headerlink" title="三、数据类型"></a>三、数据类型</h2><p>主要包括以下五大类：</p><ul><li>整数类型：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li><li>浮点数类型：FLOAT、DOUBLE、DECIMAL</li><li>字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li><li>日期类型：Date、DateTime、TimeStamp、Time、Year</li><li>其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li></ul><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff30a28cf0d.jpg" alt=""></p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff309f9eea0.jpg" alt=""></p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff30a5e00fe.jpg" alt=""></p><blockquote><p>CHAR 和 VARCHAR 的区别？</p></blockquote><p>char是固定长度，varchar长度可变：</p><p>char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p><p>存储时，前者不管实际存储数据的长度，直接按 char 规定的长度分配存储空间；而后者会根据实际存储的数据分配最终的存储空间</p><p>相同点：</p><ol><li>char(n)，varchar(n)中的n都代表字符的个数</li><li>超过char，varchar最大长度n的限制后，字符串会被截断。</li></ol><p>不同点：</p><ol><li>char不论实际存储的字符数都会占用n个字符的空间，而varchar只会占用实际字符应该占用的字节空间加1（实际长度length，0&lt;=length&lt;255）或加2（length&gt;255）。因为varchar保存数据时除了要保存字符串之外还会加一个字节来记录长度（如果列声明长度大于255则使用两个字节来保存长度）。</li><li>能存储的最大空间限制不一样：char的存储上限为255字节。</li><li>char在存储时会截断尾部的空格，而varchar不会。</li></ol><p>char是适合存储很短的、一般固定长度的字符串。例如，char非常适合存储密码的MD5值，因为这是一个定长的值。对于非常短的列，char比varchar在存储空间上也更有效率。</p><blockquote><p>列的字符串类型可以是什么？</p></blockquote><p>字符串类型是：SET、BLOB、ENUM、CHAR、TEXT、VARCHAR</p><blockquote><p>BLOB和TEXT有什么区别？</p></blockquote><p>BLOB是一个二进制对象，可以容纳可变数量的数据。有四种类型的BLOB：TINYBLOB、BLOB、MEDIUMBLO和 LONGBLOB</p><p>TEXT是一个不区分大小写的BLOB。四种TEXT类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。</p><p>BLOB 保存二进制数据，TEXT 保存字符数据。</p><hr><h2 id="四、索引"><a href="#四、索引" class="headerlink" title="四、索引"></a>四、索引</h2><blockquote><p>说说你对 MySQL 索引的理解？数据库索引的原理，为什么要用 B+树，为什么不用二叉树？聚集索引与非聚集索引的区别？InnoDB引擎中的索引策略，了解过吗？创建索引的方式有哪些？聚簇索引/非聚簇索引，mysql索引底层实现，为什么不用B-tree，为什么不用hash，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？</p></blockquote><ul><li><p>MYSQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构，所以说<strong>索引的本质是：数据结构</strong></p></li><li><p>索引的目的在于提高查询效率，可以类比字典、 火车站的车次表、图书的目录等 。</p></li><li><p>可以简单的理解为“排好序的快速查找数据结构”，数据本身之外，<font color=red size=3><strong>数据库还维护者一个满足特定查找算法的数据结构</strong></font>，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图是一种可能的索引方式示例。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff356f9f2f0.jpg" alt=""></p><p>左边的数据表，一共有两列七条记录，最左边的是数据记录的物理地址</p><p>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值，和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到对应的数据，从而快速检索出符合条件的记录。</p></li><li><p>索引本身也很大，不可能全部存储在内存中，<strong>一般以索引文件的形式存储在磁盘上</strong></p></li><li><p>平常说的索引，没有特别指明的话，就是B+树（多路搜索树，不一定是二叉树）结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。此外还有哈希索引等。</p></li></ul><h3 id="基本语法："><a href="#基本语法：" class="headerlink" title="基本语法："></a>基本语法：</h3><ul><li><p>创建：</p><ul><li><p>创建索引：<font color=red size=3><code>CREATE [UNIQUE] INDEX indexName ON mytable(username(length));</code></font></p><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p></li><li><p>修改表结构(添加索引)：<font color=red size=3><code>ALTER table tableName ADD [UNIQUE] INDEX indexName(columnName)</code></font></p></li></ul></li><li><p>删除：<font color=red size=3><code>DROP INDEX [indexName] ON mytable;</code></font></p></li><li><p>查看：<font color=red size=3><code>SHOW INDEX FROM table_name\\G</code></font> –可以通过添加 \G 来格式化输出信息。</p></li><li><p>使用ALERT命令</p><ul><li><font color=red size=3><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):</code></font> 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li><li><font color=red size=3><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list</code></font> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li><li><font color=red size=3><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code></font> 添加普通索引，索引值可出现多次。</li><li><font color=red size=3><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code></font>该语句指定了索引为 FULLTEXT ，用于全文索引。</li></ul></li></ul><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li><strong>提高数据检索效率，降低数据库IO成本</strong></li><li><strong>降低数据排序的成本，降低CPU的消耗</strong></li></ul><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ul><li>索引也是一张表，保存了主键和索引字段，并指向实体表的记录，所以也需要占用内存</li><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段， 都会调整因为更新所带来的键值变化后的索引信息</li></ul><h3 id="MySQL索引分类"><a href="#MySQL索引分类" class="headerlink" title="MySQL索引分类"></a>MySQL索引分类</h3><h3 id="数据结构角度"><a href="#数据结构角度" class="headerlink" title="数据结构角度"></a>数据结构角度</h3><ul><li>B+树索引</li><li>Hash索引</li><li>Full-Text全文索引</li><li>R-Tree索引</li></ul><h3 id="从物理存储角度"><a href="#从物理存储角度" class="headerlink" title="从物理存储角度"></a>从物理存储角度</h3><ul><li><p>聚集索引（clustered index）</p></li><li><p>非聚集索引（non-clustered index），也叫辅助索引（secondary index）</p><p>聚集索引和非聚集索引都是B+树结构</p></li></ul><h3 id="从逻辑角度"><a href="#从逻辑角度" class="headerlink" title="从逻辑角度"></a>从逻辑角度</h3><ul><li>主键索引：主键索引是一种特殊的唯一索引，不允许有空值</li><li>普通索引或者单列索引：每个索引只包含单个列，一个表可以有多个单列索引</li><li>多列索引（复合索引、联合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</li><li>唯一索引或者非唯一索引</li><li>空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。 MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</li></ul><blockquote><p>为什么MySQL 索引中用B+tree，不用B-tree 或者其他树，为什么不用 Hash 索引聚簇索引/非聚簇索引，MySQL 索引底层实现，叶子结点存放的是数据还是指向数据的内存地址，使用索引需要注意的几个地方？使用索引查询一定能提高查询的性能吗？为什么?</p></blockquote><h3 id="MySQL索引结构"><a href="#MySQL索引结构" class="headerlink" title="MySQL索引结构"></a>MySQL索引结构</h3><p><strong>首先要明白索引（index）是在存储引擎（storage engine）层面实现的，而不是server层面</strong>。不是所有的存储引擎都支持所有的索引类型。即使多个存储引擎支持某一索引类型，它们的实现和行为也可能有所差别。</p><h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+Tree索引"></a>B+Tree索引</h3><p>MyISAM 和 InnoDB 存储引擎，都使用 B+Tree的数据结构，它相对与 B-Tree结构，所有的数据都存放在叶子节点上，且把叶子节点通过指针连接到一起，形成了一条数据链表，以加快相邻数据的检索效率。</p><p><strong>先了解下 B-Tree 和 B+Tree 的区别</strong></p><h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。</p><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p><p>InnoDB 存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为16KB，可通过参数 <code>innodb_page_size</code> 将页的大小设置为 4K、8K、16K，在 MySQL 中可通过如下命令查看页的大小：<code>show variables like &#39;innodb_page_size&#39;;</code></p><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p><p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述 B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p>一棵m阶的B-Tree有如下特性：</p><ol><li>每个节点最多有m个孩子</li><li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。</li><li>若根节点不是叶子节点，则至少有2个孩子</li><li>所有叶子节点都在同一层，且不包含其它关键字信息</li><li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn）</li><li>关键字的个数n满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li><li>ki(i=1,…n)为关键字，且关键字升序排序</li><li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li></ol><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff356b40f0d.jpg" alt=""></p><p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p><p>模拟查找关键字29的过程：</p><ol><li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li><li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li><li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li><li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li><li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li><li>在磁盘块8中的关键字列表中找到关键字29。</li></ol><p>分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p><h3 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h3><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</p><p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，<strong>所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上</strong>，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p>B+Tree相对于B-Tree有几点不同：</p><ol><li>非叶子节点只存储键值信息；</li><li>所有叶子节点之间都有一个链指针；</li><li>数据记录都存放在叶子节点中</li></ol><p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff3498c6715.jpg" alt=""></p><p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p><p>可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：</p><p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为10^3）。也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</p><p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2-4层。MySQL的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p><p>B+Tree性质</p><ol><li>通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。</li><li>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong>。</li></ol><h3 id="MyISAM主键索引与辅助索引的结构"><a href="#MyISAM主键索引与辅助索引的结构" class="headerlink" title="MyISAM主键索引与辅助索引的结构"></a>MyISAM主键索引与辅助索引的结构</h3><p>MyISAM引擎的索引文件和数据文件是分离的。<strong>MyISAM引擎索引结构的叶子节点的数据域，存放的并不是实际的数据记录，而是数据记录的地址</strong>。索引文件与数据文件分离，这样的索引称为”<strong>非聚簇索引</strong>“。MyISAM的主索引与辅助索引区别并不大，只是主键索引不能有重复的关键字。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff35bbbf112.jpg" alt=""></p><p>在MyISAM中，索引（含叶子节点）存放在单独的.myi文件中，叶子节点存放的是数据的物理地址偏移量（通过偏移量访问就是随机访问，速度很快）。</p><p>主索引是指主键索引，键值不可能重复；辅助索引则是普通索引，键值可能重复。</p><p>通过索引查找数据的流程：先从索引文件中查找到索引节点，从中拿到数据的文件指针，再到数据文件中通过文件指针定位了具体的数据。辅助索引类似。</p><h3 id="InnoDB主键索引与辅助索引的结构"><a href="#InnoDB主键索引与辅助索引的结构" class="headerlink" title="InnoDB主键索引与辅助索引的结构"></a>InnoDB主键索引与辅助索引的结构</h3><p><strong>InnoDB引擎索引结构的叶子节点的数据域，存放的就是实际的数据记录</strong>（对于主索引，此处会存放表中所有的数据记录；对于辅助索引此处会引用主键，检索的时候通过主键到主键索引中找到对应数据行），或者说，<strong>InnoDB的数据文件本身就是主键索引文件</strong>，这样的索引被称为”“聚簇索引”，一个表只能有一个聚簇索引。</p><h3 id="主键索引："><a href="#主键索引：" class="headerlink" title="主键索引："></a>主键索引：</h3><p>我们知道InnoDB索引是聚集索引，它的索引和数据是存入同一个.idb文件中的，因此它的索引结构是在同一个树节点中同时存放索引和数据，如下图中最底层的叶子节点有三行数据，对应于数据表中的id、stu_id、name数据项。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff337681c17.jpg" alt=""></p><p>在Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的，在数据段中。Innodb的数据文件可以按照表来切分（只需要开启<font color=red size=3><code>innodb_file_per_table)</code></font>，切分后存放在<font color=red size=3><code>xxx.ibd</code></font>中，默认不切分，存放在<font color=red size=3><code>xxx.ibdata</code></font>中。</p><h3 id="辅助（非主键）索引："><a href="#辅助（非主键）索引：" class="headerlink" title="辅助（非主键）索引："></a>辅助（非主键）索引：</h3><p>这次我们以示例中学生表中的name列建立辅助索引，它的索引结构跟主键索引的结构有很大差别，在最底层的叶子结点有两行数据，第一行的字符串是辅助索引，按照ASCII码进行排序，第二行的整数是主键的值。</p><p>这就意味着，对name列进行条件搜索，需要两个步骤：</p><p>① 在辅助索引上检索name，到达其叶子节点获取对应的主键；</p><p>② 使用主键在主索引上再进行对应的检索操作</p><p>这也就是所谓的“<strong>回表查询</strong>”</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff365f39d10.jpg" alt=""></p><p><strong>InnoDB 索引结构需要注意的点</strong></p><ol><li>数据文件本身就是索引文件</li><li>表数据文件本身就是按 B+Tree 组织的一个索引结构文件</li><li>聚集索引中叶节点包含了完整的数据记录</li><li>InnoDB 表必须要有主键，并且推荐使用整型自增主键</li></ol><p>正如我们上面介绍 InnoDB 存储结构，索引与数据是共同存储的，不管是主键索引还是辅助索引，在查找时都是通过先查找到索引节点才能拿到相对应的数据，如果我们在设计表结构时没有显式指定索引列的话，MySQL 会从表中选择数据不重复的列建立索引，如果没有符合的列，则 MySQL 自动为 InnoDB 表生成一个隐含字段作为主键，并且这个字段长度为6个字节，类型为整型。</p><blockquote><p>那为什么推荐使用整型自增主键而不是选择UUID？</p></blockquote><ul><li>UUID是字符串，比整型消耗更多的存储空间；</li><li>在B+树中进行查找时需要跟经过的节点值比较大小，整型数据的比较运算比字符串更快速；</li><li>自增的整型索引在磁盘中会连续存储，在读取一页数据时也是连续；UUID是随机产生的，读取的上下两行数据存储是分散的，不适合执行where id &gt; 5 &amp;&amp; id &lt; 20的条件查询语句。</li><li>在插入或删除数据时，整型自增主键会在叶子结点的末尾建立新的叶子节点，不会破坏左侧子树的结构；UUID主键很容易出现这样的情况，B+树为了维持自身的特性，有可能会进行结构的重构，消耗更多的时间。</li></ul><blockquote><p>为什么非主键索引结构叶子节点存储的是主键值？</p></blockquote><p>保证数据一致性和节省存储空间，可以这么理解：商城系统订单表会存储一个用户ID作为关联外键，而不推荐存储完整的用户信息，因为当我们用户表中的信息（真实名称、手机号、收货地址···）修改后，不需要再次维护订单表的用户数据，同时也节省了存储空间。</p><h3 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h3><ul><li><p>主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p><p>检索算法：在检索查询时，就再次对待查关键字再次执行相同的Hash算法，得到Hash值，到对应Hash表对应位置取出数据即可，如果发生Hash碰撞，则需要在取值时进行筛选。目前使用Hash索引的数据库并不多，主要有Memory等。</p><p>MySQL目前有Memory引擎和NDB引擎支持Hash索引。</p></li></ul><h3 id="full-text全文索引"><a href="#full-text全文索引" class="headerlink" title="full-text全文索引"></a>full-text全文索引</h3><ul><li>全文索引也是MyISAM的一种特殊索引类型，主要用于全文索引，InnoDB从MYSQL5.6版本提供对全文索引的支持。</li><li>它用于替代效率较低的LIKE模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。</li><li>同样使用B-Tree存放索引数据，但使用的是特定的算法，将字段数据分割后再进行索引（一般每4个字节一次分割），索引文件存储的是分割前的索引字符串集合，与分割后的索引信息，对应Btree结构的节点存储的是分割后的词信息以及它在分割前的索引字符串集合中的位置。</li></ul><h3 id="R-Tree空间索引"><a href="#R-Tree空间索引" class="headerlink" title="R-Tree空间索引"></a>R-Tree空间索引</h3><p>空间索引是MyISAM的一种特殊索引类型，主要用于地理空间数据类型</p><blockquote><p>为什么Mysql索引要用B+树不是B树？</p></blockquote><p>用B+树不用B树考虑的是IO对性能的影响，B树的每个节点都存储数据，而B+树只有叶子节点才存储数据，所以查找相同数据量的情况下，B树的高度更高，IO更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘页（对应索引树的节点）。其中在MySQL底层对B+树进行进一步优化：在叶子节点中是双向链表，且在链表的头结点和尾节点也是循环指向的。</p><blockquote><p>面试官：为何不采用Hash方式？</p></blockquote><p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。而B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p><p>哈希索引不支持多列联合索引的最左匹配规则，如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题。</p><h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，高并发下倾向创建组合索引</li><li>查询中排序的字段，排序字段通过索引访问大幅提高排序速度</li><li>查询中统计或分组字段</li></ol><h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h3><ol><li>表记录太少</li><li>经常增删改的表</li><li>数据重复且分布均匀的表字段，只应该为最经常查询和最经常排序的数据列建立索引（如果某个数据类包含太多的重复数据，建立索引没有太大意义）</li><li>频繁更新的字段不适合创建索引（会加重IO负担）</li><li>where条件里用不到的字段不创建索引</li></ol><h3 id="MySQL高效索引"><a href="#MySQL高效索引" class="headerlink" title="MySQL高效索引"></a>MySQL高效索引</h3><p><strong>覆盖索引</strong>（Covering Index）,或者叫索引覆盖， 也就是平时所说的不需要回表操作</p><ul><li><p>就是select的数据列只用从索引中就能够取得，不必读取数据行，MySQL可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件，换句话说<strong>查询列要被所建的索引覆盖</strong>。</p></li><li><p>索引是高效找到行的一个方法，但是一般数据库也能使用索引找到一个列的数据，因此它不必读取整个行。毕竟索引叶子节点存储了它们索引的数据，当能通过读取索引就可以得到想要的数据，那就不需要读取行了。一个索引包含（覆盖）满足查询结果的数据就叫做覆盖索引。</p></li><li><p><strong>判断标准</strong></p><p>使用explain，可以通过输出的extra列来判断，对于一个索引覆盖查询，显示为<strong>using index</strong>，MySQL查询优化器在执行查询前会决定是否有索引覆盖查询</p></li></ul><h2 id="五、MySQL查询"><a href="#五、MySQL查询" class="headerlink" title="五、MySQL查询"></a>五、MySQL查询</h2><hr><blockquote><p>count(*) 和 count(1)和count(列名)区别   ps：这道题说法有点多</p></blockquote><p>执行效果上：</p><ul><li>count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL</li><li>count(1)包括了所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL</li><li>count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。</li></ul><p>执行效率上：</p><ul><li>列名为主键，count(列名)会比count(1)快</li><li>列名不为主键，count(1)会比count(列名)快</li><li>如果表多个列并且没有主键，则 count(1) 的执行效率优于 count(*)</li><li>如果有主键，则 select count（主键）的执行效率是最优的</li><li>如果表只有一个字段，则 select count(*) 最优。</li></ul><blockquote><p>MySQL中 in和 exists 的区别？</p></blockquote><ul><li>exists：exists对外表用loop逐条查询，每次查询都会查看exists的条件语句，当exists里的条件语句能够返回记录行时（无论记录行是的多少，只要能返回），条件就为真，返回当前loop到的这条记录；反之，如果exists里的条件语句不能返回记录行，则当前loop到的这条记录被丢弃，exists的条件就像一个bool条件，当能返回结果集则为true，不能返回结果集则为false</li><li>in：in查询相当于多个or条件的叠加</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> A.id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> B);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> * <span class="keyword">from</span> B <span class="keyword">WHERE</span> B.id = A.id);</span><br></pre></td></tr></table></figure><p><strong>如果查询的两个表大小相当，那么用in和exists差别不大</strong>。</p><p>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in：</p><blockquote><p>UNION和UNION ALL的区别?</p></blockquote><p>UNION和UNION ALL都是将两个结果集合并为一个，<strong>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）；</strong></p><ul><li>UNION在进行表连接后会筛选掉重复的数据记录（效率较低），而UNION ALL则不会去掉重复的数据记录；</li><li>UNION会按照字段的顺序进行排序，而UNION ALL只是简单的将两个结果合并就返回；</li></ul><h3 id="SQL执行顺序"><a href="#SQL执行顺序" class="headerlink" title="SQL执行顺序"></a>SQL执行顺序</h3><ul><li><p>手写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">FROM</span>  &lt;left_table&gt; &lt;join_type&gt;</span><br><span class="line"><span class="keyword">JOIN</span>  &lt;right_table&gt; <span class="keyword">ON</span> &lt;join_condition&gt;</span><br><span class="line"><span class="keyword">WHERE</span>  &lt;where_condition&gt;</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span>  &lt;group_by_list&gt;</span><br><span class="line"><span class="keyword">HAVING</span> &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure></li><li><p>机读</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM  &lt;left_table&gt;</span><br><span class="line">ON &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; JOIN  &lt;right_table&gt; </span><br><span class="line">WHERE  &lt;where_condition&gt;</span><br><span class="line">GROUP BY  &lt;group_by_list&gt;</span><br><span class="line">HAVING &lt;having_condition&gt;</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DISTINCT</span> &lt;select_list&gt;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;order_by_condition&gt;</span><br><span class="line"><span class="keyword">LIMIT</span> &lt;limit_number&gt;</span><br></pre></td></tr></table></figure></li><li><p>总结</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff368752ece.jpg" alt=""></p></li></ul><blockquote><p>mysql 的内连接、左连接、右连接有什么区别？什么是内连接、外连接、交叉连接、笛卡尔积呢？</p></blockquote><h3 id="Join图"><a href="#Join图" class="headerlink" title="Join图"></a>Join图</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff37ac0e7f6.jpg" alt=""></p><hr><h2 id="六、MySQL-事务"><a href="#六、MySQL-事务" class="headerlink" title="六、MySQL 事务"></a>六、MySQL 事务</h2><hr><blockquote><p>事务的隔离级别有哪些？MySQL的默认隔离级别是什么？什么是幻读，脏读，不可重复读呢？MySQL事务的四大特性以及实现原理MVCC熟悉吗，它的底层原理？</p></blockquote><p>MySQL 事务主要用于处理操作量大，复杂度高的数据。比如说，在人员管理系统中，你删除一个人员，你即需要删除人员的基本资料，也要删除和该人员相关的信息，如信箱，文章等等，这样，这些数据库操作语句就构成一个事务！</p><h3 id="ACID-—-事务基本要素"><a href="#ACID-—-事务基本要素" class="headerlink" title="ACID — 事务基本要素"></a>ACID — 事务基本要素</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff377ece423.jpg" alt=""></p><p>事务是由一组SQL语句组成的逻辑处理单元，具有4个属性，通常简称为事务的ACID属性。</p><ul><li><strong>A (Atomicity) 原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</li><li><strong>C (Consistency) 一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏</li><li><strong>I (Isolation)隔离性</strong>：一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰</li><li><strong>D (Durability) 持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚</li></ul><p><strong>并发事务处理带来的问题</strong></p><ul><li>更新丢失（Lost Update)： 事务A和事务B选择同一行，然后基于最初选定的值更新该行时，由于两个事务都不知道彼此的存在，就会发生丢失更新问题</li><li>脏读(Dirty Reads)：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li><li>不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li><li>幻读（Phantom Reads)：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li></ul><p><strong>幻读和不可重复读的区别：</strong></p><ul><li><strong>不可重复读的重点是修改</strong>：在同一事务中，同样的条件，第一次读的数据和第二次读的数据不一样。（因为中间有其他事务提交了修改）</li><li><strong>幻读的重点在于新增或者删除</strong>：在同一事务中，同样的条件,，第一次和第二次读出来的记录数不一样。（因为中间有其他事务提交了插入/删除）</li></ul><p><strong>并发事务处理带来的问题的解决办法：</strong></p><ul><li>“更新丢失”通常是应该完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</li><li>“脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决：<ul><li>一种是加锁：在读取数据前，对其加锁，阻止其他事务对数据进行修改。</li><li>另一种是数据多版本并发控制（MultiVersion Concurrency Control，简称 <strong>MVCC</strong> 或 MCC），也称为多版本数据库：不用加任何锁， 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本。</li></ul></li></ul><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库事务的隔离级别有4种，由低到高分别为</p><ul><li><strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><p>查看当前数据库的事务隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'tx_isolation'</span></span><br></pre></td></tr></table></figure><p>下面通过事例一一阐述在事务的并发操作中可能会出现脏读，不可重复读，幻读和事务隔离级别的联系。</p><p>数据库的事务隔离越严格，并发副作用越小，但付出的代价就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。</p><h3 id="Read-uncommitted"><a href="#Read-uncommitted" class="headerlink" title="Read uncommitted"></a>Read uncommitted</h3><p>读未提交，就是一个事务可以读取另一个未提交事务的数据。</p><p>事例：老板要给程序员发工资，程序员的工资是3.6万/月。但是发工资时老板不小心按错了数字，按成3.9万/月，该钱已经打到程序员的户口，但是事务还没有提交，就在这时，程序员去查看自己这个月的工资，发现比往常多了3千元，以为涨工资了非常高兴。但是老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成3.6万再提交。</p><p>分析：实际程序员这个月的工资还是3.6万，但是程序员看到的是3.9万。他看到的是老板还没提交事务时的数据。这就是脏读。</p><p>那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。</p><h3 id="Read-committed"><a href="#Read-committed" class="headerlink" title="Read committed"></a>Read committed</h3><p>读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。</p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（程序员事务开启），收费系统事先检测到他的卡里有3.6万，就在这个时候！！程序员的妻子要把钱全部转出充当家用，并提交。当收费系统准备扣款时，再检测卡里的金额，发现已经没钱了（第二次检测金额当然要等待妻子转出金额事务提交完）。程序员就会很郁闷，明明卡里是有钱的…</p><p>分析：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是<strong>不可重复读</strong>。</p><p>那怎么解决可能的不可重复读问题？Repeatable read ！</p><h3 id="Repeatable-read"><a href="#Repeatable-read" class="headerlink" title="Repeatable read"></a>Repeatable read</h3><p>重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。 <strong>MySQL的默认事务隔离级别</strong></p><p>事例：程序员拿着信用卡去享受生活（卡里当然是只有3.6万），当他埋单时（事务开启，不允许其他事务的UPDATE修改操作），收费系统事先检测到他的卡里有3.6万。这个时候他的妻子不能转出金额了。接下来收费系统就可以扣款了。</p><p>分析：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，<strong>不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作</strong>。</p><p><strong>什么时候会出现幻读？</strong></p><p>事例：程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p><p>那怎么解决幻读问题？Serializable！</p><h3 id="Serializable-序列化"><a href="#Serializable-序列化" class="headerlink" title="Serializable 序列化"></a>Serializable 序列化</h3><p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。简单来说，Serializable会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用问题。这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><table><thead><tr><th>事务隔离级别</th><th>读数据一致性</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td>最低级被，只能保证不读取物理上损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>读已提交（read-committed）</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>可重复读（repeatable-read）</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>串行化（serializable）</td><td>最高级别，事务级</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>需要说明的是，事务隔离级别和数据访问的并发性是对立的，事务隔离级别越高并发性就越差。所以要根据具体的应用来确定合适的事务隔离级别，这个地方没有万能的原则。</p><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<font color=red size=3><code>SELECT @@tx_isolation;</code></font>命令来查看，MySQL 8.0 该命令改为<font color=red size=3><code>SELECT @@transaction_isolation;</code></font></p><p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong>事务隔离级别下使用的是Next-Key Lock 算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 <strong>SERIALIZABLE(可串行化)</strong>隔离级别，而且保留了比较好的并发性能。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读已提交):</strong>，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p><h3 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h3><p>MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。</p><p>可以认为 MVCC 是行级锁的一个变种，但它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p><p>MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说不管需要执行多长时间，每个事物看到的数据都是一致的。</p><p>典型的MVCC实现方式，分为<strong>乐观（optimistic）并发控制和悲观（pressimistic）并发控制</strong>。下边通过 InnoDB的简化版行为来说明 MVCC 是如何工作的。</p><p>InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是真实的时间，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p><strong>REPEATABLE READ（可重读）隔离级别下MVCC如何工作：</strong></p><ul><li><p>SELECT</p><p>InnoDB会根据以下两个条件检查每行记录：</p><ul><li>InnoDB只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行，要么是在开始事务之前已经存在要么是事务自身插入或者修改过的</li><li>行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除</li></ul><p>只有符合上述两个条件的才会被查询出来</p></li><li><p>INSERT：InnoDB为新插入的每一行保存当前系统版本号作为行版本号</p></li><li><p>DELETE：InnoDB为删除的每一行保存当前系统版本号作为行删除标识</p></li><li><p>UPDATE：InnoDB为插入的一行新纪录保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为删除标识</p></li></ul><p>保存这两个额外系统版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且也能保证只会读取到符合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。</p><p>MVCC 只在 COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作。</p><h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p>InnoDB 使用日志来减少提交事务时的开销。因为日志中已经记录了事务，就无须在每个事务提交时把缓冲池的脏块刷新(flush)到磁盘中。</p><p>事务修改的数据和索引通常会映射到表空间的随机位置，所以刷新这些变更到磁盘需要很多随机 IO。</p><p>InnoDB 假设使用常规磁盘，随机IO比顺序IO昂贵得多，因为一个IO请求需要时间把磁头移到正确的位置，然后等待磁盘上读出需要的部分，再转到开始位置。</p><p>InnoDB 用日志把随机IO变成顺序IO。一旦日志安全写到磁盘，事务就持久化了，即使断电了，InnoDB可以重放日志并且恢复已经提交的事务。</p><p>InnoDB 使用一个后台线程智能地刷新这些变更到数据文件。这个线程可以批量组合写入，使得数据写入更顺序，以提高效率。</p><p>事务日志可以帮助提高事务效率：</p><ul><li>使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。</li><li>事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序I/O，而不像随机I/O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。</li><li>事务日志持久以后，内存中被修改的数据在后台可以慢慢刷回到磁盘。</li><li>如果数据的修改已经记录到事务日志并持久化，但数据本身没有写回到磁盘，此时系统崩溃，存储引擎在重启时能够自动恢复这一部分修改的数据。</li></ul><p>目前来说，大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong>（Write-Ahead Logging），修改数据需要写两次磁盘。</p><h3 id="事务的实现"><a href="#事务的实现" class="headerlink" title="事务的实现"></a>事务的实现</h3><p>事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不一样。MySQL 中支持事务的存储引擎有 InnoDB 和 NDB。</p><p>事务的实现就是如何实现ACID特性。</p><p>事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现 。</p><blockquote><p>事务是如何通过日志来实现的，说得越深入越好。</p></blockquote><p>事务日志包括：<strong>重做日志redo</strong>和<strong>回滚日志undo</strong></p><ul><li><p><strong>redo log（重做日志</strong>） 实现持久化和原子性</p><p>在innoDB的存储引擎中，事务日志通过重做(redo)日志和innoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作，都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲的日志都需要提前刷新到磁盘上持久化，这就是DBA们口中常说的“日志先行”(Write-Ahead Logging)。当事务提交之后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据库崩溃或者宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的一个状态。未完成的事务，可以继续提交，也可以选择回滚，这基于恢复的策略而定。</p><p>在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录Redo Log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起。</p></li><li><p><strong>undo log（回滚日志）</strong> 实现一致性</p><p>undo log 主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他的事务做的操作。</p><p>Undo记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下回滚日志是记录下表空间中的（共享表空间或者独享表空间）</p></li></ul><p>二种日志均可以视为一种恢复操作，redo_log是恢复提交事务修改的页操作，而undo_log是回滚行记录到特定版本。二者记录的内容也不同，redo_log是物理日志，记录页的物理修改操作，而undo_log是逻辑日志，根据每行记录进行记录。</p><blockquote><p>又引出个问题：你知道MySQL 有多少种日志吗？</p></blockquote><ul><li><strong>错误日志</strong>：记录出错信息，也记录一些警告信息或者正确的信息。</li><li><strong>查询日志</strong>：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。</li><li><strong>慢查询日志</strong>：设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中。</li><li><strong>二进制日志</strong>：记录对数据库执行更改的所有操作。</li><li><strong>中继日志</strong>：中继日志也是二进制日志，用来给slave 库恢复</li><li><strong>事务日志</strong>：重做日志redo和回滚日志undo</li></ul><blockquote><p>分布式事务相关问题，可能还会问到 2PC、3PC，，，</p></blockquote><h3 id="MySQL对分布式事务的支持"><a href="#MySQL对分布式事务的支持" class="headerlink" title="MySQL对分布式事务的支持"></a>MySQL对分布式事务的支持</h3><p>分布式事务的实现方式有很多，既可以采用 InnoDB 提供的原生的事务支持，也可以采用消息队列来实现分布式事务的最终一致性。这里我们主要聊一下 InnoDB 对分布式事务的支持。</p><p>MySQL 从 5.0.3 InnoDB 存储引擎开始支持XA协议的分布式事务。一个分布式事务会涉及多个行动，这些行动本身是事务性的。所有行动都必须一起成功完成，或者一起被回滚。</p><p>在MySQL中，使用分布式事务涉及一个或多个资源管理器和一个事务管理器。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff37e532a33.jpg" alt=""></p><p>如图，MySQL 的分布式事务模型。模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）:</p><ul><li>应用程序：定义了事务的边界，指定需要做哪些事务；</li><li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li><li>事务管理器：协调参与了全局事务中的各个事务。</li></ul><p>分布式事务采用两段式提交（two-phase commit）的方式：</p><ul><li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li><li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li></ul><h2 id="七、MySQL锁机制"><a href="#七、MySQL锁机制" class="headerlink" title="七、MySQL锁机制"></a>七、MySQL锁机制</h2><hr><blockquote><p>数据库的乐观锁和悲观锁？MySQL 中有哪几种锁，列举一下？MySQL中InnoDB引擎的行锁是怎么实现的？MySQL 间隙锁有没有了解，死锁有没有了解，写一段会造成死锁的 sql 语句，死锁发生了如何解决，MySQL 有没有提供什么机制去解决死锁</p></blockquote><p>锁是计算机协调多个进程或线程并发访问某一资源的机制。</p><p>在数据库中，除传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。数据库锁定机制简单来说，就是数据库为了保证数据的一致性，而使各种共享资源在被并发访问变得有序所设计的一种规则。</p><p>打个比方，我们到淘宝上买一件商品，商品只有一件库存，这个时候如果还有另一个人买，那么如何解决是你买到还是另一个人买到的问题？这里肯定要用到事物，我们先从库存表中取出物品数量，然后插入订单，付款后插入付款表信息，然后更新商品数量。在这个过程中，使用锁可以对有限的资源进行保护，解决隔离和并发的矛盾。</p><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p><strong>从对数据操作的类型分类</strong>：</p><ul><li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li><li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li></ul><p><strong>从对数据操作的粒度分类</strong>：</p><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p><ul><li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li><li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li><li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul><p>适用：从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。</p><table><thead><tr><th>行锁</th><th>表锁</th><th>页锁</th><th></th></tr></thead><tbody><tr><td>MyISAM</td><td></td><td>√</td><td></td></tr><tr><td>BDB</td><td></td><td>√</td><td>√</td></tr><tr><td>InnoDB</td><td>√</td><td>√</td><td></td></tr><tr><td>Memory</td><td></td><td>√</td><td></td></tr></tbody></table><h3 id="MyISAM-表锁"><a href="#MyISAM-表锁" class="headerlink" title="MyISAM 表锁"></a>MyISAM 表锁</h3><p>MyISAM 的表锁有两种模式：</p><ul><li>表共享读锁 （Table Read Lock）：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li><li>表独占写锁 （Table Write Lock）：会阻塞其他用户对同一表的读和写操作；</li></ul><p>MyISAM 表的读操作与写操作之间，以及写操作之间是串行的。当一个线程获得对一个表的写锁后， 只有持有锁的线程可以对表进行更新操作。 其他线程的读、 写操作都会等待，直到锁被释放为止。</p><p>默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等候的获取锁请求，然后再给读锁队列中等候的获取锁请求。</p><h3 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h3><p>InnoDB 实现了以下两种类型的<strong>行锁</strong>：</p><ul><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ul><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是<strong>表锁</strong>：</p><ul><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li></ul><p><strong>索引失效会导致行锁变表锁</strong>。比如 vchar 查询不写单引号的情况。</p><h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p><strong>乐观锁与悲观锁是两种并发控制的思想，可用于解决丢失更新问题</strong></p><p>乐观锁会“乐观地”假定大概率不会发生并发更新冲突，访问、处理数据过程中不加锁，只在更新数据时再根据版本号或时间戳判断是否有冲突，有则处理，无则提交事务。用数据版本（Version）记录机制实现，这是乐观锁最常用的一种实现方式</p><p>悲观锁会“悲观地”假定大概率会发生并发更新冲突，访问、处理数据前就加排他锁，在整个数据处理过程中锁定数据，事务提交或回滚后才释放锁。另外与乐观锁相对应的，<strong>悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。</strong></p><h3 id="锁模式-InnoDB有三种行锁的算法"><a href="#锁模式-InnoDB有三种行锁的算法" class="headerlink" title="锁模式(InnoDB有三种行锁的算法)"></a>锁模式(InnoDB有三种行锁的算法)</h3><ul><li><p><strong>记录锁(Record Locks)</strong>： 单个行记录上的锁。对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>它会在 id=1 的记录上加上记录锁，以阻止其他事务插入，更新，删除 id=1 这一行</p><p>在通过 主键索引 与 唯一索引 对数据行进行 UPDATE 操作时，也会对该行数据加记录锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- id 列为主键列或唯一索引列</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">SET</span> age = <span class="number">50</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>间隙锁（Gap Locks）</strong>： 当我们使用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁。对于键值在条件范围内但并不存在的记录，叫做“间隙”。</p><p>InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁。</p><p>对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁），不包含索引项本身。其他事务不能在锁范围内插入数据，这样就防止了别的事务新增幻影行。</p><p>间隙锁基于非唯一索引，它锁定一段范围内的索引记录。间隙锁基于下面将会提到的<font color=red size=3><code>Next-Key Locking</code></font> 算法，请务必牢记：<strong>使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> BETWEN <span class="number">1</span> <span class="keyword">AND</span> <span class="number">10</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>即所有在<font color=red size=3><code>（1，10）</code></font>区间内的记录行都会被锁住，所有id 为 2、3、4、5、6、7、8、9 的数据行的插入会被阻塞，但是 1 和 10 两条记录行并不会被锁住。</p><p>GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况</p></li><li><p><strong>临键锁(Next-key Locks)</strong>： <strong>临键锁</strong>，是<strong>记录锁与间隙锁的组合</strong>，它的封锁范围，既包含索引记录，又包含索引区间。(临键锁的主要目的，也是为了避免<strong>幻读</strong>(Phantom Read)。如果把事务的隔离级别降级为RC，临键锁则也会失效。)</p><p>Next-Key 可以理解为一种特殊的<strong>间隙锁</strong>，也可以理解为一种特殊的<strong>算法</strong>。通过<strong>临建锁</strong>可以解决幻读的问题。 每个数据行上的非唯一索引列上都会存在一把临键锁，当某个事务持有该数据行的临键锁时，会锁住一段左开右闭区间的数据。需要强调的一点是，<code>InnoDB</code> 中行级锁是基于索引实现的，临键锁只与非唯一索引列有关，在唯一索引列（包括主键列）上不存在临键锁。</p><p>对于行的查询，都是采用该方法，主要目的是解决幻读的问题。</p></li></ul><blockquote><p>select for update有什么含义，会锁表还是锁行还是其他</p></blockquote><p>for update 仅适用于InnoDB，且必须在事务块(BEGIN/COMMIT)中才能生效。在进行事务操作时，通过“for update”语句，MySQL会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。排他锁包含行锁、表锁。</p><p>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 假设有个表单 products ，里面有id跟name二个栏位，id是主键。</p><ul><li>明确指定主键，并且有此笔资料，row lock</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'3'</span> <span class="keyword">and</span> <span class="keyword">type</span>=<span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><ul><li>明确指定主键，若查无此笔资料，无lock</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="string">'-1'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><ul><li>无主键，table lock</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'Mouse'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><ul><li>主键不明确，table lock</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span>&lt;&gt;<span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><ul><li>主键不明确，table lock</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> products <span class="keyword">WHERE</span> <span class="keyword">id</span> <span class="keyword">LIKE</span> <span class="string">'3'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p><strong>注1</strong>: FOR UPDATE仅适用于InnoDB，且必须在交易区块(BEGIN/COMMIT)中才能生效。 <strong>注2</strong>: 要测试锁定的状况，可以利用MySQL的Command Mode ，开二个视窗来做测试。</p><blockquote><p>MySQL 遇到过死锁问题吗，你是如何解决的？</p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><strong>死锁产生</strong>：</p><ul><li>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环</li><li>当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁</li><li>锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。</li></ul><p><strong>检测死锁</strong>：数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。</p><p><strong>死锁恢复</strong>：死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。</p><p><strong>外部锁的死锁检测</strong>：发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测到死锁， 这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决</p><p><strong>死锁影响性能</strong>：死锁会影响性能而不是会产生严重错误，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖<code>innodb_lock_wait_timeout</code>设置进行事务回滚。</p><p><strong>MyISAM避免死锁</strong>：</p><ul><li>在自动加锁的情况下，MyISAM 总是一次获得 SQL 语句所需要的全部锁，所以 MyISAM 表不会出现死锁。</li></ul><p><strong>InnoDB避免死锁</strong>：</p><ul><li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用<code>SELECT ... FOR UPDATE</code>语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li><li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li><li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li><li>通过<font color=red size=3><code>SELECT ... LOCK IN SHARE MODE</code></font>获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li><li>改变事务隔离级别</li></ul><p>如果出现死锁，可以用 <font color=red size=3><code>show engine innodb status;</code></font>命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</p><hr><h2 id="八、MySQL调优"><a href="#八、MySQL调优" class="headerlink" title="八、MySQL调优"></a>八、MySQL调优</h2><hr><blockquote><p>日常工作中你是怎么优化SQL的？SQL优化的一般步骤是什么，怎么看执行计划（explain），如何理解其中各个字段的含义？如何写sql能够有效的使用到复合索引？一条sql执行过长的时间，你如何优化，从哪些方面入手？什么是最左前缀原则？什么是最左匹配原则？</p></blockquote><h3 id="影响mysql的性能因素"><a href="#影响mysql的性能因素" class="headerlink" title="影响mysql的性能因素"></a>影响mysql的性能因素</h3><ul><li>业务需求对MySQL的影响(合适合度)</li><li>存储定位对MySQL的影响<ul><li>不适合放进MySQL的数据<ul><li>二进制多媒体数据</li><li>流水队列数据</li><li>超大文本数据</li></ul></li><li>需要放进缓存的数据<ul><li>系统各种配置及规则数据</li><li>活跃用户的基本信息数据</li><li>活跃用户的个性化定制信息数据</li><li>准实时的统计信息数据</li><li>其他一些访问频繁但变更较少的数据</li></ul></li></ul></li><li>Schema设计对系统的性能影响<ul><li>尽量减少对数据库访问的请求</li><li>尽量减少无用数据的查询请求</li></ul></li><li>硬件环境对系统性能的影响</li></ul><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h3 id="MySQL-Query-Optimizer"><a href="#MySQL-Query-Optimizer" class="headerlink" title="MySQL Query Optimizer"></a>MySQL Query Optimizer</h3><ol><li>MySQL 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最优的执行计划（他认为最优的数据检索方式，但不见得是 DBA 认为是最优的，这部分最耗费时间）</li><li>当客户端向 MySQL 请求一条 Query，命令解析器模块完成请求分类，区别出是 SELECT 并转发给 MySQL Query Optimize r时，MySQL Query Optimizer 首先会对整条 Query 进行优化，处理掉一些常量表达式的预算，直接换算成常量值。并对 Query 中的查询条件进行简化和转换，如去掉一些无用或显而易见的条件、结构调整等。然后分析 Query 中的 Hint 信息（如果有），看显示 Hint 信息是否可以完全确定该 Query 的执行计划。如果没有 Hint 或 Hint 信息还不足以完全确定执行计划，则会读取所涉及对象的统计信息，根据 Query 进行写相应的计算分析，然后再得出最后的执行计划。</li></ol><h3 id="MySQL常见瓶颈"><a href="#MySQL常见瓶颈" class="headerlink" title="MySQL常见瓶颈"></a>MySQL常见瓶颈</h3><ul><li>CPU：CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据时候</li><li>IO：磁盘I/O瓶颈发生在装入数据远大于内存容量的时候</li><li>服务器硬件的性能瓶颈：top，free，iostat 和 vmstat来查看系统的性能状态</li></ul><h3 id="性能下降SQL慢-执行时间长-等待时间长-原因分析"><a href="#性能下降SQL慢-执行时间长-等待时间长-原因分析" class="headerlink" title="性能下降SQL慢 执行时间长 等待时间长 原因分析"></a>性能下降SQL慢 执行时间长 等待时间长 原因分析</h3><ul><li>查询语句写的烂</li><li>索引失效（单值、复合）</li><li>关联查询太多join（设计缺陷或不得已的需求）</li><li>服务器调优及各个参数设置（缓冲、线程数等）</li></ul><h3 id="MySQL常见性能分析手段"><a href="#MySQL常见性能分析手段" class="headerlink" title="MySQL常见性能分析手段"></a>MySQL常见性能分析手段</h3><p>在优化MySQL时，通常需要对数据库进行分析，常见的分析手段有<strong>慢查询日志</strong>，<strong>EXPLAIN 分析查询</strong>，<strong>profiling分析</strong>以及<strong>show命令查询系统状态及系统变量</strong>，通过定位分析性能的瓶颈，才能更好的优化数据库系统的性能。</p><h3 id="性能瓶颈定位"><a href="#性能瓶颈定位" class="headerlink" title="性能瓶颈定位"></a>性能瓶颈定位</h3><p>我们可以通过 show 命令查看 MySQL 状态及变量，找到系统的瓶颈：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Mysql&gt; show status ——显示状态信息（扩展show status like ‘XXX’）</span><br><span class="line"></span><br><span class="line">Mysql&gt; show variables ——显示系统变量（扩展show variables like ‘XXX’）</span><br><span class="line"></span><br><span class="line">Mysql&gt; show innodb status ——显示InnoDB存储引擎的状态</span><br><span class="line"></span><br><span class="line">Mysql&gt; show processlist ——查看当前SQL执行，包括执行状态、是否锁表等</span><br><span class="line"></span><br><span class="line">Shell&gt; mysqladmin variables -u username -p password——显示系统变量</span><br><span class="line"></span><br><span class="line">Shell&gt; mysqladmin extended-status -u username -p password——显示状态信息</span><br></pre></td></tr></table></figure><h3 id="Explain-执行计划"><a href="#Explain-执行计划" class="headerlink" title="Explain(执行计划)"></a>Explain(执行计划)</h3><p>是什么：使用 <strong>Explain</strong> 关键字可以模拟优化器执行SQL查询语句，从而知道 MySQL 是如何处理你的 SQL 语句的。分析你的查询语句或是表结构的性能瓶颈</p><p>能干吗：</p><ul><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ul><p>怎么玩：</p><ul><li>Explain + SQL语句</li><li>执行计划包含的信息（如果有分区表的话还会有<strong>partitions</strong>）</li></ul><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff38d5d8333.jpg" alt=""></p><p>各字段解释</p><ul><li><p><strong>id</strong>（select 查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序）</p><ul><li>id相同，执行顺序从上往下</li><li>id全不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li><li>id部分相同，执行顺序是先按照数字大的先执行，然后数字相同的按照从上往下的顺序执行</li></ul></li><li><p><strong>select_type</strong>（查询类型，用于区别普通查询、联合查询、子查询等复杂查询）</p><ul><li><strong>SIMPLE</strong> ：简单的select查询，查询中不包含子查询或UNION</li><li><strong>PRIMARY</strong>：查询中若包含任何复杂的子部分，最外层查询被标记为PRIMARY</li><li><strong>SUBQUERY</strong>：在select或where列表中包含了子查询</li><li><strong>DERIVED</strong>：在from列表中包含的子查询被标记为DERIVED，MySQL会递归执行这些子查询，把结果放在临时表里</li><li><strong>UNION</strong>：若第二个select出现在UNION之后，则被标记为UNION，若UNION包含在from子句的子查询中，外层select将被标记为DERIVED</li><li><strong>UNION RESULT</strong>：从UNION表获取结果的select</li></ul></li><li><p><strong>table</strong>（显示这一行的数据是关于哪张表的）</p></li><li><p><strong>type</strong>（显示查询使用了那种类型，从最好到最差依次排列    <strong>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong> ）</p><ul><li>system：表只有一行记录（等于系统表），是 const 类型的特例，平时不会出现</li><li>const：表示通过索引一次就找到了，const 用于比较 primary key 或 unique 索引，因为只要匹配一行数据，所以很快，如将主键置于 where 列表中，mysql 就能将该查询转换为一个常量</li><li>eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描</li><li>ref：非唯一性索引扫描，范围匹配某个单独值得所有行。本质上也是一种索引访问，他返回所有匹配某个单独值的行，然而，它可能也会找到多个符合条件的行，多以他应该属于查找和扫描的混合体</li><li>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询，这种范围扫描索引比全表扫描要好，因为它只需开始于索引的某一点，而结束于另一点，不用扫描全部索引</li><li>index：Full Index Scan，index于ALL区别为index类型只遍历索引树。通常比ALL快，因为索引文件通常比数据文件小。（<strong>也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的</strong>）</li><li>ALL：Full Table Scan，将遍历全表找到匹配的行</li></ul><p>tip: 一般来说，得保证查询至少达到range级别，最好到达ref</p></li><li><p><strong>possible_keys</strong>（显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段若存在索引，则该索引将被列出，但不一定被查询实际使用）</p></li><li><p><strong>key</strong></p><ul><li>实际使用的索引，如果为NULL，则没有使用索引</li><li><strong>查询中若使用了覆盖索引，则该索引和查询的 select 字段重叠，仅出现在key列表中</strong></li></ul></li></ul><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff38f6a6955.jpg" alt=""></p><ul><li><p>key_len</p><ul><li>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好</li><li>key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的</li></ul></li><li><p><strong>ref</strong> （显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值）</p></li><li><p><strong>rows</strong> （根据表统计信息及索引选用情况，大致估算找到所需的记录所需要读取的行数）</p></li><li><p>Extra</p><p>（包含不适合在其他列中显示但十分重要的额外信息）</p><ol><li>using filesort: 说明mysql会对数据使用一个外部的索引排序，不是按照表内的索引顺序进行读取。mysql中无法利用索引完成的排序操作称为“文件排序”。常见于order by和group by语句中</li><li>Using temporary：使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order by和分组查询group by。</li><li>using index：表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率不错，如果同时出现using where，表明索引被用来执行索引键值的查找；否则索引被用来读取数据而非执行查找操作</li><li>using where：使用了where过滤</li><li>using join buffer：使用了连接缓存</li><li>impossible where：where子句的值总是false，不能用来获取任何元祖</li><li>select tables optimized away：在没有group by子句的情况下，基于索引优化操作或对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化</li><li>distinct：优化distinct操作，在找到第一匹配的元祖后即停止找同样值的动作</li></ol></li></ul><p><strong>case</strong>:</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff39882383d.jpg" alt=""></p><ol><li>第一行（执行顺序4）：id列为1，表示是union里的第一个select，select_type列的primary表示该查询为外层查询，table列被标记为，表示查询结果来自一个衍生表，其中derived3中3代表该查询衍生自第三个select查询，即id为3的select。【select <a href="http://d1.name" target="_blank" rel="noopener">d1.name</a>……】</li><li>第二行（执行顺序2）：id为3，是整个查询中第三个select的一部分。因查询包含在from中，所以为derived。【select id,name from t1 where other_column=’’】</li><li>第三行（执行顺序3）：select列表中的子查询select_type为subquery，为整个查询中的第二个select。【select id from t3】</li><li>第四行（执行顺序1）：select_type为union，说明第四个select是union里的第二个select，最先执行【select name,id from t2】</li><li>第五行（执行顺序5）：代表从union的临时表中读取行的阶段，table列的&lt;union1,4&gt;表示用第一个和第四个select的结果进行union操作。【两个结果union操作】</li></ol><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>MySQL 的慢查询日志是 MySQL 提供的一种日志记录，它用来记录在 MySQL 中响应时间超过阈值的语句，具体指运行时间超过 <font color=red size=3><code>long_query_time</code></font> 值的 SQL，则会被记录到慢查询日志中。</p><ul><li><font color=red size=3><code>long_query_time</code></font>  的默认值为10，意思是运行10秒以上的语句</li><li>默认情况下，MySQL数据库没有开启慢查询日志，需要手动设置参数开启</li></ul><p><strong>查看开启状态</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%slow_query_log%'</span></span><br></pre></td></tr></table></figure><p><strong>开启慢查询日志</strong></p><ul><li>临时配置：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global slow_query_log='ON';</span><br><span class="line">mysql&gt; set global slow_query_log_file='/var/lib/mysql/hostname-slow.log';</span><br><span class="line">mysql&gt; set global long_query_time=2;</span><br><span class="line">也可<span class="keyword">set</span>文件位置，系统会默认给一个缺省文件host_name-slow.log</span><br><span class="line"></span><br><span class="line">使用<span class="keyword">set</span>操作开启慢查询日志只对当前数据库生效，如果MySQL重启则会失效。</span><br></pre></td></tr></table></figure><ul><li><p>永久配置</p><p>修改配置文件my.cnf或my.ini，在[mysqld]一行下面加入两个配置参数</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">slow_query_log = ON</span><br><span class="line">slow_query_log_file = /var/lib/mysql/hostname-slow.log</span><br><span class="line">long_query_time = 3</span><br></pre></td></tr></table></figure><p>注：log-slow-queries 参数为慢查询日志存放的位置，一般这个目录要有 MySQL 的运行帐号的可写权限，一般都将这个目录设置为 MySQL 的数据存放目录；long_query_time=2 中的 2 表示查询超过两秒才记录；在my.cnf或者 my.ini 中添加 log-queries-not-using-indexes 参数，表示记录下没有使用索引的查询。</p><p>可以用 <font color=red size=3><code>select sleep(4)</code></font> 验证是否成功开启。</p><p>在生产环境中，如果手工分析日志，查找、分析SQL，还是比较费劲的，所以MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p><p>通过 mysqldumpslow –help 查看操作帮助信息</p><ul><li><p>得到返回记录集最多的10个SQL</p><p><font color=red size=3><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log</code></font></p></li><li><p>得到访问次数最多的10个SQL</p><p><font color=red size=3><code>mysqldumpslow -s c -t 10 /var/lib/mysql/hostname-slow.log</code></font></p></li><li><p>得到按照时间排序的前10条里面含有左连接的查询语句</p><p><font color=red size=3><code>mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/hostname-slow.log</code></font></p></li><li><p>也可以和管道配合使用</p><p><font color=red size=3><code>mysqldumpslow -s r -t 10 /var/lib/mysql/hostname-slow.log | more</code></font></p></li></ul><p><strong>也可使用 pt-query-digest 分析 RDS MySQL 慢查询日志</strong></p><h3 id="Show-Profile-分析查询"><a href="#Show-Profile-分析查询" class="headerlink" title="Show Profile 分析查询"></a>Show Profile 分析查询</h3><p>通过慢日志查询可以知道哪些 SQL 语句执行效率低下，通过 explain 我们可以得知 SQL 语句的具体执行情况，索引使用等，还可以结合<font color=red size=3><code>Show Profile</code></font>命令查看执行状态。</p><ul><li><p>Show Profile 是 MySQL 提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p></li><li><p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p></li><li><p>分析步骤</p><ul><li><p>是否支持，看看当前的mysql版本是否支持</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;Show  variables like &#39;profiling&#39;;  --默认是关闭，使用前需要开启</span><br></pre></td></tr></table></figure></li><li><p>开启功能，默认是关闭，使用前需要开启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;set profiling&#x3D;1;</span><br></pre></td></tr></table></figure></li><li><p>运行SQL</p></li><li><p>查看结果</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------+</span></span><br><span class="line">| Query_ID | Duration | Query |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------+</span></span><br><span class="line">| 1 | 0.00385450 | <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"profiling"</span> |</span><br><span class="line">| <span class="number">2</span> | <span class="number">0.00170050</span> | <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">"profiling"</span> |</span><br><span class="line">| <span class="number">3</span> | <span class="number">0.00038025</span> | <span class="keyword">select</span> * <span class="keyword">from</span> t_base_user |</span><br><span class="line">+<span class="comment">----------+------------+---------------------------------+</span></span><br></pre></td></tr></table></figure><ul><li>诊断SQL，show profile cpu,block io for query id(上一步前面的问题SQL数字号码)</li><li>日常开发需要注意的结论<ul><li>converting HEAP to MyISAM 查询结果太大，内存都不够用了往磁盘上搬了。</li><li>create tmp table 创建临时表，这个要注意</li><li>Copying to tmp table on disk 把内存临时表复制到磁盘</li><li>locked</li></ul></li></ul></li></ul><blockquote><p>查询中哪些情况不会使用索引？</p></blockquote><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><ol><li>全值匹配我最爱</li><li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li><li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li><li>存储引擎不能使用索引中范围条件右边的列</li><li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li><li>is null ,is not null 也无法使用索引</li><li>like “xxxx%” 是可以用到索引的，like “%xxxx” 则不行(like “%xxx%” 同理)。like以通配符开头(‘%abc…’)索引失效会变成全表扫描的操作，</li><li>字符串不加单引号索引失效</li><li>少用or，用它来连接时会索引失效</li><li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li></ol><p><strong>一般性建议</strong></p><ul><li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li><li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li><li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li><li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li><li>少用Hint强制索引</li></ul><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p><strong>永远小标驱动大表（小的数据集驱动大的数据集）</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slect * from A where id in (select id from B)`等价于</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> B</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> A.id=B.id</span><br></pre></td></tr></table></figure><p>当 B 表的数据集必须小于 A 表的数据集时，用 in 优于 exists</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A <span class="keyword">where</span> <span class="keyword">exists</span> (<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> B <span class="keyword">where</span> B.id=A.id)</span><br><span class="line"><span class="comment">#等价于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> A</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> B <span class="keyword">where</span> B.id = A.id<span class="string">`</span></span><br></pre></td></tr></table></figure><p>当 A 表的数据集小于B表的数据集时，用 exists优于用 in</p><p>注意：A表与B表的ID字段应建立索引。</p><p><strong>order by关键字优化</strong></p><ul><li>order by子句，尽量使用 Index 方式排序，避免使用 FileSort 方式排序</li><li>MySQL 支持两种方式的排序，FileSort 和 Index，Index效率高，它指 MySQL 扫描索引本身完成排序，FileSort 效率较低；</li><li>ORDER BY 满足两种情况，会使用Index方式排序；①ORDER BY语句使用索引最左前列 ②使用where子句与ORDER BY子句条件列组合满足索引最左前列</li><li>尽可能在索引列上完成排序操作，遵照索引建的最佳最前缀</li><li>如果不在索引列上，filesort 有两种算法，mysql就要启动双路排序和单路排序<ul><li>双路排序：MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</li><li>单路排序：从磁盘读取查询需要的所有列，按照order by 列在 buffer对它们进行排序，然后扫描排序后的列表进行输出，效率高于双路排序</li></ul></li><li>优化策略<ul><li>增大sort_buffer_size参数的设置</li><li>增大max_lencth_for_sort_data参数的设置</li></ul></li></ul><p><strong>GROUP BY关键字优化</strong></p><ul><li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li><li>当无法使用索引列，增大 <code>max_length_for_sort_data</code> 参数的设置，增大<code>sort_buffer_size</code>参数的设置</li><li>where高于having，能写在where限定的条件就不要去having限定了</li></ul><h3 id="数据类型优化"><a href="#数据类型优化" class="headerlink" title="数据类型优化"></a>数据类型优化</h3><p>MySQL 支持的数据类型非常多，选择正确的数据类型对于获取高性能至关重要。不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p><ul><li><p>更小的通常更好：一般情况下，应该尽量使用可以正确存储数据的最小数据类型。</p><p>简单就好：简单的数据类型通常需要更少的CPU周期。例如，整数比字符操作代价更低，因为字符集和校对规则（排序规则）使字符比较比整型比较复杂。</p></li><li><p>尽量避免NULL：通常情况下最好指定列为NOT NULL</p></li></ul><hr><h2 id="九、分区、分表、分库"><a href="#九、分区、分表、分库" class="headerlink" title="九、分区、分表、分库"></a>九、分区、分表、分库</h2><hr><h3 id="MySQL分区"><a href="#MySQL分区" class="headerlink" title="MySQL分区"></a>MySQL分区</h3><p>一般情况下我们创建的表对应一组存储文件，使用<code>MyISAM</code>存储引擎时是一个<code>.MYI</code>和<code>.MYD</code>文件，使用<code>Innodb</code>存储引擎时是一个<code>.ibd</code>和<code>.frm</code>（表结构）文件。</p><p>当数据量较大时（一般千万条记录级别以上），MySQL的性能就会开始下降，这时我们就需要将数据分散到多组存储文件，保证其单个文件的执行效率</p><p><strong>能干嘛</strong></p><ul><li>逻辑数据分割</li><li>提高单一的写和读应用速度</li><li>提高分区范围读查询的速度</li><li>分割数据能够有多个不同的物理文件路径</li><li>高效的保存历史数据</li></ul><p><strong>怎么玩</strong></p><p>首先查看当前数据库是否支持分区</p><ul><li><p>MySQL5.6以及之前版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;%partition%&#39;;</span><br></pre></td></tr></table></figure></li><li><p>MySQL5.6：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show plugins;</span><br></pre></td></tr></table></figure></li></ul><p><strong>分区类型及操作</strong></p><ul><li><p><strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。</p><p>按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。</p><p>range 来分，好处在于说，扩容的时候很简单。</p></li><li><p><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</p></li><li><p><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。</p><p>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</p></li><li><p><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</p></li></ul><p><strong>看上去分区表很帅气，为什么大部分互联网还是更多的选择自己分库分表来水平扩展咧？</strong></p><ul><li>分区表，分区键设计不太灵活，如果不走分区键，很容易出现全表锁</li><li>一旦数据并发量上来，如果在分区表实施关联，就是一个灾难</li><li>自己分库分表，自己掌控业务场景与访问模式，可控。分区表，研发写了一个sql，都不确定mysql是怎么玩的，不太可控</li></ul><blockquote><p>随着业务的发展，业务越来越复杂，应用的模块越来越多，总的数据量很大，高并发读写操作均超过单个数据库服务器的处理能力怎么办？</p></blockquote><p>这个时候就出现了<strong>数据分片</strong>，数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中。数据分片的有效手段就是对关系型数据库进行分库和分表。</p><p>区别于分区的是，分区一般都是放在单机里的，用的比较多的是时间范围分区，方便归档。只不过分库分表需要代码实现，分区则是mysql内部实现。分库分表和分区并不冲突，可以结合使用。</p><blockquote><p>说说分库与分表的设计</p></blockquote><h3 id="MySQL分表"><a href="#MySQL分表" class="headerlink" title="MySQL分表"></a>MySQL分表</h3><p>分表有两种分割方式，一种垂直拆分，另一种水平拆分。</p><ul><li><p><strong>垂直拆分</strong></p><p>垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p></li><li><p><strong>水平拆分(数据分片)</strong></p><p>单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。</p><p>水平分割的几种方法：</p><ul><li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</li><li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li><li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li><li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li></ul></li></ul><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff39ffffdd1.jpg" alt=""></p><h3 id="MySQL分库"><a href="#MySQL分库" class="headerlink" title="MySQL分库"></a>MySQL分库</h3><blockquote><p>为什么要分库?</p></blockquote><p>数据库集群环境后都是多台 slave，基本满足了读取操作; 但是写入或者说大数据、频繁的写入操作对master性能影响就比较大，这个时候，单库并不能解决大规模并发写入的问题，所以就会考虑分库。</p><blockquote><p>分库是什么？</p></blockquote><p>一个库里表太多了，导致了海量数据，系统性能下降，把原本存储于一个库的表拆分存储到多个库上， 通常是将表按照功能模块、关系密切程度划分出来，部署到不同库上。</p><p>优点：</p><ul><li>减少增量数据写入时的锁对查询的影响</li><li>由于单表数量下降，常见的查询操作由于减少了需要扫描的记录，使得单表单次查询所需的检索行数变少，减少了磁盘IO，时延变短</li></ul><p>但是它无法解决单表数据量太大的问题</p><p><strong>分库分表后的难题</strong></p><p>分布式事务的问题，数据的完整性和一致性问题。</p><p>数据操作维度问题：用户、交易、订单各个不同的维度，用户查询维度、产品数据分析维度的不同对比分析角度。 跨库联合查询的问题，可能需要两次查询 跨节点的count、order by、group by以及聚合函数问题，可能需要分别在各个节点上得到结果后在应用程序端进行合并 额外的数据管理负担，如：访问数据表的导航定位 额外的数据运算压力，如：需要在多个节点执行，然后再合并计算程序编码开发难度提升，没有太好的框架解决，更多依赖业务看如何分，如何合，是个难题。</p><blockquote><p>配主从，正经公司的话，也不会让 Javaer 去搞的，但还是要知道</p></blockquote><h2 id="十、主从复制"><a href="#十、主从复制" class="headerlink" title="十、主从复制"></a>十、主从复制</h2><hr><h3 id="复制的基本原理"><a href="#复制的基本原理" class="headerlink" title="复制的基本原理"></a>复制的基本原理</h3><ul><li><p>slave 会从 master 读取 binlog 来进行数据同步</p></li><li><p>三个步骤</p><ol><li>master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；</li><li>salve 将 master 的 binary log events 拷贝到它的中继日志（relay log）;</li><li>slave 重做中继日志中的事件，将改变应用到自己的数据库中。MySQL 复制是异步且是串行化的。</li></ol><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/1734bff3c7c7b231.jpg" alt=""></p></li></ul><h3 id="复制的基本原则"><a href="#复制的基本原则" class="headerlink" title="复制的基本原则"></a>复制的基本原则</h3><ul><li>每个 slave只有一个 master</li><li>每个 salve只能有一个唯一的服务器 ID</li><li>每个master可以有多个salve</li></ul><h3 id="复制的最大问题"><a href="#复制的最大问题" class="headerlink" title="复制的最大问题"></a>复制的最大问题</h3><ul><li>延时</li></ul><hr><h2 id="十一、其他问题"><a href="#十一、其他问题" class="headerlink" title="十一、其他问题"></a>十一、其他问题</h2><hr><h3 id="说一说三个范式"><a href="#说一说三个范式" class="headerlink" title="说一说三个范式"></a>说一说三个范式</h3><ul><li>第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</li><li>第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</li><li>第三范式（3NF）：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如 果存在”A → B → C”的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系： 关键字段 → 非关键字段 x → 非关键字段y</li></ul><h3 id="百万级别或以上的数据如何删除"><a href="#百万级别或以上的数据如何删除" class="headerlink" title="百万级别或以上的数据如何删除"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p><ol><li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li><li>然后删除其中无用数据（此过程需要不到两分钟）</li><li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li><li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li></ol><h2 id="参考与感谢："><a href="#参考与感谢：" class="headerlink" title="参考与感谢："></a>参考与感谢：</h2><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/29150809</a></p><p><a href="https://juejin.im/post/5e3eb616f265da570d734dcb#heading-105" target="_blank" rel="noopener">juejin.im/post/5e3eb6…</a></p><p><a href="https://blog.csdn.net/yin767833376/article/details/81511377" target="_blank" rel="noopener">blog.csdn.net/yin76783337…</a></p>]]></content>
    
    <summary type="html">
    
      和其它数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其它的系统任务以及数...
    
    </summary>
    
    
      <category term="直击面试" scheme="http://yoursite.com/categories/%E7%9B%B4%E5%87%BB%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>[Docker通关手册]</title>
    <link href="http://yoursite.com/2022/03/21/Docker%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/"/>
    <id>http://yoursite.com/2022/03/21/Docker%E9%80%9A%E5%85%B3%E6%89%8B%E5%86%8C/</id>
    <published>2022-03-21T12:29:59.000Z</published>
    <updated>2022-03-21T13:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人建议把面试题看作是费曼学习法中的回顾、简化的环节，准备面试的时候，跟着题目先自己讲给自己听，看看自己会满意吗，不满意就继续学习这个点，如此反复，好的offer离你不远的，奥利给</p><p>…</p></blockquote><blockquote><p>成长手册，<strong>GitHub</strong> <a href="https://github.com/rogerXS80/roger" target="_blank" rel="noopener">Lupinus</a> ，N线互联网开发必备技能兵器谱</p></blockquote><h1 id="Docker通关手册"><a href="#Docker通关手册" class="headerlink" title="Docker通关手册"></a>Docker通关手册</h1><h2 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a>Docker是什么？</h2><p>最广泛的开源容器引擎</p><p>一种操作系统级的虚拟化技术</p><p>依赖于Linux内核特性：Namespace（<strong>资源隔离</strong>）和Cgroups（<strong>资源限制</strong>）</p><p>一个简单的应用程序打包工具</p><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><p>如果已经安装了，运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                 docker-client \</span><br><span class="line">                 docker-client-latest \</span><br><span class="line">                 docker-common \</span><br><span class="line">                 docker-latest \</span><br><span class="line">                 docker-latest-logrotate \</span><br><span class="line">                 docker-logrotate \</span><br><span class="line">                 docker-engine</span><br></pre></td></tr></table></figure><p>安装docker工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 Docker所需的依赖</span></span><br><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加软件源信息</span></span><br><span class="line">yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Docker CE</span></span><br><span class="line">yum install docker-ce -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重新加载 配置文件</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 Docker服务</span></span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 Docker服务 加入开机自启</span></span><br><span class="line">systemctl enable --now docker.service</span><br><span class="line">Created symlink <span class="keyword">from</span> /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br><span class="line">        </span><br><span class="line"><span class="comment"># yum源工作目录</span></span><br><span class="line">/etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure><h2 id="Docker基本组成"><a href="#Docker基本组成" class="headerlink" title="Docker基本组成"></a>Docker基本组成</h2><img src="https://gitee.com/wjxyzs/img/raw/master/img/docker%E7%BB%84%E6%88%90.png" style="zoom: 67%;" /><h2 id="Docker核心组件"><a href="#Docker核心组件" class="headerlink" title="Docker核心组件"></a>Docker核心组件</h2><img src="https://gitee.com/wjxyzs/img/raw/master/img/docker%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6.png" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Docker Daemon：Docker守护进程，负责与Docker Clinet交互，并管理镜像、</span><br><span class="line">容器。</span><br><span class="line">Containerd：是一个简单的守护进程，向上给Docker Daemon提供接口，向下</span><br><span class="line">通过containerd-shim结合runC管理容器。</span><br><span class="line">runC：一个命令行工具，它根据OCI标准来创建和运行容器。</span><br></pre></td></tr></table></figure><h2 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">• 一个分层存储的文件，不是一个单一的文件 </span><br><span class="line">• 一个软件的环境 </span><br><span class="line">• 一个镜像可以创建N个容器 </span><br><span class="line">• 一种标准化的交付 </span><br><span class="line">• 一个不包含Linux内核而又精简的Linux操作系统</span><br></pre></td></tr></table></figure><h3 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"registry-mirrors"</span>: [<span class="string">"https://rxsa4cyh.mirror.aliyuncs.com]</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="镜像常用指令"><a href="#镜像常用指令" class="headerlink" title="镜像常用指令"></a>镜像常用指令</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">images</td><td align="center">列出镜像</td></tr><tr><td align="center">build</td><td align="center">构建镜像来自Dockerfile</td></tr><tr><td align="center">history</td><td align="center">查看镜像历史</td></tr><tr><td align="center">inspect</td><td align="center">显示一个或多个镜像详细信息</td></tr><tr><td align="center">pull</td><td align="center">从镜像仓库拉取镜像</td></tr><tr><td align="center">push</td><td align="center">推送一个镜像到镜像仓库</td></tr><tr><td align="center">rmi</td><td align="center">移除一个或多个镜像</td></tr><tr><td align="center">prune</td><td align="center">移除没有被标记或者没有被任何容器引用的镜像</td></tr><tr><td align="center">tag</td><td align="center">创建一个引用源镜像标记目标镜像</td></tr></tbody></table><h2 id="镜像存储核心技术"><a href="#镜像存储核心技术" class="headerlink" title="镜像存储核心技术"></a>镜像存储核心技术</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">储存驱动: overlay2（性能好）</span><br></pre></td></tr></table></figure><h3 id="联合文件系统（UnionFS"><a href="#联合文件系统（UnionFS" class="headerlink" title="联合文件系统（UnionFS)"></a>联合文件系统（UnionFS)</h3><img src="https://gitee.com/wjxyzs/img/raw/master/img/%E9%95%9C%E5%83%8F%E4%B8%8E%E5%AE%B9%E5%99%A8.png" style="zoom:67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">联合文件系统：将镜像多层文件联合挂载到容器文件系统</span><br></pre></td></tr></table></figure><h3 id="写时复制（COW）"><a href="#写时复制（COW）" class="headerlink" title="写时复制（COW）"></a>写时复制（COW）</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/docker%E5%AD%98%E5%82%A8%E6%9E%B6%E6%9E%84.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">写时复制：需要修改文件操作时，会先从镜像里把要写的文件复制到自己的文件系统中进行修改</span><br></pre></td></tr></table></figure><h3 id="Docker读写优化"><a href="#Docker读写优化" class="headerlink" title="Docker读写优化"></a>Docker读写优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SSD固态硬盘（工作目录：/var/lib/docker）</span><br><span class="line">使用卷作为频繁读写文件的工作目录，绕过储存驱动，减少抽象开销</span><br></pre></td></tr></table></figure><h2 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h2><h3 id="创建容器常用选项"><a href="#创建容器常用选项" class="headerlink" title="创建容器常用选项"></a>创建容器常用选项</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-i</td><td align="center">交互式</td></tr><tr><td align="center">-t</td><td align="center">分配一个伪终端</td></tr><tr><td align="center">-d</td><td align="center">运行容器到后台</td></tr><tr><td align="center">-e</td><td align="center">设置环境变量</td></tr><tr><td align="center">-p</td><td align="center">发布容器端口到主机</td></tr><tr><td align="center">–name</td><td align="center">指定容器名字</td></tr><tr><td align="center">-h</td><td align="center">指定容器主机名</td></tr><tr><td align="center">-ip</td><td align="center">指定容器IP，只能用于自定义网络</td></tr><tr><td align="center">-network</td><td align="center">连接容器到一个网络</td></tr><tr><td align="center">-m</td><td align="center">将文件系统附加到容器</td></tr><tr><td align="center">-v</td><td align="center">绑定挂载一个卷</td></tr><tr><td align="center">-restart</td><td align="center">容器退出时重启策略，默认no，可选值：[always|on-failure]</td></tr></tbody></table><p>挂载宿主机三个文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostname       --hostname</span><br><span class="line">hosts          --dns</span><br><span class="line">resolc.conf    --add-host</span><br></pre></td></tr></table></figure><h3 id="容器资源限制"><a href="#容器资源限制" class="headerlink" title="容器资源限制"></a>容器资源限制</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-m</td><td align="center">容器可以使用的最大内存量（）</td></tr><tr><td align="center">–memory-swap</td><td align="center">允许交换到磁盘的内存量</td></tr><tr><td align="center">–memory-swappiness=&lt;0-100&gt;</td><td align="center">容器使用SWAP分区交换的百分比（0-100，默认为-1）</td></tr><tr><td align="center">–oom-kill-disable</td><td align="center">禁用OOM Killer</td></tr><tr><td align="center">–cpus</td><td align="center">可以使用的CPU数量</td></tr><tr><td align="center">–cpuset-cpus</td><td align="center">限制容器使用特定的CPU核心，如(0-3, 0,1)</td></tr><tr><td align="center">–cpu-shares</td><td align="center">CPU共享（相对权重）</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">默认创建的容器使用宿主机所有资源</span><br><span class="line">主要用于每个容器能够平均分配到宿主机资源</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存限额：</span></span><br><span class="line"><span class="comment"># 允许容器最多使用500M内存和100M的Swap，并禁用 OOM Killer：</span></span><br><span class="line">docker run -d --name nginx01 -m=<span class="string">"500m"</span> --memory-swap=<span class="string">"100m"</span> --oom-kill-disable nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU限额：</span></span><br><span class="line"><span class="comment"># 允许容器最多使用一个半的CPU：</span></span><br><span class="line">docker run -d --name nginx02 --cpus=<span class="string">"1.5"</span> nginx</span><br><span class="line"><span class="comment"># 允许容器最多使用50%的CPU：</span></span><br><span class="line">docker run -d --name nginx03 --cpus=<span class="string">".5"</span> nginx</span><br></pre></td></tr></table></figure><h3 id="管理容器常用指令"><a href="#管理容器常用指令" class="headerlink" title="管理容器常用指令"></a>管理容器常用指令</h3><table><thead><tr><th align="center">指令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">ls</td><td align="center">列出容器</td></tr><tr><td align="center">inspect</td><td align="center">查看一个或多个容器详细信息</td></tr><tr><td align="center">exec</td><td align="center">在运行容器中执行命令</td></tr><tr><td align="center">commit</td><td align="center">创建一个新镜像来自一个容器</td></tr><tr><td align="center">cp</td><td align="center">拷贝文件/文件夹到一个容器</td></tr><tr><td align="center">logs</td><td align="center">获取一个容器日志</td></tr><tr><td align="center">port</td><td align="center">列出或指定容器端口映射</td></tr><tr><td align="center">top</td><td align="center">显示一个容器运行的进程</td></tr><tr><td align="center">stats</td><td align="center">显示容器资源使用统计</td></tr><tr><td align="center">stop/start/restart</td><td align="center">停止/启动一个或多个容器</td></tr><tr><td align="center">rm</td><td align="center">删除一个或多个容器</td></tr><tr><td align="center">prune</td><td align="center">移除已停止的容器</td></tr></tbody></table> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看容器</span></span><br><span class="line">docker ps</span><br><span class="line">docker ps -a  // 查看所有的容器</span><br><span class="line">docker ps -q  // 查看所有的容器id</span><br><span class="line">docker ps -l  // 查看最新创建的容器</span><br><span class="line"></span><br><span class="line">docker top 容器名    // 查看容器中的进程</span><br><span class="line"></span><br><span class="line">docker stats 容器名  // 容器资源统计信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行基础镜像</span></span><br><span class="line">docker run -it centos</span><br><span class="line"><span class="comment"># 运行应用镜像</span></span><br><span class="line">docker run -d nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">docker <span class="keyword">exec</span> -it centos bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除容器</span></span><br><span class="line">docker rm centos</span><br><span class="line"><span class="comment"># 批量删除容器</span></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝文件</span></span><br><span class="line">docker cp nginx.tar 容器名:/opt</span><br><span class="line">docker cp 容器名:/opt/nginx ./</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 更新容器配置（部分可以修改）</span></span><br><span class="line">docker update --help</span><br></pre></td></tr></table></figure><h2 id="容器实现核心技术"><a href="#容器实现核心技术" class="headerlink" title="容器实现核心技术"></a>容器实现核心技术</h2><h3 id="命名空间（Namespace）"><a href="#命名空间（Namespace）" class="headerlink" title="命名空间（Namespace）"></a>命名空间（Namespace）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">将特定的全局系统资源通过抽象方法使得Namespace中的进程看起来拥有自己隔离的资源</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6种不同命名空间</span></span><br><span class="line">ll /proc/$$/ns</span><br><span class="line"><span class="number">1</span> IPC:：隔离进程间通信</span><br><span class="line"><span class="number">2</span> MOUNT：隔离文件系统挂载点</span><br><span class="line"><span class="number">3</span> NET：隔离网络协议栈</span><br><span class="line"><span class="number">4</span> PID：隔离进程号，进程命名空间是一个父子结构，子空间对父空间可见</span><br><span class="line"><span class="number">5</span> USER：隔离用户</span><br><span class="line"><span class="number">6</span> UTS：隔离主机名和域名</span><br></pre></td></tr></table></figure><h2 id="控制组（CGroups）"><a href="#控制组（CGroups）" class="headerlink" title="控制组（CGroups）"></a>控制组（CGroups）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">如果某个容器属于CPU密集型任务，那么会影响其他容器使用CPU，导致多个容器相互影响并抢占资源</span><br><span class="line">CGroups：所有任务就是运行在系统中的一个进程，而CGroups以某种标准将一组进程为目标进行资源分配和控制，并且可以动态配置</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主要功能</span></span><br><span class="line">-限制进程组使用的资源数量：可以为进程组设定资源使用上限，例如内存（***）</span><br><span class="line">-进程组优先控制：可以为进程组分配特定CPU,磁盘IO吞吐量</span><br><span class="line">-记录进程组使用的资源数量：例如使用记录某个进程组使用的CPU时间</span><br><span class="line">-可以将进程组挂起和恢复</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看cgroup可控制资源</span></span><br><span class="line">ls /sys/fs/cgroup/&lt;资源名&gt;/docker -l</span><br></pre></td></tr></table></figure><h3 id="工具镜像"><a href="#工具镜像" class="headerlink" title="工具镜像"></a>工具镜像</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd busy:<span class="number">1.28</span><span class="number">.4</span></span><br><span class="line">docker <span class="keyword">exec</span> -it 容器名 sh</span><br></pre></td></tr></table></figure><h2 id="容器数据持久化"><a href="#容器数据持久化" class="headerlink" title="容器数据持久化"></a>容器数据持久化</h2><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E6%96%B9%E5%BC%8F.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Docker提供两种方式将数据从宿主机挂载到容器中：</span><br><span class="line">• volumes：Docker管理宿主机文件系统的一部分（/var/lib/docker/volumes）。保存数据的最佳方式。</span><br><span class="line">• bind mounts：将宿主机上的任意位置的文件或者目录挂载到容器中。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line">/var/lib/docker/volumes</span><br><span class="line"></span><br><span class="line"><span class="comment">### volume </span></span><br><span class="line">docker volume --help</span><br><span class="line"></span><br><span class="line"><span class="comment"># 管理卷：</span></span><br><span class="line">docker volume create nginx-vol</span><br><span class="line">docker volume ls</span><br><span class="line">docker volume inspect nginx-vol</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用卷创建一个容器：</span></span><br><span class="line">docker run -d --name=nginx-test --mount src=nginx-vol,dst=/usr/share/nginx/html nginx</span><br><span class="line">docker run -d --name=nginx-test -v nginx-vol:/usr/share/nginx/html nginx</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 清理：</span></span><br><span class="line">docker stop nginx-test</span><br><span class="line">docker rm nginx-test </span><br><span class="line">docker volume rm nginx-vol</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"><span class="number">1.</span> 如果没有指定卷，自动创建。</span><br><span class="line"></span><br><span class="line"><span class="comment">### bind mount</span></span><br><span class="line"><span class="comment"># 用卷创建一个容器：</span></span><br><span class="line">docker run -d --name=nginx-test --mount type=bind,src=/app/wwwroot,dst=/usr/share/nginx/html nginx</span><br><span class="line">docker run -d --name=nginx-test -v /app/wwwroot:/usr/share/nginx/html nginx</span><br><span class="line"><span class="comment"># 验证绑定：</span></span><br><span class="line">docker inspect nginx-test</span><br><span class="line"><span class="comment"># 清理：</span></span><br><span class="line">docker stop nginx-test </span><br><span class="line">docker rm nginx-test </span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"><span class="number">1.</span> 如果源文件/目录没有存在如果挂载目标在容器中非空目录，则该目录现有内容将被隐藏。</span><br></pre></td></tr></table></figure><h2 id="四种网络模式"><a href="#四种网络模式" class="headerlink" title="四种网络模式"></a>四种网络模式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-bridege：--net=bridge，Docker启动创建一个docker0网桥，默认创建的容器页是添加到这个网桥中。</span><br><span class="line">-host：--net=host，容器不会获得一个独立的network namespace，而是与宿主机公用一个。容器除了网络都是隔离的。</span><br><span class="line">-none：--net=none，获取独立的network namespace，但部位容器进行任何网络配置，需要手动配置。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用场景</span></span><br><span class="line">host：希望使用宿主机网络</span><br><span class="line">none：手动配置容器网络，对接公司IPAM</span><br><span class="line">container：希望容器与另一个容器在一个网络命名空间</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建网桥</span></span><br><span class="line">docker network create test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络</span></span><br><span class="line">docker network ls</span><br></pre></td></tr></table></figure><h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">veth pair：成对出现的一种虚拟网络设备，数据从一端进，从另一端出。用于解决网络命名空间之间隔离。</span><br><span class="line">docker：网桥是一个二层网络设备，通过网桥可以将Linux支持的不同端口连接起撸，并实现类似交换机那样的多对多的通信。</span><br></pre></td></tr></table></figure><h3 id="容器网络访问原理"><a href="#容器网络访问原理" class="headerlink" title="容器网络访问原理"></a>容器网络访问原理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实验</span></span><br><span class="line">docker run -d -p <span class="number">88</span>:<span class="number">80</span> ngxin</span><br><span class="line">docker logs 容器名 -f</span><br></pre></td></tr></table></figure><h3 id="容器网络实现核心技术（iptables）"><a href="#容器网络实现核心技术（iptables）" class="headerlink" title="容器网络实现核心技术（iptables）"></a>容器网络实现核心技术（iptables）</h3><table><thead><tr><th align="center">表</th><th align="center">链</th></tr></thead><tbody><tr><td align="center">filter（过滤）</td><td align="center">INPUT，OUTPUT，FORWORD</td></tr><tr><td align="center">nat（地址转发）</td><td align="center">PREROUTING，POSTROUTING，OUTPUT</td></tr><tr><td align="center">mangle（拆包，修改，封装）</td><td align="center">INPUT，OUTPUT，FORWARD，PREROUTING，POSTROUTING</td></tr><tr><td align="center">raw（数据包状态跟踪）</td><td align="center">PREROUTING，OUTPUT</td></tr></tbody></table><img src="https://gitee.com/wjxyzs/img/raw/master/img/iptables%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" style="zoom:80%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">INPUT链：接收的数据包是本机（入站）时，应用此链中的规则</span><br><span class="line">OUTPUT链：本机向外发送数据包（出站）时，应用此链中的规则</span><br><span class="line">FORWARD链：需要通过防火墙中转发送给其他地址的数据包（转发）时，应用此链中的规则</span><br><span class="line">PREROUTING链：在对数据包做路由选择之前，应用此链中的规则（DNAT）</span><br><span class="line">POSTROUTING链：在对数据包做路由选择之后，应用此链中的规则（SNAT）</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 外部访问容器</span></span><br><span class="line"><span class="comment"># DNAT：目标地址转换，修改数据包目标IP</span></span><br><span class="line">iptables -t nat -vnL DOCKER</span><br><span class="line">Chain DOCKER (<span class="number">2</span> references)</span><br><span class="line">pkts bytes target prot opt <span class="keyword">in</span> out source destination </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> RETURN all -- docker0 * <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span> </span><br><span class="line"><span class="number">1</span> <span class="number">52</span> DNAT tcp -- !docker0 * <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span> tcp dpt:<span class="number">8080</span> to:<span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span>:<span class="number">80</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 容器访问外部</span></span><br><span class="line"><span class="comment"># SNAT：修改源IP为宿主机IP向外发出</span></span><br><span class="line">iptables -t nat -vnL POSTROUTING</span><br><span class="line">Chain POSTROUTING (policy ACCEPT <span class="number">0</span> packets, <span class="number">0</span> bytes)</span><br><span class="line">pkts bytes target prot opt <span class="keyword">in</span> out source destination </span><br><span class="line"><span class="number">0</span> <span class="number">0</span> MASQUERADE all -- * !docker0 <span class="number">172.17</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">16</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="容器多主机通信"><a href="#容器多主机通信" class="headerlink" title="容器多主机通信"></a>容器多主机通信</h3><img src="https://gitee.com/wjxyzs/img/raw/master/img/docker%E5%A4%9A%E4%B8%BB%E6%9C%BA%E9%80%9A%E4%BF%A1.png" style="zoom:80%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flannel是CoreOS维护的一个网络组件，在每个主机上运行守护进程负责维护本地路由准发，Flannel使用ETCD来存储容器网络与主机之前的关系。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遇到的问题</span></span><br><span class="line">两台主机容器进行通信，会走FORWORD链执行DROP</span><br><span class="line"><span class="comment"># 解决方案</span></span><br><span class="line">iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      最广泛的开源容器引擎，一种操作系统级的虚拟化技术，依赖于Linux内核特性：Namespace（**资源隔离**）和Cgroups（**资源限制**），一个简单的应用程序打包工具...
    
    </summary>
    
    
      <category term="CI/CD" scheme="http://yoursite.com/categories/CI-CD/"/>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>[NoSQL的前世今生]</title>
    <link href="http://yoursite.com/2022/03/08/NoSQL%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <id>http://yoursite.com/2022/03/08/NoSQL%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</id>
    <published>2022-03-08T04:13:25.000Z</published>
    <updated>2022-04-12T00:34:29.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>成长手册，<strong>GitHub</strong> <a href="https://github.com/rogerXS80/roger" target="_blank" rel="noopener">Lupinus</a> ，N线互联网开发必备技能兵器谱</p></blockquote><h2 id="啥玩意："><a href="#啥玩意：" class="headerlink" title="啥玩意："></a>啥玩意：</h2><p>NoSQL(NoSQL = Not Only SQL )，“不仅仅是SQL”，泛指<strong>非关系型的数据库</strong>。随着互联网web2.0网站的兴起，传统的关系数据库在处理web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。</p><h3 id="互联网时代背景下，数据库的发展以及为什么要用nosql"><a href="#互联网时代背景下，数据库的发展以及为什么要用nosql" class="headerlink" title="互联网时代背景下，数据库的发展以及为什么要用nosql"></a>互联网时代背景下，数据库的发展以及为什么要用nosql</h3><h4 id="1-单机MySQL的美好年代"><a href="#1-单机MySQL的美好年代" class="headerlink" title="1. 单机MySQL的美好年代"></a>1. 单机MySQL的美好年代</h4><p> 在以前，一个网站的访问量一般都不大，用单个数据库完全可以轻松应付。在那个时候，更多的都是静态网页，动态交互类型的网站不多。上述架构下，我们来看看数据存储的瓶颈是什么？</p><ul><li>数据量的总大小 一个机器放不下时</li><li>数据的索引（B+ Tree）一个机器的内存放不下时</li><li>访问量(读写混合)一个实例不能承受</li></ul><h4 id="2-Memcached-缓存-MySQL-垂直拆分"><a href="#2-Memcached-缓存-MySQL-垂直拆分" class="headerlink" title="2. Memcached(缓存)+MySQL+垂直拆分"></a>2. Memcached(缓存)+MySQL+垂直拆分</h4><p> 后来，随着访问量的上升，几乎大部分使用MySQL架构的网站在数据库上都开始出现了性能问题，web程序不再仅仅专注在功能上，同时也在追求性能。程序员们开始大量的使用<strong>缓存技术</strong>来缓解数据库的压力，优化数据库的结构和索引。开始比较流行的是通过<strong>文件缓存</strong>来缓解数据库压力，但是当访问量继续增大的时候，多台web机器通过文件缓存不能共享，大量的小文件缓存也带了了比较高的IO压力。在这个时候，Memcached就自然的成为一个非常时尚的技术产品。</p><p> Memcached作为一个<strong>独立的分布式的缓存服务器</strong>，为多个web服务器提供了一个共享的高性能缓存服务，在Memcached服务器上，又发展了根据hash算法来进行多台Memcached缓存服务的扩展，然后又出现了一致性hash来解决增加或减少缓存服务器导致重新hash带来的大量缓存失效的弊端</p><h4 id="3-Mysql主从读写分离"><a href="#3-Mysql主从读写分离" class="headerlink" title="3. Mysql主从读写分离"></a>3. Mysql主从读写分离</h4><p> 由于数据库的写入压力增加，Memcached只能缓解数据库的读取压力。读写集中在一个数据库上让数据库不堪重负，大部分网站开始<strong>使用主从复制技术来达到读写分离，以提高读写性能和读库的可扩展性</strong>。<strong>Mysql的master-slave模式</strong>成为这个时候的网站标配了。</p><h4 id="4-分表分库-水平拆分-mysql集群"><a href="#4-分表分库-水平拆分-mysql集群" class="headerlink" title="4. 分表分库+水平拆分+mysql集群"></a>4. 分表分库+水平拆分+mysql集群</h4><p> 在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，这时MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于<strong>MyISAM</strong>使用<strong>表锁</strong>，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用<strong>InnoDB</strong>引擎代替MyISAM。</p><p> 同时，开始流行<strong>使用分表分库来缓解写压力和数据增长的扩展问题</strong>。这个时候，分表分库成了一个热门技术，是面试的热门问题也是业界讨论的热门技术问题。也就在这个时候，MySQL推出了还不太稳定的表分区，这也给技术实力一般的公司带来了希望。虽然MySQL推出了MySQL Cluster集群，但性能也不能很好满足互联网的要求，只是在高可靠性上提供了非常大的保证。</p><h4 id="5-MySQL的扩展性瓶颈"><a href="#5-MySQL的扩展性瓶颈" class="headerlink" title="5. MySQL的扩展性瓶颈"></a>5. MySQL的扩展性瓶颈</h4><p> MySQL数据库也经常存储一些大文本字段，导致数据库表非常的大，在做数据库恢复的时候就导致非常的慢，不容易快速恢复数据库。比如1000万4KB大小的文本就接近40GB的大小，如果能把这些数据从MySQL省去，MySQL将变得非常的小。关系数据库很强大，但是它并不能很好的应付所有的应用场景。MySQL的扩展性差（需要复杂的技术来实现），大数据下IO压力大，表结构更改困难，正是当前使用MySQL的开发人员面临的问题。</p><h4 id="6-为什么用NoSQL"><a href="#6-为什么用NoSQL" class="headerlink" title="6. 为什么用NoSQL"></a>6. 为什么用NoSQL</h4><p> 今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的<strong>访问和抓取数据</strong>（爬虫私密信息有风险哈）。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也不能很好的处理这些大的数据。</p><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16f118aa1160ab73.jpg" alt=""></p><h2 id="NoSql的优缺点"><a href="#NoSql的优缺点" class="headerlink" title="NoSql的优缺点"></a>NoSql的优缺点</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>易扩展</strong> ： NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展。也无形之间，在架构的层面上带来了可扩展的能力。</li><li><strong>大数据量高性能</strong>：NoSQL数据库都具有非常高的读写性能，尤其在大数据量下，同样表现优秀。这得益于它的无关系性，数据库的结构简单。一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高。而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说就要性能高很多了</li><li><strong>多样灵活的数据模型</strong>：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式。而在关系数据库里，增删字段是一件非常麻烦的事情。如果是非常大数据量的表，增加字段简直就是一个噩梦</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>没有标准化</li><li>有限的查询功能（到目前为止）</li><li>最终一致是不直观的程序</li></ul><h3 id="传统RDBMS-VS-NOSQL："><a href="#传统RDBMS-VS-NOSQL：" class="headerlink" title="传统RDBMS VS NOSQL："></a>传统<strong>RDBMS</strong> <em>VS</em> <strong>NOSQL</strong>：</h3><h4 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h4><ul><li>高度组织化结构化数据</li><li>结构化查询语言（SQL）</li><li>数据和关系都存储在单独的表中。</li><li>数据操纵语言，数据定义语言</li><li>严格的一致性</li><li>基础事务</li></ul><h4 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h4><ul><li>代表着不仅仅是SQL</li><li>没有声明性查询语言</li><li>没有预定义的模式</li><li>键 - 值对存储，列存储，文档存储，图形数据库</li><li>最终一致性，而非ACID属性</li><li>非结构化和不可预知的数据</li><li>CAP定理</li><li>高性能，高可用性和可伸缩性</li></ul><h4 id="3V-3高"><a href="#3V-3高" class="headerlink" title="3V+3高"></a><strong>3V+3高</strong></h4><ul><li>大数据时代的3V（海量Volume、多样Variety、实时Velocity）</li><li>互联网需求的3高（高并发、高可扩、高性能）</li></ul><h2 id="NoSQL数据模型简介"><a href="#NoSQL数据模型简介" class="headerlink" title="NoSQL数据模型简介"></a>NoSQL数据模型简介</h2><p><strong>聚合模型</strong></p><ul><li>KV键值</li><li>bson：BSON（）是一种类json的一种二进制形式的存储格式，简称Binary JSON，它和JSON一样，支持内嵌的文档对象和数组对象</li><li>列族：顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。</li><li>图形：</li></ul><h2 id="NoSQL数据库的四大分类"><a href="#NoSQL数据库的四大分类" class="headerlink" title="NoSQL数据库的四大分类"></a>NoSQL数据库的四大分类</h2><p><strong>KV键值：</strong></p><p> 新浪：BerkeleyDB+redis</p><p> 美团：redis+tair</p><p> 阿里、百度：memcache+redis</p><p><strong>文档型数据库(bson格式比较多)</strong>：</p><p> CouchDB</p><p> MongoDB：MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><p><strong>列存储数据库</strong></p><p> Cassandra, HBase</p><p> 分布式文件系统</p><p><strong>图关系数据库</strong></p><p> 它不是放图形的，放的是关系比如:朋友圈社交网络、广告推荐系统、社交网络，推荐系统等。专注于构建关系图谱</p><p>Neo4J, InfoGrid</p><h4 id="四者对比"><a href="#四者对比" class="headerlink" title="四者对比"></a>四者对比</h4><p><strong>在分布式数据库中CAP原理CAP+BASE</strong></p><p>传统的<strong>ACID</strong></p><p><font color=red size=4>A (Atomicity) 原子性</font></p><p><font color=red size=4>C (Consistency) 一致性</font></p><p><font color=red size=4>I (Isolation) 独立性</font></p><p><font color=red size=4>D (Durability) 持久性</font></p><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a><strong>CAP</strong></h3><p><font color=red size=4><strong>C (Consistency) 强一致性——所有节点在同一时间具有相同的数据</strong></font></p><p><font color=red size=4><strong>A (Availability) 可用性——保证每个请求不管成功或者失败都有响应</strong></font></p><p><font color=red size=4><strong>P (Partition tolerance) 分区容错性——系统中任意信息的丢失或失败不会影响系统的继续运作</strong></font></p><p>CAP理论的核心是：<strong>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个</strong>。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以<strong>分区容忍性是我们必须需要实现的</strong>。我们称之为<strong>CAP的3进2，</strong>所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。</p><p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三大类：</p><ul><li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。传统Oracle数据库</li><li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。Redis、Mongodb</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。大多数网站架构的选择</li></ul><p><img src="https://gitee.com/wjxyzs/img/raw/master/img/16f118aa11736452.jpg" alt=""></p><p>☆ 注意</p><p><strong>分布式架构的时候必须做出取舍</strong>：一致性和可用性之间取一个平衡。多余大多数web应用，其实并不需要强一致性。因此牺牲C换取P，这是目前分布式数据库产品的方向</p><p><strong>一致性与可用性的决择</strong>：对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地</p><p><strong>数据库事务一致性需求</strong> ：很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低， 有些场合对写一致性要求并不高。允许实现最终一致性。</p><p><strong>数据库的写实时性和读实时性需求</strong>：对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出来这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比方说发一条消息之 后，过几秒乃至十几秒之后，我的订阅者才看到这条动态是完全可以接受的。</p><p><strong>对复杂的SQL查询，特别是多表关联查询的需求</strong> ：任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的报表查询，特别是SNS类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。</p><h2 id="BASE是什么"><a href="#BASE是什么" class="headerlink" title="BASE是什么"></a>BASE是什么</h2><p>BASE就是为了解决关系数据库强一致性引起的的可用性降低问题而提出的方案。</p><p>BASE其实是下面三个术语的缩写：</p><ul><li>基本可用（Basically Available）</li><li>软状态（Soft state）</li><li>最终一致（Eventually consistent）</li></ul><p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法</p><p><strong>分布式+集群简介</strong></p><p>分布式系统（distributed system）</p><p>由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：PC、工作站、局域网和广域网上等。</p><p><strong>分布式计算的优点</strong></p><ul><li><strong>可靠性（容错）</strong> ：分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。</li><li><strong>可扩展性</strong>：在分布式计算系统可以根据需要增加更多的机器。</li><li><strong>资源共享</strong>：共享数据是必不可少的应用，如银行，预订系统。</li><li><strong>灵活性</strong>：由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。</li><li><strong>更快的速度</strong>：分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。</li><li><strong>开放系统</strong>：由于它是开放的系统，本地或者远程都可以访问到该服务。</li><li><strong>更高的性能</strong>：相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。</li></ul><p><strong>分布式计算的缺点</strong></p><ul><li><strong>故障排除</strong>： 故障排除和诊断问题。</li><li><strong>软件</strong>：更少的软件支持是分布式计算系统的主要缺点。</li><li><strong>网络</strong>：网络基础设施的问题，包括：传输问题，高负载，信息丢失等。</li><li><strong>安全性</strong>：开发系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。</li></ul>]]></content>
    
    <summary type="html">
    
      NoSQL(NoSQL = Not Only SQL )，“不仅仅是SQL”，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数而非关系型的数据库则由于其本身的特点得到了非常迅速的发展...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[Django框架]</title>
    <link href="http://yoursite.com/2022/02/01/Django%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2022/02/01/Django%E6%A1%86%E6%9E%B6/</id>
    <published>2022-02-01T14:48:11.000Z</published>
    <updated>2022-02-01T07:48:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Django框架"><a href="#Django框架" class="headerlink" title="Django框架"></a>Django框架</h2><p>Django 是用Python开发的一个免费开源的Web框架，可以用于快速搭建高性能，优雅的网站！采用了MVC的框架模式，即模型M，视图V和控制器C，也可以称为MVT模式，模型M，视图V，模板T</p><p><a href="https://rogerxs80.github.io/2020/02/10/%E5%88%9D%E8%AF%86django%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">1.初识django框架</a></p><p><a href="https://rogerxs80.github.io/2020/02/10/%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6%E3%80%81request%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%93%BE%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/" target="_blank" rel="noopener">2.静态文件、request对象与链接数据库</a></p><p><a href="https://rogerxs80.github.io/2020/02/11/%E6%95%B0%E6%8D%AE%E7%BC%96%E8%BE%91%E3%80%81orm%E8%A1%A8%E5%85%B3%E7%B3%BB%E5%92%8C%E8%B7%AF%E7%94%B1%E5%B1%82/" target="_blank" rel="noopener">3.数据编辑、orm表关系和路由层</a></p><p><a href="https://rogerxs80.github.io/2020/02/12/%E8%A7%86%E5%9B%BE%E5%B1%82/" target="_blank" rel="noopener">4.视图层</a></p><p><a href="https://rogerxs80.github.io/2020/02/12/%E6%A8%A1%E6%9D%BF%E5%B1%82/" target="_blank" rel="noopener">5.模板层</a></p><p><a href="https://rogerxs80.github.io/2020/02/12/%E6%A8%A1%E5%9E%8B%E5%B1%82/" target="_blank" rel="noopener">6.模型层</a></p><p><a href="https://rogerxs80.github.io/2020/02/15/Ajax%E6%93%8D%E4%BD%9C/" target="_blank" rel="noopener">7.Ajax操作</a></p><p><a href="https://rogerxs80.github.io/2020/02/15/Forms%E7%BB%84%E4%BB%B6/" target="_blank" rel="noopener">8.Forms组件</a></p><p><a href="https://rogerxs80.github.io/2020/02/16/Cookie%E4%B8%8ESession/" target="_blank" rel="noopener">9.Cookie与Session</a></p><p><a href="https://rogerxs80.github.io/2020/02/17/django%E4%B8%AD%E9%97%B4%E4%BB%B6%E4%B8%8Ecsrf%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/" target="_blank" rel="noopener">10.django中间件与csrf跨站请求伪造</a></p><p><a href="https://rogerxs80.github.io/2020/02/17/MTV%E5%92%8CMVC%E6%A8%A1%E5%9E%8B%E4%B8%8EAuth%E6%A8%A1%E5%9D%97/" target="_blank" rel="noopener">11.MTV和MVC模型与Auth模块</a></p><p><a href="https://rogerxs80.github.io/2020/02/15/%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%86%E9%A1%B5%E5%99%A8/" target="_blank" rel="noopener">12.批量插入与分页器</a></p><p><a href="https://rogerxs80.github.io/2020/02/19/%E4%BA%86%E8%A7%A3%E7%9F%A5%E8%AF%86/" target="_blank" rel="noopener">13.了解知识</a></p>]]></content>
    
    <summary type="html">
    
      Django 是用Python开发的一个免费开源的Web框架，可以用于快速搭建高性能，优雅的网站！采用了MVC的框架模式，即模型M，视图V和控制器C，也可以称为MVT模式，模型M，视图V，模板T...
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="Django框架" scheme="http://yoursite.com/tags/Django%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>[Go函数]</title>
    <link href="http://yoursite.com/2021/04/23/Go%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2021/04/23/Go%E5%87%BD%E6%95%B0/</id>
    <published>2021-04-23T12:55:51.000Z</published>
    <updated>2021-04-23T15:05:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的基本形式"><a href="#函数的基本形式" class="headerlink" title="函数的基本形式"></a>函数的基本形式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义。a,b是形参</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">argf</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">a = a + b </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">6</span></span><br><span class="line">argf(x, y) <span class="comment">//函数调用。x,y是实参</span></span><br></pre></td></tr></table></figure><ul><li>形参是函数内部的局部变量，实参的值会拷贝给形参。</li><li>函数定义时的第一个的大括号不能另起一行。</li><li>形参可以有0个或多个。</li><li>参数类型相同时可以只写一次，比如argf(a,b int)。 </li><li>在函数内部修改形参的值，实参的值不受影响。</li><li>如果想通过函数修改实参，就需要指针类型。 </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">argf</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">    *a = *a + *b</span><br><span class="line">    *b = <span class="number">888</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">6</span></span><br><span class="line">argf(&amp;x, &amp;y)</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;slice、map、channel都是引用类型，它们作为函数参数时其实跟普通struct没什么区别，都是对struct内部的各个字段做一次拷贝传到函数内部。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slice_arg_1</span><span class="params">(arr []<span class="keyword">int</span>)</span></span> &#123; <span class="comment">//slice作为参数，实际上是把slice的arrayPointer、len、cap拷贝了一份传进来</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>           <span class="comment">//修改底层数据里的首元素</span></span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">1</span>) <span class="comment">//arr的len和cap发生了变化，不会影响实参</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">8</span>&#125;</span><br><span class="line">slice_arg_1(arr)</span><br><span class="line">fmt.Println(arr[<span class="number">0</span>])   <span class="comment">//1</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(arr)) <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于函数返回值</p><ul><li>可以返回0个或多个参数。</li><li>可以在func行直接声明要返回的变量。</li><li>return后面的语句不会执行。</li><li>无返回参数时return可以不写。   </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnf</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(c <span class="keyword">int</span>)</span></span> &#123; <span class="comment">//返回变量c已经声明好了</span></span><br><span class="line">    a = a + b</span><br><span class="line">    c = a <span class="comment">//直接使用c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//由于函数要求有返回值，即使给c赋过值了，也需要显式写return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;不定长参数实际上是slice类型。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variable_ength_arg</span><span class="params">(a <span class="keyword">int</span>, other ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; </span><br><span class="line">    sum := a</span><br><span class="line">    <span class="keyword">for</span> _, ele := <span class="keyword">range</span> other &#123;<span class="comment">//不定长参数实际上是slice类型</span></span><br><span class="line">        sum += ele</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">"len %d cap %d\n"</span>, <span class="built_in">len</span>(other), <span class="built_in">cap</span>(other))</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">variable_ength_arg(<span class="number">1</span>)</span><br><span class="line">variable_ength_arg(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;append函数接收的就是不定长参数。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">arr = <span class="built_in">append</span>(arr, <span class="number">7</span>)</span><br><span class="line">arr = <span class="built_in">append</span>(arr)</span><br><span class="line">slice := <span class="built_in">append</span>([]<span class="keyword">byte</span>(<span class="string">"hello "</span>), <span class="string">"world"</span>...) <span class="comment">//...自动把"world"转成byte切片，等价于[]byte("world")...</span></span><br><span class="line">slice2 := <span class="built_in">append</span>([]<span class="keyword">rune</span>(<span class="string">"hello "</span>), []<span class="keyword">rune</span>(<span class="string">"world"</span>)...) <span class="comment">//需要显式把"world"转成rune切片</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;在很多场景下string都隐式的转换成了byte切片，而非rune切片，比如”a中”[1]是228而非”中”。<br>递归函数  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fibonacci</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> || n == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n <span class="comment">//凡是递归，一定要有终止条件，否则会进入无限循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>) <span class="comment">//递归调用函数自身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>&#8195;&#8195;函数也是一种数据类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_arg1</span><span class="params">(f <span class="keyword">func</span>(a, b <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span> &#123; <span class="comment">//f参数是一种函数类型</span></span><br><span class="line">a := <span class="number">2</span> * b</span><br><span class="line"><span class="keyword">return</span> f(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> foo <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span> //<span class="title">foo</span>是一种函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_arg2</span><span class="params">(f foo, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="comment">//参数类型看上去简洁多了</span></span><br><span class="line">    a := <span class="number">2</span> * b</span><br><span class="line">    <span class="keyword">return</span> f(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    bye foo <span class="comment">//bye的类型是foo，而foo代表一种函数类型</span></span><br><span class="line">    hello <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span> //使用匿名函数来声明<span class="title">struct</span>字段的类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">string</span>, 10)</span></span><br><span class="line">ch &lt;- <span class="function"><span class="keyword">func</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;  <span class="comment">//使用匿名函数</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">"hello "</span> + name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>&#8195;&#8195;闭包（Closure）是引用了自由变量的函数，自由变量将和函数一同存在，即使已经离开了创造它的环境。闭包复制的是原对象的指针。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//闭包（Closure）是引用了自由变量的函数。自由变量将和函数一同存在，即使已经离开了创造它的环境。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">10</span></span><br><span class="line">fmt.Printf(<span class="string">"%p\n"</span>, &amp;i)</span><br><span class="line">b := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"i addr %p\n"</span>, &amp;i) <span class="comment">//闭包复制的是原对象的指针</span></span><br><span class="line">i--                           <span class="comment">//b函数内部引用了变量i</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b <span class="comment">//返回了b函数，变量i和b函数将一起存在，即使已经离开函数sub()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外部引用函数参数局部变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(base <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"base addr %p\n"</span>, &amp;base)</span><br><span class="line">base += i</span><br><span class="line"><span class="keyword">return</span> base</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">b := sub()</span><br><span class="line">b()</span><br><span class="line">b()</span><br><span class="line">fmt.Println()</span><br><span class="line"></span><br><span class="line">tmp1 := add(<span class="number">10</span>)</span><br><span class="line">fmt.Println(tmp1(<span class="number">1</span>), tmp1(<span class="number">2</span>)) <span class="comment">//11,13</span></span><br><span class="line"><span class="comment">// 此时tmp1和tmp2不是一个实体了</span></span><br><span class="line">tmp2 := add(<span class="number">100</span>)</span><br><span class="line">fmt.Println(tmp2(<span class="number">1</span>), tmp2(<span class="number">2</span>)) <span class="comment">//101,103</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟调用defer"><a href="#延迟调用defer" class="headerlink" title="延迟调用defer"></a>延迟调用defer</h2><ul><li>defer用于注册一个延迟调用（在函数返回之前调用）。</li><li>defer典型的应用场景是释放资源，比如关闭文件句柄，释放数据库连接等。</li><li>如果同一个函数里有多个defer，则后注册的先执行。</li><li>defer后可以跟一个func，func内部如果发生panic，会把panic暂时搁置，当把其他defer执行完之后再来执行这个。</li><li>defer后不是跟func，而直接跟一条执行语句，则相关变量在注册defer时被拷贝或计算。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">basic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"A"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="number">1</span>) fmt.Println(<span class="string">"B"</span>)</span><br><span class="line">    <span class="comment">//如果同一个函数里有多个defer，则后注册的先执行</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="string">"C"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defer_exe_time</span><span class="params">()</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">i = <span class="number">9</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//defer后可以跟一个func</span></span><br><span class="line">fmt.Printf(<span class="string">"first i=%d\n"</span>, i) <span class="comment">//打印5，而非9。充分理解“defer在函数返回前执行”的含义，不是在“return语句前执行defer”</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"second i=%d\n"</span>, i) <span class="comment">//打印9</span></span><br><span class="line">&#125;(i)</span><br><span class="line"><span class="keyword">defer</span> fmt.Printf(<span class="string">"third i=%d\n"</span>, i) <span class="comment">//defer后不是跟func，而直接跟一条执行语句，则相关变量在注册defer时被拷贝或计算</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>&#8195;&#8195;go语言没有try catch，它提倡返回error。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, errors.New(<span class="string">"divide by zero"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res, err := divide(<span class="number">3</span>, <span class="number">0</span>); err != <span class="literal">nil</span> &#123;<span class="comment">//函数调用方判断error是否为nil</span></span><br><span class="line">    fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;Go语言定义了error这个接口，自定义的error要实现Error()方法。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PathError <span class="keyword">struct</span> &#123;    <span class="comment">//自定义error</span></span><br><span class="line">    path <span class="keyword">string</span></span><br><span class="line">    op <span class="keyword">string</span></span><br><span class="line">    createTime <span class="keyword">string</span></span><br><span class="line">    message <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(err PathError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;    <span class="comment">//error接口要求实现Error() string方法</span></span><br><span class="line"><span class="keyword">return</span> err.createTime + <span class="string">": "</span> + err.op + <span class="string">" "</span> + err.path + <span class="string">" "</span> + err.message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>何时会发生panic:  </p><ul><li>运行时错误会导致panic，比如数组越界、除0。</li><li>程序主动调用panic(error)。</li></ul><p>panic会执行什么：  </p><ol><li>逆序执行当前goroutine的defer链（recover从这里介入）。</li><li>打印错误信息和调用堆栈。</li><li>调用exit(2)结束整个进程。  </li></ol><p>&#8195;&#8195;recover会使程序从panic中恢复(即不会执行panic的第2步和第3步)，并返回panic value。recover所在的函数后续的代码不会执行，但函数可以正常返回。在未发生panic时调用recover，会返回nil。recover()必须在defer中才能生效。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">soo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"enter soo"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//去掉这个defer试试，看看panic的流程。把这个defer放到soo函数末尾试试。把这个defer移到main()里试试。</span></span><br><span class="line"><span class="comment">//recover必须在defer中才能生效</span></span><br><span class="line"><span class="keyword">if</span> panic_value := <span class="built_in">recover</span>(); panic_value != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"soo函数中发生了panic:%v\n"</span>, panic_value)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(<span class="string">"regist recover"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">n := <span class="number">0</span></span><br><span class="line">_ = <span class="number">3</span> / n <span class="comment">//除0异常，发生panic，下一行的defer没有注册成功</span></span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">"how are you"</span>)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// defer func() &#123; //方式一，recover()在B()函数里，则在B()函数中panic后面的代码不会执行。不影响BBBBBBB的打印</span></span><br><span class="line"><span class="comment">// if panicValue := recover(); panicValue != nil &#123;</span></span><br><span class="line"><span class="comment">// fmt.Printf("panic info %v\n", panicValue)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// &#125;()</span></span><br><span class="line"><span class="built_in">panic</span>(<span class="number">5</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//方式二，recover()在main()函数里，则在main()函数中panic后面的代码不会执行。BBBBBBB不会打印出来</span></span><br><span class="line"><span class="keyword">if</span> panicValue := <span class="built_in">recover</span>(); panicValue != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"panic info %v\n"</span>, panicValue)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">B()</span><br><span class="line">fmt.Println(<span class="string">"BBBBBBB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Go流程控制语句]</title>
    <link href="http://yoursite.com/2021/04/22/Go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>http://yoursite.com/2021/04/22/Go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</id>
    <published>2021-04-22T10:55:32.000Z</published>
    <updated>2021-04-22T07:01:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">5</span> &gt; <span class="number">9</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"5&gt;9"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果逻辑表达式成立，就会执行{}里的内容。</li><li>逻辑表达式不需要加()。</li><li>“{“必须紧跟在逻辑表达式后面，不能另起一行。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> c, d, e := <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>; c &lt; d &amp;&amp; (c &gt; e || c &gt; <span class="number">3</span>) &#123; <span class="comment">//初始化多个局部变量。复杂的逻辑表达式</span></span><br><span class="line">    fmt.Println(<span class="string">"fit"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>逻辑表达中可以含有变量或常量。</li><li>if句子中允许包含1个(仅1个)分号，在分号前初始化一些局部变量(即只在if块内可见)。  </li></ul><p>if-else的用法  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">color := <span class="string">"black"</span></span><br><span class="line"><span class="keyword">if</span> color == <span class="string">"red"</span> &#123; <span class="comment">//if只能有一个</span></span><br><span class="line">    fmt.Println(<span class="string">"stop"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> color == <span class="string">"green"</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"go"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> color == <span class="string">"yellow"</span> &#123; <span class="comment">//else if可以有0个、一个或者连续多个</span></span><br><span class="line">    fmt.Println(<span class="string">"stop"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//else有0个或1个</span></span><br><span class="line">    fmt.Printf(<span class="string">"invalid traffic signal: %s\n"</span>, strings.ToUpper(color))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if表达式嵌套  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> xxx &#123;</span><br><span class="line">    <span class="keyword">if</span> xxx &#123;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> xxx&#123;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> xxx &#123;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;注意太深的嵌套不利于代码的维护，比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">color := <span class="string">"black"</span></span><br><span class="line"><span class="keyword">switch</span> color &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"green"</span> :<span class="comment">//相当于  if color== "green"</span></span><br><span class="line">fmt.Println(<span class="string">"go"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"red"</span> :<span class="comment">//相当于else if color== "red" </span></span><br><span class="line">fmt.Println(<span class="string">"stop"</span>)</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//相当于else </span></span><br><span class="line">fmt.Printf(<span class="string">"invalid traffic signal: %s\n"</span>, strings.ToUpper(color))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>switch-case-default可能模拟if-else if-else，但只能实现相等判断。</li><li>switch和case后面可以跟常量、变量或函数表达式，只要它们表示的数据类型相同就行。</li><li>case后面可以跟多个值，只要有一个值满足就行。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switch_expression</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">switch</span> add(a) &#123; <span class="comment">//switch后跟一个函数表达式</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">15</span>: <span class="comment">//case后跟一个常量</span></span><br><span class="line">fmt.Println(<span class="string">"right"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> B = <span class="number">15</span></span><br><span class="line"><span class="keyword">switch</span> B &#123; <span class="comment">//switch后跟一个常量</span></span><br><span class="line"><span class="keyword">case</span> add(a): <span class="comment">//case后跟一个函数表达式</span></span><br><span class="line">fmt.Println(<span class="string">"right"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;switch后带表达式时，switch-case只能模拟相等的情况；如果switch后不带表达式，case后就可以跟任意的条件表达式。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switch_condition</span><span class="params">()</span></span> &#123;</span><br><span class="line">color := <span class="string">"yellow"</span></span><br><span class="line"><span class="keyword">switch</span> color &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">"green"</span>:</span><br><span class="line">fmt.Println(<span class="string">"go"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"red"</span>, <span class="string">"yellow"</span>: <span class="comment">//用逗号分隔多个condition，它们之间是“或”的关系，只需要有一个condition满足就行</span></span><br><span class="line">fmt.Println(<span class="string">"stop"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch后带表达式时，switch-case只能模拟相等的情况；如果switch后不带表达式，case后就可以跟任意的条件表达式</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> add(<span class="number">5</span>) &gt; <span class="number">10</span>:</span><br><span class="line">fmt.Println(<span class="string">"right"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"wrong"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch Type</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switch_type</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num <span class="keyword">interface</span>&#123;&#125; = <span class="number">6.5</span></span><br><span class="line"><span class="keyword">switch</span> num.(<span class="keyword">type</span>) &#123; <span class="comment">//获取interface的具体类型。.(type)只能用在switch后面</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">fmt.Println(<span class="string">"int"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float32</span>:</span><br><span class="line">fmt.Println(<span class="string">"float32"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">fmt.Println(<span class="string">"float64"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">byte</span>:</span><br><span class="line">fmt.Println(<span class="string">"byte"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"neither"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> value := num.(<span class="keyword">type</span>) &#123; <span class="comment">//相当于在每个case内部申明了一个变量value</span></span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>: <span class="comment">//value已被转换为int类型</span></span><br><span class="line">fmt.Printf(<span class="string">"number is int %d\n"</span>, value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>: <span class="comment">//value已被转换为float64类型</span></span><br><span class="line">fmt.Printf(<span class="string">"number is float64 %f\n"</span>, value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">byte</span>, <span class="keyword">string</span>: <span class="comment">//如果case后有多个类型，则value还是interface&#123;&#125;类型</span></span><br><span class="line">fmt.Printf(<span class="string">"number is inerface %v\n"</span>, value)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"neither"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价形式</span></span><br><span class="line"><span class="keyword">switch</span> num.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">value := num.(<span class="keyword">int</span>)</span><br><span class="line">fmt.Printf(<span class="string">"number is int %d\n"</span>, value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">float64</span>:</span><br><span class="line">value := num.(<span class="keyword">float64</span>)</span><br><span class="line">fmt.Printf(<span class="string">"number is float64 %f\n"</span>, value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">byte</span>:</span><br><span class="line">value := num.(<span class="keyword">byte</span>)</span><br><span class="line">fmt.Printf(<span class="string">"number is byte %d\n"</span>, value)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"neither"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fallthrough 强制执行下一个case（或default）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fall_throth</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"您的年龄是%d, 您可以：\n"</span>, age)</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">50</span>:</span><br><span class="line">fmt.Println(<span class="string">"出任国家首脑"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">25</span>:</span><br><span class="line">fmt.Println(<span class="string">"生育子女"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">22</span>:</span><br><span class="line">fmt.Println(<span class="string">"结婚"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">18</span>:</span><br><span class="line">fmt.Println(<span class="string">"开车"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">16</span>:</span><br><span class="line">fmt.Println(<span class="string">"参加工作"</span>)</span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">15</span>:</span><br><span class="line">fmt.Println(<span class="string">"上高中"</span>)</span><br><span class="line"><span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">case</span> age &gt; <span class="number">3</span>:</span><br><span class="line">fmt.Println(<span class="string">"上幼儿园"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123; <span class="comment">//正序遍历切片</span></span><br><span class="line">fmt.Printf(<span class="string">"%d: %d\n"</span>, i, arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 初始化局部变量;条件表达式;后续操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> sum, i := <span class="number">0</span>, <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr) &amp;&amp; sum &lt; <span class="number">100</span>; sum, i = sum*<span class="number">1</span>, i+<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>局部变量指仅在for块内可见。</li><li>初始化变量可以放在for上面。</li><li>后续操作可以放在for块内部。</li><li>只有条件判断时，前后的分号可以不要。</li><li>for{}是一个无限循环。  </li></ul><p>for range  </p><ul><li>遍历数组或切片<ul><li>for i, ele := range arr </li></ul></li><li>遍历string<ul><li>for i, ele := range “我会唱ABC”    //ele是rune类型</li></ul></li><li>遍历map，go不保证遍历的顺序<ul><li>for key, value := range m</li></ul></li><li>遍历channel，遍历前一定要先close<ul><li>for ele := range ch</li><li>for range拿到的是数据的拷贝</li></ul></li></ul><p>for嵌套<br>&#8195;&#8195;矩阵乘法需要用到三层for循环嵌套。 </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/mat_mul.png" alt="avatar">   </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nest_for</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">A := [SIZE][SIZE]<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line"><span class="comment">//初始化二维数组</span></span><br><span class="line"><span class="comment">//两层for循环嵌套</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line">A[i][j] = rand.Float64() <span class="comment">//[0,1)上的随机数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B := [SIZE][SIZE]<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line">B[i][j] = rand.Float64() <span class="comment">//[0,1)上的随机数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rect := [SIZE][SIZE]<span class="keyword">float64</span>&#123;&#125;</span><br><span class="line"><span class="comment">//三层for循环嵌套</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line">prod := <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="number">0</span>; k &lt; SIZE; k++ &#123;</span><br><span class="line">prod += A[i][k] * B[k][j]</span><br><span class="line">&#125;</span><br><span class="line">rect[i][j] = prod</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i, j := <span class="number">2</span>, <span class="number">1</span></span><br><span class="line">fmt.Println(A[i]) <span class="comment">//二维数组第i行</span></span><br><span class="line"><span class="comment">//打印二维数组的第j列</span></span><br><span class="line"><span class="comment">//注意：B[:][j]这不是二维数组第j列，这是二维数组第j行！</span></span><br><span class="line"><span class="keyword">for</span> _, row := <span class="keyword">range</span> B &#123;</span><br><span class="line">fmt.Printf(<span class="string">"%g "</span>, row[j])</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line">fmt.Println(rect[i][j])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break与continue"><a href="#break与continue" class="headerlink" title="break与continue"></a>break与continue</h2><ul><li>break与continue用于控制for循环的代码流程，并且只针对最靠近自己的外层for循环。</li><li>break:退出for循环，且本轮break下面的代码不再执行。</li><li>continue:本轮continue下面的代码不再执行，进入for循环的下一轮。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//break和continue都是针对for循环的，不针对if或switch</span></span><br><span class="line"><span class="comment">//break和continue都是针对套在自己外面的最靠里的那层for循环，不针对更外层的for循环（除非使用Label）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">complex_break_continue</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">5</span></span><br><span class="line">arr := [SIZE][SIZE]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"开始检查第%d行\n"</span>, i)</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"开始检查第%d列\n"</span>, j)</span><br><span class="line"><span class="keyword">if</span> arr[i][j]%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">//针对第二层for循环</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"将要检查第%d列\n"</span>, j+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span> <span class="comment">//针对第一层for循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="goto与Label"><a href="#goto与Label" class="headerlink" title="goto与Label"></a>goto与Label</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">4</span></span><br><span class="line">MY_LABEL:</span><br><span class="line">i += <span class="number">3</span></span><br><span class="line">fmt.Println(i)</span><br><span class="line"><span class="keyword">goto</span> MY_LABEL <span class="comment">//返回定义MY_LABEL的那一行，把代码再执行一遍（会进入一个无限循环）</span></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> L1 <span class="comment">//Label指示的是某一行代码，并没有圈定一个代码块，所以goto L1也会执行L2后的代码</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> L2<span class="comment">//先使用Label</span></span><br><span class="line">&#125;</span><br><span class="line">L1: </span><br><span class="line">i += <span class="number">3</span></span><br><span class="line">L2: <span class="comment">//后定义Label。Label定义后必须在代码的某个地方被使用</span></span><br><span class="line">i *= <span class="number">3</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;goto与Label结合可以实现break的功能，甚至比break更强大。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line">L2:</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line"><span class="keyword">goto</span> L1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">L1:</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure><ul><li>break、continue与Label结合使用可以跳转到更外层的for循环。</li><li>continue和break针对的Label必须写在for前面，而goto可以针对任意位置的Label。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">break_label</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> SIZE = <span class="number">5</span></span><br><span class="line">arr := [SIZE][SIZE]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">L1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; SIZE; i++ &#123;</span><br><span class="line">L2:</span><br><span class="line">fmt.Printf(<span class="string">"开始检查第%d行\n"</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">1</span> &#123;</span><br><span class="line">L3:</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; SIZE; j++ &#123;</span><br><span class="line">fmt.Printf(<span class="string">"开始检查第%d列\n"</span>, j)</span><br><span class="line"><span class="keyword">if</span> arr[i][j]%<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span> L1 <span class="comment">//直接退出最外层的fot循环</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[i][j]%<span class="number">3</span> == <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> L2 <span class="comment">//continue和break针对的Label必须写在for前面，而goto可以针对任意位置的Label</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span> L3</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>练习</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span></span><br><span class="line">L1:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; &#123;</span><br><span class="line">fmt.Println(<span class="string">"开始"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"i=%d\n"</span>, i)</span><br><span class="line">L2:</span><br><span class="line">fmt.Println(<span class="string">"开始2"</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">fmt.Printf(<span class="string">"i=%d\n"</span>, i)</span><br><span class="line">fmt.Print(<span class="string">"请输入："</span>)</span><br><span class="line">fmt.Scan(&amp;num)</span><br><span class="line"><span class="keyword">switch</span> num &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">break</span> L1 <span class="comment">//直接跳出L1</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">continue</span> L1 <span class="comment">// 会直接执行L1下面的语句,但变量仍保持，仍保持刚刚的进行</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="keyword">goto</span> L2 <span class="comment">// 会直接执行L2下面的语句,但变量仍保持</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="keyword">goto</span> L1 <span class="comment">// 会直接重新执行L1下面的语句</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"结束"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Go结构体]</title>
    <link href="http://yoursite.com/2021/04/21/Go%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://yoursite.com/2021/04/21/Go%E7%BB%93%E6%9E%84%E4%BD%93/</id>
    <published>2021-04-21T12:29:40.000Z</published>
    <updated>2021-04-21T13:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="结构体创建、访问与修改"><a href="#结构体创建、访问与修改" class="headerlink" title="结构体创建、访问与修改"></a>结构体创建、访问与修改</h2><p>定义结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">    score <span class="keyword">float32</span></span><br><span class="line">    enrollment time.Time</span><br><span class="line">    name, addr <span class="keyword">string</span> <span class="comment">//多个字段类型相同时可以简写到一行里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明和初始化结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u user <span class="comment">//声明，会用相应类型的默认值初始化struct里的每一个字段</span></span><br><span class="line">u = user&#123;&#125; <span class="comment">//用相应类型的默认值初始化struct里的每一个字段</span></span><br><span class="line">u = user&#123;id: <span class="number">3</span>, name: <span class="string">"zcy"</span>&#125; <span class="comment">//赋值初始化</span></span><br><span class="line">u = user&#123;<span class="number">4</span>, <span class="number">100.0</span>, time.Now(), <span class="string">"zcy"</span>, <span class="string">"beijing"</span>&#125; <span class="comment">//赋值初始化，可以不写字段名，但需要跟结构体定义里的字段顺序一致</span></span><br></pre></td></tr></table></figure><p>访问与修改结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u.enrollment = time.Now() <span class="comment">//给结构体的成员变量赋值</span></span><br><span class="line">fmt.Printf(<span class="string">"id=%d, enrollment=%v, name=%s\n"</span>, u.id, u.enrollment, u.name) <span class="comment">//访问结构体的成员变量</span></span><br></pre></td></tr></table></figure><p>成员方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以把user理解为hello函数的参数，即hello(u user, man string)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">hello</span><span class="params">(man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", my name is "</span> + u.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数里不需要访问user的成员，可以传匿名，甚至_也不传</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(_ user)</span> <span class="title">think</span><span class="params">(man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", do you know my name?"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为自定义类型添加方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UserMap <span class="keyword">map</span>[<span class="keyword">int</span>]User <span class="comment">//自定义类型</span></span><br><span class="line"><span class="comment">//可以给自定义类型添加任意方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(um UserMap)</span> <span class="title">GetUser</span><span class="params">(id <span class="keyword">int</span>)</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> um[id]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体的可见性：  </p><ul><li>go语言关于可见的统一规则：大写字母开头跨package也可以访问；否则只能本package内部访问。</li><li>结构体名称以大写开头时，package外部可见，在此前提下，结构体中以大写开头在成员变量或成员方法在package外部也可见。  </li></ul><p>匿名结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stu <span class="keyword">struct</span> &#123; <span class="comment">//声明stu是一个结构体，但这个结构体是匿名的</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Addr <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line">stu.Name = <span class="string">"zcy"</span></span><br><span class="line">stu.Addr = <span class="string">"bj"</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;匿名结构体通常用于只使用一次的情况。<br>结构体中含有匿名成员</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Id <span class="keyword">int</span></span><br><span class="line"><span class="keyword">string</span> <span class="comment">//匿名字段</span></span><br><span class="line"><span class="keyword">float32</span> <span class="comment">//直接使用数据类型作为字段名，所以匿名字段中不能出现重复的数据类型</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stu = Student&#123;Id: <span class="number">1</span>, <span class="keyword">string</span>: <span class="string">"zcy"</span>, <span class="keyword">float32</span>: <span class="number">79.5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"anonymous_member string member=%s float member=%f\n"</span>, stu.<span class="keyword">string</span>, stu.<span class="keyword">float32</span>)  <span class="comment">//直接使用数据类型访问匿名成员</span></span><br></pre></td></tr></table></figure><h2 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h2><p>创建结构体指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u User</span><br><span class="line">user := &amp;u <span class="comment">//通过取址符&amp;得到指针</span></span><br><span class="line">user = &amp;User&#123; <span class="comment">//直接创建结构体指针</span></span><br><span class="line">    Id: <span class="number">3</span>, Name: <span class="string">"zcy"</span>, addr: <span class="string">"beijing"</span>,</span><br><span class="line">&#125;</span><br><span class="line">user = <span class="built_in">new</span>(User) <span class="comment">//通过new()函数实体化一个结构体，并返回其指针</span></span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造函数。返回指针是为了避免值拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUser</span><span class="params">(id <span class="keyword">int</span>, name <span class="keyword">string</span>)</span> *<span class="title">User</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;User&#123;</span><br><span class="line">Id: id,</span><br><span class="line">Name: name,</span><br><span class="line">addr: <span class="string">"China"</span>,</span><br><span class="line">Score: <span class="number">59</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法接收指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//user传的是值，即传的是整个结构体的拷贝。在函数里修改结构体不会影响原来的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(u user, man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.name = <span class="string">"杰克"</span></span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", my name is "</span> + u.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传的是user指针，在函数里修改user的成员会影响原来的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello2</span><span class="params">(u *user, man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.name = <span class="string">"杰克"</span></span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", my name is "</span> + u.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把user理解为hello()的参数，即hello(u user, man string)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">hello</span><span class="params">(man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.name = <span class="string">"杰克"</span></span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", my name is "</span> + u.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以理解为hello2(u *user, man string)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">hello2</span><span class="params">(man <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    u.name = <span class="string">"杰克"</span></span><br><span class="line">    fmt.Println(<span class="string">"hi "</span> + man + <span class="string">", my name is "</span> + u.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体嵌套"><a href="#结构体嵌套" class="headerlink" title="结构体嵌套"></a>结构体嵌套</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex <span class="keyword">byte</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> paper <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    auther user <span class="comment">//结构体嵌套</span></span><br><span class="line">&#125;</span><br><span class="line">p := <span class="built_in">new</span>(paper)</span><br><span class="line">p.name = <span class="string">"论文标题"</span></span><br><span class="line">p.auther.name = <span class="string">"作者姓名"</span></span><br><span class="line">p.auther.sex = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> vedio <span class="keyword">struct</span> &#123;</span><br><span class="line">    length <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    user<span class="comment">//匿名字段,可用数据类型当字段名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体嵌套时字段名冲突的问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v := <span class="built_in">new</span>(vedio)</span><br><span class="line">v.length = <span class="number">13</span></span><br><span class="line">v.name = <span class="string">"视频名称"</span></span><br><span class="line">v.user.sex = <span class="number">0</span> <span class="comment">//通过字段名逐级访问</span></span><br><span class="line">v.sex = <span class="number">0</span> <span class="comment">//对于匿名字段也可以跳过中间字段名，直接访问内部的字段名</span></span><br><span class="line">v.user.name = <span class="string">"作者姓名"</span> <span class="comment">//由于内部、外部结构体都有name这个字段，名字冲突了，所以需要指定中间字段名</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Vedio <span class="keyword">struct</span> &#123;</span><br><span class="line">Length <span class="keyword">int</span></span><br><span class="line">Author User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;Go语言里的赋值都会发生值拷贝。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/deep_copy.png" alt="avatar">  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Vedio <span class="keyword">struct</span> &#123;</span><br><span class="line">Length <span class="keyword">int</span></span><br><span class="line">Author *User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/shallow_copy.png" alt="avatar">  </p><ul><li>深拷贝，拷贝的是值，比如Vedio.Length。</li><li>浅拷贝，拷贝的是指针，比如Vedio.Author。</li><li>深拷贝开辟了新的内存空间，修改操作不影响原先的内存。</li><li>浅拷贝指向的还是原来的内存空间，修改操作直接作用在原内存空间上。</li></ul><p>&#8195;&#8195;传slice，对sclice的3个字段进行了拷贝，拷贝的是底层数组的指针，所以修改底层数组的元素会反应到原数组上。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">users := []User&#123;&#123;Name: <span class="string">"康熙"</span>&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update_users</span><span class="params">(users []User)</span></span> &#123;</span><br><span class="line">    users[<span class="number">0</span>].Name = <span class="string">"光绪"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Go数据类型]</title>
    <link href="http://yoursite.com/2021/04/21/Go%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2021/04/21/Go%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-04-21T12:29:30.000Z</published>
    <updated>2021-04-21T13:11:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go数据类型"><a href="#Go数据类型" class="headerlink" title="Go数据类型"></a>Go数据类型</h1><h2 id="数据类型概览"><a href="#数据类型概览" class="headerlink" title="数据类型概览"></a>数据类型概览</h2><p>基础数据类型</p><table><thead><tr><th align="center">类型</th><th align="center">长度(字节)</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bool</td><td align="center">1</td><td align="center">false</td><td align="center"></td></tr><tr><td align="center">byte</td><td align="center">1</td><td align="center">0</td><td align="center">uint8，取值范围[0,255]</td></tr><tr><td align="center">rune</td><td align="center">4</td><td align="center">0</td><td align="center">Unicode Code Point, int32</td></tr><tr><td align="center">int, uint</td><td align="center">4或8</td><td align="center">0</td><td align="center">32 或 64 位，取决于操作系统</td></tr><tr><td align="center">int8, uint8</td><td align="center">1</td><td align="center">0</td><td align="center">-128 ~ 127, 0 ~ 255</td></tr><tr><td align="center">int16, uint16</td><td align="center">2</td><td align="center">0</td><td align="center">-32768 ~ 32767, 0 ~ 65535</td></tr><tr><td align="center">int32, uint32</td><td align="center">4</td><td align="center">0</td><td align="center">-21亿~ 21亿, 0 ~ 42亿，rune是int32 的别名</td></tr><tr><td align="center">int64, uint64</td><td align="center">8</td><td align="center">0</td><td align="center"></td></tr><tr><td align="center">float32</td><td align="center">4</td><td align="center">0.0</td><td align="center"></td></tr><tr><td align="center">float64</td><td align="center">8</td><td align="center">0.0</td><td align="center"></td></tr><tr><td align="center">complex64</td><td align="center">8</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">complex128</td><td align="center">16</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">uintptr</td><td align="center">4或8</td><td align="center"></td><td align="center">以存储指针的 uint32 或 uint64 整数</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"os arch %s, int size %d\n"</span>, runtime.GOARCH, strconv.IntSize) <span class="comment">//int是4字节还是8字节，取决于操作系统是32位还是64位</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int8</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">int16</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">int32</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">int64</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">uint</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> g <span class="keyword">uint8</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> h <span class="keyword">uint16</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">uint32</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> j <span class="keyword">uint64</span> = <span class="number">5</span></span><br><span class="line">fmt.Printf(<span class="string">"a=%d, b=%d, c=%d, d=%d, e=%d, f=%d, g=%d, h=%d, i=%d, j=%d\n"</span>, a, b, c, d, e, f, g, h, i, j)</span><br><span class="line"><span class="keyword">var</span> k <span class="keyword">float32</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">var</span> l <span class="keyword">float64</span> = <span class="number">5</span></span><br><span class="line">fmt.Printf(<span class="string">"k=%f, l=%.2f\n"</span>, k, l) <span class="comment">//%.2f保留2位小数</span></span><br><span class="line"><span class="keyword">var</span> m <span class="keyword">complex128</span> = <span class="built_in">complex</span>(<span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">var</span> n <span class="keyword">complex64</span> = <span class="built_in">complex</span>(<span class="number">4</span>, <span class="number">7</span>)</span><br><span class="line">fmt.Printf(<span class="string">"type of m is %T, type of n is %T\n"</span>, m, n) <span class="comment">//%T输出变量类型</span></span><br><span class="line">fmt.Printf(<span class="string">"m=%v, n=%v\n"</span>, m, n)                       <span class="comment">//按值的本来值输出</span></span><br><span class="line">fmt.Printf(<span class="string">"m=%+v, n=%+v\n"</span>, m, n)                     <span class="comment">//在 %v 基础上，对结构体字段名和值进行展开</span></span><br><span class="line">fmt.Printf(<span class="string">"m=%#v, n=%#v\n"</span>, m, n)                     <span class="comment">//输出 Go 语言语法格式的值</span></span><br><span class="line">fmt.Printf(<span class="string">"m的实部%f, m的虚部%f\n"</span>, <span class="built_in">real</span>(m), <span class="built_in">imag</span>(m))</span><br><span class="line">fmt.Printf(<span class="string">"m的实部%e, m的虚部%g\n"</span>, <span class="built_in">real</span>(m), <span class="built_in">imag</span>(m)) <span class="comment">//%e科学计数法，%g根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）</span></span><br><span class="line">o := <span class="literal">true</span>                                        <span class="comment">//等价于var o bool = true</span></span><br><span class="line">fmt.Printf(<span class="string">"o=%t\n"</span>, o)                          <span class="comment">//%t布尔变量</span></span><br><span class="line"><span class="keyword">var</span> pointer unsafe.Pointer = unsafe.Pointer(&amp;a)</span><br><span class="line"><span class="keyword">var</span> p <span class="keyword">uintptr</span> = <span class="keyword">uintptr</span>(pointer)</span><br><span class="line"><span class="keyword">var</span> ptr *<span class="keyword">int</span> = &amp;a</span><br><span class="line">fmt.Printf(<span class="string">"p=%x pointer=%p ptr=%p\n"</span>, p, pointer, ptr) <span class="comment">//%p输出地址，%x十六进制</span></span><br><span class="line"><span class="keyword">var</span> q <span class="keyword">byte</span> = <span class="number">100</span>                                        <span class="comment">//byte是uint，取值范围[0,255]</span></span><br><span class="line">fmt.Printf(<span class="string">"q=%d, binary of q is %b\n"</span>, q, q)           <span class="comment">//%b输出二进制</span></span><br><span class="line"><span class="keyword">var</span> r <span class="keyword">rune</span> = <span class="string">'☻'</span>                                        <span class="comment">//rune实际上是int32，即可以表示2147483647种字符，包括所有汉字和各种特殊符号</span></span><br><span class="line">fmt.Printf(<span class="string">"r=%d, r=%U\n"</span>, r, r)                        <span class="comment">//%U Unicode 字符</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"I'm 张朝阳"</span></span><br><span class="line">fmt.Printf(<span class="string">"s=%s\n"</span>, s)</span><br><span class="line"><span class="keyword">var</span> t error = errors.New(<span class="string">"my error"</span>)</span><br><span class="line">fmt.Printf(<span class="string">"error is %v\n"</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">"error is %+v\n"</span>, t) <span class="comment">//在 %v 基础上，对结构体字段名和值进行展开</span></span><br><span class="line">fmt.Printf(<span class="string">"error is %#v\n"</span>, t) <span class="comment">//输出 Go 语言语法格式的值</span></span><br></pre></td></tr></table></figure><p>数值型变量的默认值是0，字符串的默认值是空字符串，布尔型变量的默认值是false，引用类型、函数、指针、接口的默认值是nil。数组的默认值取每个元素对应类型的默认值，结构体的默认值取每个成员变量对应类型的默认值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> t <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> r <span class="keyword">rune</span></span><br><span class="line"><span class="keyword">var</span> arr [<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> slc []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"default value of int %d\n"</span>, a)</span><br><span class="line">fmt.Printf(<span class="string">"default value of byte %d\n"</span>, b)</span><br><span class="line">fmt.Printf(<span class="string">"default value of float %.2f\n"</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">"default value of bool %t\n"</span>, t)</span><br><span class="line">fmt.Printf(<span class="string">"default value of string [%s]\n"</span>, s)</span><br><span class="line">fmt.Printf(<span class="string">"default value of rune %d, [%c]\n"</span>, r, r)</span><br><span class="line">fmt.Printf(<span class="string">"default int array is %v\n"</span>, arr) <span class="comment">//取每个元素对应类型的默认值</span></span><br><span class="line">fmt.Printf(<span class="string">"default slice is nil %t\n"</span>, slc == <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>复合数据类型</p><table><thead><tr><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">array</td><td align="center">取每个元素对应类型的默认值</td><td align="center">值类型</td></tr><tr><td align="center">struct</td><td align="center">取每个成员变量对应类型的默认值</td><td align="center">值类型</td></tr><tr><td align="center">string</td><td align="center">“”</td><td align="center">UTF-8 字符串</td></tr><tr><td align="center">slice</td><td align="center">nil</td><td align="center">引用类型</td></tr><tr><td align="center">map</td><td align="center">nil</td><td align="center">引用类型</td></tr><tr><td align="center">channel</td><td align="center">nil</td><td align="center">引用类型</td></tr><tr><td align="center">interface</td><td align="center">nil</td><td align="center">接口</td></tr><tr><td align="center">function</td><td align="center">nil</td><td align="center">函数</td></tr></tbody></table><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>类型别名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="keyword">byte</span> = <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> <span class="keyword">rune</span> = <span class="keyword">int32</span></span><br><span class="line"><span class="keyword">type</span> semaphore = <span class="keyword">uint8</span></span><br></pre></td></tr></table></figure><p>自定义类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;name <span class="keyword">string</span>;age <span class="keyword">int</span>&#125;  <span class="comment">//用分号把多行代码隔开</span></span><br><span class="line"><span class="keyword">type</span> signal <span class="keyword">uint8</span></span><br><span class="line"><span class="keyword">type</span> ms <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> add <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是块连续的内存空间，在声明的时候必须指定长度，且长度不能改变。所以数组在声明的时候就可以把内存空间分配好，并赋上默认值，即完成了初始化。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/array.png" alt="avatar">  </p><p>一维数组初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span> = [<span class="number">5</span>]<span class="keyword">int</span>&#123;&#125; <span class="comment">//数组必须指定长度和类型，且长度和类型指定后不可改变</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> arr3 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>&#125; <span class="comment">//给前2个元素赋值</span></span><br><span class="line"><span class="keyword">var</span> arr4 = [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>: <span class="number">15</span>, <span class="number">4</span>: <span class="number">30</span>&#125; <span class="comment">//指定index赋值</span></span><br><span class="line"><span class="keyword">var</span> arr5 = [...]<span class="keyword">int</span>&#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;<span class="comment">//根据&#123;&#125;里元素的个数推断出数组的长度</span></span><br><span class="line"><span class="keyword">var</span> arr6 = [...]<span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;&#123;&#123;<span class="string">"Tom"</span>, <span class="number">18</span>&#125;, &#123;<span class="string">"Jim"</span>, <span class="number">20</span>&#125;&#125; <span class="comment">//数组的元素类型由匿名结构体给定</span></span><br></pre></td></tr></table></figure><p>二维数组初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5行3列，只给前2行赋值，且前2行的所有列还没有赋满</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">5</span>][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br><span class="line"><span class="comment">//第1维可以用...推测，第2维不能用...</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [...][<span class="number">3</span>]<span class="keyword">int</span>&#123;&#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>, <span class="number">3</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>访问数组里的元素</p><ul><li>通过index访问<ul><li>首元素 arr[0]</li><li>末元素 arr[len(arr)-1]</li></ul></li><li>访问二维数组里的元素<ul><li>位于第三行第四列的元素 arr[2][3]</li></ul></li></ul><p>遍历数组</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历数组里的元素</span></span><br><span class="line"><span class="keyword">for</span> i, ele := <span class="keyword">range</span> arr &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"index=%d, element=%d\n"</span>, i, ele)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者这样遍历数组</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123; <span class="comment">//len(arr)获取数组的长度</span></span><br><span class="line">    fmt.Printf(<span class="string">"index=%d, element=%d\n"</span>, i, arr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历二维数组</span></span><br><span class="line"><span class="keyword">for</span> row, array := <span class="keyword">range</span> arr &#123; <span class="comment">//先取出某一行</span></span><br><span class="line">    <span class="keyword">for</span> col, ele := <span class="keyword">range</span> array &#123; <span class="comment">//再遍历这一行</span></span><br><span class="line">        fmt.Printf(<span class="string">"arr[%d][%d]=%d\n"</span>, row, col, ele)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;通过for range遍历数组时取得的是数组里每一个元素的拷贝。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i, ele := <span class="keyword">range</span> arr &#123; <span class="comment">//ele是arr中元素的拷贝</span></span><br><span class="line">    arr[i] += <span class="number">8</span> <span class="comment">//修改arr里的元素，不影响ele</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d %d %d\n"</span>, i, arr[i], ele)</span><br><span class="line">    ele += <span class="number">1</span> <span class="comment">//修改ele不影响arr</span></span><br><span class="line">    fmt.Printf(<span class="string">"%d %d %d\n"</span>, i, arr[i], ele)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%d %d\n"</span>, i, arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在数组上调用cap()函数表示capacity容量，即给数组分配的内存空间可以容纳多少个元素；len()函数代表length长度，即目前数组里有几个元素。由于数组初始化之后长度不会改变，不需要给它预留内存空间，所以len(arr)==cap(arr)。对于多维数组，其cap和len指第一维的长度。<br>数组的长度和类型都是数组类型的一部分，函数传递数组类型时这两部分都必须吻合。<strong>go语言没有按引用传参，全都是按值传参，即传递数组实际上传的是数组的拷贝，当数组的长度很大时，仅传参开销都很大。</strong>如果想修改函数外部的数组，就把它的指针（数组在内存里的地址）传进来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数必须是长度为5的int型数组（注意长度必须是5）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update_array1</span><span class="params">(arr [5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"array in function, address is %p\n"</span>, &amp;arr[<span class="number">0</span>])</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">888</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update_array2</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"array in function, address is %p\n"</span>, &amp;((*arr)[<span class="number">0</span>]))</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">888</span> <span class="comment">//因为传的是数组指针，所以直接在原来的内存空间上进行修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>&#8195;&#8195;切片是一个结构体，包含三个成员变量，array指向一块连续的内存空间，cap表示这块内存的大小，len表示目前该内存里存储了多少元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123; </span><br><span class="line">    array unsafe.Pointer </span><br><span class="line">    <span class="built_in">len</span> <span class="keyword">int</span> </span><br><span class="line">    <span class="built_in">cap</span> <span class="keyword">int</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/slice.png" alt="avatar">   </p><p>切片的初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span> <span class="comment">//切片声明，len=cap=0</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;&#125; <span class="comment">//初始化，len=cap=0</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">//初始化，len=cap=3</span></span><br><span class="line">s = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">//初始化，len=3，cap=5</span></span><br><span class="line">s = []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125; <span class="comment">//初始化，len=cap=5</span></span><br><span class="line">s2d := [][]<span class="keyword">int</span>&#123;</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,&#123;<span class="number">2</span>, <span class="number">3</span>&#125;, <span class="comment">//二维数组各行的列数相等，但二维切片各行的len可以不等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>切片相对于数组最大的特点就是可以追加元素，可以自动扩容。追加的元素放到预留的内存空间里，同时len加1。如果预留空间已用完，则会重新申请一块更大的内存空间，capacity大约变成之前的2倍(cap&lt;1024)或1.25倍(cap&gt;1024)。把原内存空间的数据拷贝过来，在新内存空间上执行append操作。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    s[i] = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="comment">//s=[1,2,3]</span></span><br><span class="line">fmt.Printf(<span class="string">"s[0] address %p, s=%v\n"</span>, &amp;s[<span class="number">0</span>], s)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">capacity还够用，直接把追加的元素放到预留的内存空间上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">//可以一次append多个元素</span></span><br><span class="line">fmt.Printf(<span class="string">"s[0] address %p, s=%v\n"</span>, &amp;s[<span class="number">0</span>], s)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">capacity不够用了，得申请一片新的内存，把老数据先拷贝过来，在新内存上执行append操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">6</span>)</span><br><span class="line">fmt.Printf(<span class="string">"s[0] address %p, s=%v\n"</span>, &amp;s[<span class="number">0</span>], s)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//探究capacity扩容规律</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expansion</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">prevCap := <span class="built_in">cap</span>(s)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, i)</span><br><span class="line">currCap := <span class="built_in">cap</span>(s)</span><br><span class="line"><span class="keyword">if</span> currCap &gt; prevCap &#123;</span><br><span class="line"><span class="comment">//每次扩容都是扩到原先的2倍</span></span><br><span class="line">fmt.Printf(<span class="string">"capacity从%d变成%d\n"</span>, prevCap, currCap)</span><br><span class="line">prevCap = currCap</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">brr := <span class="built_in">append</span>(arr, <span class="number">8</span>) <span class="comment">//arr和brr共享底层数组，但它们的len不同</span></span><br></pre></td></tr></table></figure><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/append.png" alt="append"></p><p>&#8195;&#8195;通过指定起止下标，可以从大切片中截取一个子切片。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)<span class="comment">//len=3, cap=5</span></span><br><span class="line">sub_slice = s[<span class="number">1</span>:<span class="number">3</span>]<span class="comment">//len=2, cap=4</span></span><br></pre></td></tr></table></figure><p>&#8195;&#8195;刚开始，子切片和母切片共享底层的内存空间，修改子切片会反映到母切片上，在子切片上执行append会把新元素放到母切片预留的内存空间上。当子切片不断执行append，耗完了母切片预留的内存空间，子切片跟母切片就会发生内存分离，此后两个切片没有任何关系。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/sub_slice.png" alt="avatar"> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sub_slice</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">截取一部分，创造子切片，此时子切片与母切片(或母数组)共享底层内存空间，母切片的capacity子切片可能直接用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">s[i] = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="comment">//s=[1,2,3]</span></span><br><span class="line">fmt.Printf(<span class="string">"s[1] address %p\n"</span>, &amp;s[<span class="number">1</span>])</span><br><span class="line">sub_slice := s[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//从切片创造子切片，len=2，cap=4</span></span><br><span class="line">fmt.Printf(<span class="string">"len %d cap %d\n"</span>, <span class="built_in">len</span>(sub_slice), <span class="built_in">cap</span>(sub_slice))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">母切片的capacity还允许子切片执行append操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sub_slice = <span class="built_in">append</span>(sub_slice, <span class="number">6</span>, <span class="number">7</span>) <span class="comment">//可以一次append多个元素</span></span><br><span class="line">sub_slice[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">fmt.Printf(<span class="string">"s=%v, sub_slice=%v, s[1] address %p, sub_slice[0] address %p\n"</span>, s, sub_slice, &amp;s[<span class="number">1</span>], &amp;sub_slice[<span class="number">0</span>])</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">母切片的capacity用完了，子切片再执行append就得申请一片新的内存，把老数据先拷贝过来，在新内存上执行append操作。此时的append操作跟母切片没有任何关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sub_slice = <span class="built_in">append</span>(sub_slice, <span class="number">8</span>)</span><br><span class="line">sub_slice[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">fmt.Printf(<span class="string">"s=%v, sub_slice=%v, s[1] address %p, sub_slice[0] address %p\n"</span>, s, sub_slice, &amp;s[<span class="number">1</span>], &amp;sub_slice[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"arr[1] address %p\n"</span>, &amp;arr[<span class="number">1</span>])</span><br><span class="line">sub_slice = arr[<span class="number">1</span>:<span class="number">3</span>] <span class="comment">//从数组创造子切片，len=cap=2</span></span><br><span class="line">fmt.Printf(<span class="string">"len %d cap %d\n"</span>, <span class="built_in">len</span>(sub_slice), <span class="built_in">cap</span>(sub_slice))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">母数组的capacity还允许子切片执行append操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sub_slice = <span class="built_in">append</span>(sub_slice, <span class="number">6</span>, <span class="number">7</span>) <span class="comment">//可以一次append多个元素</span></span><br><span class="line">sub_slice[<span class="number">0</span>] = <span class="number">8</span></span><br><span class="line">fmt.Printf(<span class="string">"arr=%v, sub_slice=%v, arr[1] address %p, sub_slice[0] address %p\n"</span>, arr, sub_slice, &amp;arr[<span class="number">1</span>], &amp;sub_slice[<span class="number">0</span>])</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">母数组的capacity用完了，子切片再执行append就得申请一片新的内存，把老数据先拷贝过来，在新内存上执行append操作。此时的append操作跟母数组没有任何关系</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">sub_slice = <span class="built_in">append</span>(sub_slice, <span class="number">8</span>)</span><br><span class="line">sub_slice[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">fmt.Printf(<span class="string">"arr=%v, sub_slice=%v, arr[1] address %p, sub_slice[0] address %p\n"</span>, arr, sub_slice, &amp;arr[<span class="number">1</span>], &amp;sub_slice[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#8195;&#8195;go语言函数传参，传的都是值，即传切片会把切片的{arrayPointer, len, cap}这3个字段拷贝一份传进来。由于传的是底层数组的指针，所以可以直接修改底层数组里的元素。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update_slice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">s[<span class="number">0</span>] = <span class="number">888</span></span><br><span class="line">&#125;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">update_slice(s)</span><br><span class="line">fmt.Printf(<span class="string">"s=%v\n"</span>, s)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Printf(<span class="string">"address of slice %p, address of array %p %p\n"</span>, &amp;s, &amp;s[<span class="number">0</span>], s)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">"address of slice %p, address of array %p %p\n"</span>, &amp;s, &amp;s[<span class="number">0</span>], s)</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">"address of slice %p, address of array %p %p\n"</span>, &amp;s, &amp;s[<span class="number">0</span>], s)</span><br></pre></td></tr></table></figure><p>获取切片的地址用&amp;s；获取切片底层数组的地址用&amp;s[0]，或直接把s当地址打印。  </p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串里可以包含任意Unicode字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">" My name is 张朝阳☻"</span></span><br></pre></td></tr></table></figure><p>字符串里可以包含转义字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"He say:\"I'm fine.\" \n\\Thank\tyou.\\"</span></span><br></pre></td></tr></table></figure><p>字符串也可以用反引号来定义，反引号里的转义字符无效。反引号里的内容原封不动地输出，包括空白符和换行符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">`here is first line. </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  there is third line.</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><p>字符串常用操作</p><table><thead><tr><th align="center">方法</th><th align="center">介绍</th></tr></thead><tbody><tr><td align="center">len(str)</td><td align="center">求长度</td></tr><tr><td align="center">strings.Split</td><td align="center">分割</td></tr><tr><td align="center">strings.Contains</td><td align="center">判断是否包含</td></tr><tr><td align="center">strings.HasPrefix,strings.HasSuffix</td><td align="center">前缀/后缀判断</td></tr><tr><td align="center">strings.Index(),strings.LastIndex()</td><td align="center">子串出现的位置</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"born to win, born to die."</span></span><br><span class="line">fmt.Printf(<span class="string">"sentence length %d\n"</span>, <span class="built_in">len</span>(s))</span><br><span class="line">fmt.Printf(<span class="string">"\"s\" length %d\n"</span>, <span class="built_in">len</span>(<span class="string">"s"</span>))  <span class="comment">//英文字母的长度为1</span></span><br><span class="line">fmt.Printf(<span class="string">"\"中\"  length %d\n"</span>, <span class="built_in">len</span>(<span class="string">"中"</span>)) <span class="comment">//一个汉字占3个长度</span></span><br><span class="line">arr := strings.Split(s, <span class="string">" "</span>)</span><br><span class="line">fmt.Printf(<span class="string">"arr[3]=%s\n"</span>, arr[<span class="number">3</span>])</span><br><span class="line">fmt.Printf(<span class="string">"contain die %t\n"</span>, strings.Contains(s, <span class="string">"die"</span>))          <span class="comment">//包含子串</span></span><br><span class="line">fmt.Printf(<span class="string">"contain wine %t\n"</span>, strings.Contains(s, <span class="string">"wine"</span>))        <span class="comment">//包含子串</span></span><br><span class="line">fmt.Printf(<span class="string">"first index of born %d\n"</span>, strings.Index(s, <span class="string">"born"</span>))    <span class="comment">//寻找子串第一次出现的位置</span></span><br><span class="line">fmt.Printf(<span class="string">"last index of born %d\n"</span>, strings.LastIndex(s, <span class="string">"born"</span>)) <span class="comment">//寻找子串最后一次出现的位置</span></span><br><span class="line">fmt.Printf(<span class="string">"begin with born %t\n"</span>, strings.HasPrefix(s, <span class="string">"born"</span>))    <span class="comment">//以xxx开头</span></span><br><span class="line">fmt.Printf(<span class="string">"end with die. %t\n"</span>, strings.HasSuffix(s, <span class="string">"die."</span>))      <span class="comment">//以xxx结尾</span></span><br></pre></td></tr></table></figure><p>把多个字符串拼接成一个长的字符串有多种方式。</p><ol><li>加号连接。</li><li>func fmt.Sprintf(format string, a …interface{}) string</li><li>func strings.Join(elems []string, sep string) string</li><li>当有大量的string需要拼接时，用strings.Builder效率最高</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"Hello"</span></span><br><span class="line">s2 := <span class="string">"how"</span></span><br><span class="line">s3 := <span class="string">"are"</span></span><br><span class="line">s4 := <span class="string">"you"</span></span><br><span class="line">merged := s1 + <span class="string">" "</span> + s2 + <span class="string">" "</span> + s3 + <span class="string">" "</span> + s4</span><br><span class="line">fmt.Println(merged)</span><br><span class="line">merged = fmt.Sprintf(<span class="string">"%s %s %s %s"</span>, s1, s2, s3, s4)</span><br><span class="line">fmt.Println(merged)</span><br><span class="line">merged = strings.Join([]<span class="keyword">string</span>&#123;s1, s2, s3, s4&#125;, <span class="string">" "</span>)</span><br><span class="line">fmt.Println(merged)</span><br><span class="line"><span class="comment">//当有大量的string需要拼接时，用strings.Builder效率最高</span></span><br><span class="line">sb := strings.Builder&#123;&#125;</span><br><span class="line">sb.WriteString(s1)</span><br><span class="line">sb.WriteString(<span class="string">" "</span>)</span><br><span class="line">sb.WriteString(s2)</span><br><span class="line">sb.WriteString(<span class="string">" "</span>)</span><br><span class="line">sb.WriteString(s3)</span><br><span class="line">sb.WriteString(<span class="string">" "</span>)</span><br><span class="line">sb.WriteString(s4)</span><br><span class="line">sb.WriteString(<span class="string">" "</span>)</span><br><span class="line">merged = sb.String()</span><br><span class="line">fmt.Println(merged)</span><br></pre></td></tr></table></figure><p>string中每个元素叫“字符”，字符有两种：</p><ol><li>byte：1个字节， 代表ASCII码的一个字符。</li><li>rune：4个字节，代表一个UTF-8字符，一个汉字可用一个rune表示。</li></ol><p>string是常量，不能修改其中的字符。<br>string可以转换为[]byte或[]rune类型。<br>string底层是byte数组，string的长度就是该byte数组的长度， UTF-8编码下一个汉字占3个byte，即一个汉字占3个长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="string">"My name is 张朝阳"</span></span><br><span class="line">arr := []<span class="keyword">byte</span>(s1)</span><br><span class="line">brr := []<span class="keyword">rune</span>(s1)</span><br><span class="line">fmt.Printf(<span class="string">"last byte %d\n"</span>, arr[<span class="built_in">len</span>(arr)<span class="number">-1</span>]) <span class="comment">//string可以转换为[]byte或[]rune类型</span></span><br><span class="line">fmt.Printf(<span class="string">"last byte %c\n"</span>, arr[<span class="built_in">len</span>(arr)<span class="number">-1</span>]) <span class="comment">//byte或rune可以转为string</span></span><br><span class="line">fmt.Printf(<span class="string">"last rune %d\n"</span>, brr[<span class="built_in">len</span>(brr)<span class="number">-1</span>])</span><br><span class="line">fmt.Printf(<span class="string">"last rune %c\n"</span>, brr[<span class="built_in">len</span>(brr)<span class="number">-1</span>])</span><br><span class="line">L := <span class="built_in">len</span>(s1)</span><br><span class="line">fmt.Printf(<span class="string">"string len %d byte array len %d rune array len %d\n"</span>, L, <span class="built_in">len</span>(arr), <span class="built_in">len</span>(brr))</span><br><span class="line"><span class="keyword">for</span> _, ele := <span class="keyword">range</span> s1 &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%c "</span>, ele) <span class="comment">//string中的每个元素是字符</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; L; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%c "</span>, s1[i]) <span class="comment">//[i]前面应该出现数组或切片，这里自动把string转成了[]byte（而不是[]rune）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>强制类型转换的基本方法就是把目标类型放在变量前面，把变量括起来。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">9</span></span><br><span class="line"><span class="keyword">var</span> by <span class="keyword">byte</span> = <span class="keyword">byte</span>(i)<span class="comment">//int转为byte</span></span><br><span class="line">i = <span class="keyword">int</span>(by)<span class="comment">//byte转为int</span></span><br></pre></td></tr></table></figure><ul><li>低精度向高精度转换没问题，高精度向低精度转换会丢失位数。</li><li>无符号向有符号转换，最高位是符号位。</li><li>byte和int可以互相转换。</li><li>float和int可以互相转换，小数位会丢失。</li><li>bool和int不能相互转换。</li><li>不同长度的int或float之间可以相互转换。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度向低精度转换，数字很小时这种转换没问题</span></span><br><span class="line"><span class="keyword">var</span> ua <span class="keyword">uint64</span> = <span class="number">1</span></span><br><span class="line">i8 := <span class="keyword">int8</span>(ua)</span><br><span class="line">fmt.Printf(<span class="string">"i8=%d\n"</span>, i8)</span><br><span class="line"></span><br><span class="line"><span class="comment">//最高位的1变成了符号位</span></span><br><span class="line">ua = <span class="keyword">uint64</span>(math.MaxUint64)</span><br><span class="line">i64 := <span class="keyword">int64</span>(ua)</span><br><span class="line">fmt.Printf(<span class="string">"i64=%d\n"</span>, i64)</span><br><span class="line"></span><br><span class="line"><span class="comment">//位数丢失</span></span><br><span class="line">ui32 := <span class="keyword">uint32</span>(ua)</span><br><span class="line">fmt.Printf(<span class="string">"ui32=%d\n"</span>, ui32)</span><br><span class="line"></span><br><span class="line"><span class="comment">//单个字符可以转为int</span></span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="keyword">int</span>(<span class="string">'a'</span>)</span><br><span class="line">fmt.Printf(<span class="string">"i=%d\n"</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//bool和int不能相互转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//byte和int可以互相转换</span></span><br><span class="line"><span class="keyword">var</span> by <span class="keyword">byte</span> = <span class="keyword">byte</span>(i)</span><br><span class="line">i = <span class="keyword">int</span>(by)</span><br><span class="line">fmt.Printf(<span class="string">"i=%d\n"</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="comment">//float和int可以互相转换，小数位会丢失</span></span><br><span class="line"><span class="keyword">var</span> ft <span class="keyword">float32</span> = <span class="keyword">float32</span>(i)</span><br><span class="line">i = <span class="keyword">int</span>(ft)</span><br><span class="line">fmt.Printf(<span class="string">"i=%d\n"</span>, i)</span><br></pre></td></tr></table></figure><p>string和其他数据类型互转。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err error</span><br><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> i64 <span class="keyword">int64</span> = <span class="keyword">int64</span>(i)</span><br><span class="line"><span class="comment">//int转string</span></span><br><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span> = strconv.Itoa(i) <span class="comment">//内部调用FormatInt</span></span><br><span class="line">s = strconv.FormatInt(i64, <span class="number">10</span>)</span><br><span class="line"><span class="comment">//string转int</span></span><br><span class="line">i, err = strconv.Atoi(s)</span><br><span class="line"><span class="comment">//string转int64</span></span><br><span class="line">i64, err = strconv.ParseInt(s, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//float转string</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">8.123456789</span></span><br><span class="line">s = strconv.FormatFloat(f, <span class="string">'f'</span>, <span class="number">2</span>, <span class="number">64</span>) <span class="comment">//保留2位小数</span></span><br><span class="line">fmt.Println(s)</span><br><span class="line"><span class="comment">//string转float</span></span><br><span class="line">f, err = strconv.ParseFloat(s, <span class="number">64</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//string&lt;--&gt;[]byte</span></span><br><span class="line"><span class="keyword">var</span> arr []<span class="keyword">byte</span> = []<span class="keyword">byte</span>(s)</span><br><span class="line">s = <span class="keyword">string</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//string&lt;--&gt;[]rune</span></span><br><span class="line"><span class="keyword">var</span> brr []<span class="keyword">rune</span> = []<span class="keyword">rune</span>(s)</span><br><span class="line">s = <span class="keyword">string</span>(brr)</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"err %v\n"</span>, err)</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>go map的底层实现是hash table，根据key查找value的时间复杂度是O(1)。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/map.png" alt="avatar">   </p><p>map的初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span> <span class="comment">//声明map，指定key和value的数据类型</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>) <span class="comment">//初始化，容量为0</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>, <span class="number">200</span>) <span class="comment">//初始化，容量为200。强烈建议初始化时给一个合适的容量，减少扩容的概率</span></span><br><span class="line">m = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">"语文"</span>: <span class="number">0</span>, <span class="string">"数学"</span>: <span class="number">39</span>&#125; <span class="comment">//初始化时直接赋值</span></span><br></pre></td></tr></table></figure><p>添加和删除key</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="string">"英语"</span>] = <span class="number">59</span> <span class="comment">//往map里添加key-value对</span></span><br><span class="line">m [<span class="string">"英语"</span>] = <span class="number">70</span> <span class="comment">//会覆盖之前的值</span></span><br><span class="line"><span class="built_in">delete</span>(m, <span class="string">"数学"</span>) <span class="comment">//从map里删除key-value对</span></span><br></pre></td></tr></table></figure><p>len(m)获取map的长度，go不支持对map上执行cap函数。<br>读取key对应的value时，如果key不存在，则返回value类型的默认值，所以强烈建议先判断key是否存在。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value, exists := m[<span class="string">"语文"</span>]; exists &#123;</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"map里不存在[语文]这个key"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历map</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历map</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"-----------"</span>)</span><br><span class="line"><span class="comment">//多次遍历map返回的顺序是不一样的，但相对顺序是一样的，因为每次随机选择一个开始位置，然后顺序遍历</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"-----------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一边遍历一边修改</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    m[key] = value + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"-----------"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//for range取得的是值拷贝</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    value = value + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%s=%d\n"</span>, key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map中的key可以是任意能够用==操作符比较的类型，不能是函数、map、切片，以及包含上述3中类型成员变量的的struct。map的value可以是任意类型。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="keyword">type</span> m <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">type</span> s []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> i <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[i]f</span><br><span class="line">fmt.Println(m1)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 函数、map、切片不能当key **/</span></span><br><span class="line"><span class="comment">// var m2 map[f]bool</span></span><br><span class="line"><span class="comment">// fmt.Println(m2)</span></span><br><span class="line"><span class="comment">// var m3 map[m]bool</span></span><br><span class="line"><span class="comment">// fmt.Println(m3)</span></span><br><span class="line"><span class="comment">// var m4 map[s]bool</span></span><br><span class="line"><span class="comment">// fmt.Println(m4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">scores <span class="keyword">float32</span> <span class="comment">//如果scores是slice，则user不能作为map的key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := user&#123;&#125;</span><br><span class="line">m5 := <span class="built_in">make</span>(<span class="keyword">map</span>[user]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">m5[u] = <span class="number">5</span></span><br><span class="line">fmt.Println(m5)</span><br></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>&#8195;&#8195;channel(管道)底层是一个环形队列(先进先出)，send(插入)和recv(取走)从同一个位置沿同一个方向顺序执行。sendx表示最后一次插入元素的位置，recvx表示最后一次取走元素的位置。<br><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/channel.png" alt="avatar">  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">//管道的声明</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">8</span>) <span class="comment">//管道的初始化，环形队列里可容纳8个int</span></span><br><span class="line">ch &lt;- <span class="number">1</span>                <span class="comment">//往管道里写入(send)数据</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">ch &lt;- <span class="number">4</span></span><br><span class="line">ch &lt;- <span class="number">5</span></span><br><span class="line">v := &lt;-ch <span class="comment">//从管道里取走(recv)数据</span></span><br><span class="line">fmt.Println(v)</span><br><span class="line">v = &lt;-ch</span><br><span class="line">fmt.Println(v)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read_only := <span class="built_in">make</span> (&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)   <span class="comment">//定义只读的channel</span></span><br><span class="line">write_only := <span class="built_in">make</span> (<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)   <span class="comment">//定义只写的channel</span></span><br></pre></td></tr></table></figure><p>定义只读和只写的channel意义不大，一般用于在参数传递中。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能向channel里写数据 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123; </span><br><span class="line">    c &lt;- <span class="number">1</span> </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//只能取channel中的数据 </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">_ = &lt;-c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个只读channel</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Context)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过for range遍历并取走管道里的元素，当管道为空且被close后，for循环退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br><span class="line"><span class="comment">//遍历并取走（receive）管道里的元素。当管道里已无剩余元素且没有close管道时，receive操作会一直阻塞，最终报deadlock。当管道为空且被close后，for循环退出。</span></span><br><span class="line"><span class="keyword">for</span> ele := <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(ele)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>slice、map和channel是go语言里的3种引用类型，都可以通过make函数来进行初始化（申请内存分配）。因为它们都包含一个指向底层数据结构的指针，所以称之为“引用”类型。引用类型未初始化时都是nil，可以对它们执行len()函数，返回0。</p>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Go基础语法]</title>
    <link href="http://yoursite.com/2021/04/21/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2021/04/21/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2021-04-21T12:29:20.000Z</published>
    <updated>2021-04-21T13:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go基础语法"><a href="#Go基础语法" class="headerlink" title="Go基础语法"></a>Go基础语法</h1><h2 id="标识符与关键字"><a href="#标识符与关键字" class="headerlink" title="标识符与关键字"></a>标识符与关键字</h2><p>go变量、常量、自定义类型、包、函数的命名方式必须遵循以下规则：</p><ol><li>首字符可以是任意Unicode字符或下划线。</li><li>首字符之外的部分可以是Unicode字符、下划线或数字。</li><li>名字的长度无限制。</li></ol><blockquote><p>理论上名字里可以有汉字，甚至可以全是汉字，但实际中不要这么做。</p></blockquote><p>Go语言关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break  default  func  interface  select  case  defer  go  map  struct  chan  else  goto  package  switch  const  if  range  type  continue  for  import  return  fallthrough  var</span><br></pre></td></tr></table></figure><p>常量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true  false  iota  nil</span><br></pre></td></tr></table></figure><p>数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int  int8  int16  int32  int64  uint  uint8  uint16  uint32  uint64  uintptr  float32  float64  complex128  complex64  bool  byte  rune  string  error</span><br></pre></td></tr></table></figure><p>函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make  len  cap  new  append  copy  close  delete  complex  real  imag  panic  recover</span><br></pre></td></tr></table></figure><h2 id="操作符与表达式"><a href="#操作符与表达式" class="headerlink" title="操作符与表达式"></a>操作符与表达式</h2><p>算法术运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">相加</td></tr><tr><td align="center">-</td><td align="center">相减</td></tr><tr><td align="center">*</td><td align="center">相乘</td></tr><tr><td align="center">/</td><td align="center">相除</td></tr><tr><td align="center">%</td><td align="center">求余</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//arithmetic 算术运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">arithmetic</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = a + b</span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">float32</span> = a - b</span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">float32</span> = a * b</span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float32</span> = a / b</span><br><span class="line">fmt.Printf(<span class="string">"a=%.3f, b=%.3f, c=%.3f, d=%.3f, e=%.3f, f=%.3f\n"</span>, a, b, c, d, e, f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关系运算符</p><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">==</td><td align="left">检查两个值是否相等，如果相等返回 True 否则返回 False</td></tr><tr><td align="center">!=</td><td align="left">检查两个值是否不相等，如果不相等返回 True 否则返回 False</td></tr><tr><td align="center">&gt;</td><td align="left">检查左边值是否大于右边值，如果是返回 True 否则返回 False</td></tr><tr><td align="center">&gt;=</td><td align="left">检查左边值是否大于等于右边值，如果是返回 True 否则返回 False</td></tr><tr><td align="center">&lt;</td><td align="left">检查左边值是否小于右边值，如果是返回 True 否则返回 False</td></tr><tr><td align="center">&lt;=</td><td align="left">检查左边值是否小于等于右边值，如果是返回 True 否则返回 False</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//relational 关系运算符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">relational</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = <span class="number">8</span></span><br><span class="line">fmt.Printf(<span class="string">"a==b吗 %t\n"</span>, a == b)</span><br><span class="line">fmt.Printf(<span class="string">"a!=b吗 %t\n"</span>, a != b)</span><br><span class="line">fmt.Printf(<span class="string">"a&gt;b吗 %t\n"</span>, a &gt; b)</span><br><span class="line">fmt.Printf(<span class="string">"a&gt;=b吗 %t\n"</span>, a &gt;= b)</span><br><span class="line">fmt.Printf(<span class="string">"a&lt;c吗 %t\n"</span>, a &lt; b)</span><br><span class="line">fmt.Printf(<span class="string">"a&lt;=c吗 %t\n"</span>, a &lt;= c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑运算符  </p><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="left">逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False</td></tr><tr><td align="center">||</td><td align="left">逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False</td></tr><tr><td align="center">!</td><td align="left">逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//logistic 逻辑运算符</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logistic</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">float32</span> = <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float32</span> = <span class="number">8</span></span><br><span class="line">fmt.Printf(<span class="string">"a&gt;b &amp;&amp; b&gt;c吗 %t\n"</span>, a &gt; b &amp;&amp; b &gt; c)</span><br><span class="line">fmt.Printf(<span class="string">"a&gt;b || b&gt;c吗 %t\n"</span>, a &gt; b || b &gt; c)</span><br><span class="line">fmt.Printf(<span class="string">"a&gt;b不成立，对吗 %t\n"</span>, !(a &gt; b))</span><br><span class="line">fmt.Printf(<span class="string">"b&gt;c不成立，对吗 %t\n"</span>, !(b &gt; c))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位运算符</p><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="left">参与运算的两数各对应的二进位相与（两位均为1才为1）</td></tr><tr><td align="center">|</td><td align="left">参与运算的两数各对应的二进位相或（两位有一个为1就为1）</td></tr><tr><td align="center">^</td><td align="left">参与运算的两数各对应的二进位相异或，当两对应的二进位相同时为0，不同时为1。作为一元运算符时表示按位取反，，符号位也跟着变</td></tr><tr><td align="center">&lt;&lt;</td><td align="left">左移n位就是乘以2的n次方。a&lt;&lt;b是把a的各二进位全部左移b位，高位丢弃，低位补0。通过左移，符号位可能会变</td></tr><tr><td align="center">&gt;&gt;</td><td align="left">右移n位就是除以2的n次方。a&gt;&gt;b是把a的各二进位全部右移b位，正数高位补0，负数高位补1</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bit_op 位运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bit_op</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"os arch %s, int size %d\n"</span>, runtime.GOARCH, strconv.IntSize) <span class="comment">//int是4字节还是8字节，取决于操作系统是32位还是64位</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int32</span> = <span class="number">260</span></span><br><span class="line">fmt.Printf(<span class="string">"260     %s\n"</span>, util.BinaryFormat(a))</span><br><span class="line">fmt.Printf(<span class="string">"-260    %s\n"</span>, util.BinaryFormat(-a)) <span class="comment">//负数用补码表示。在对应正数二进制表示的基础上，按拉取反，再末位加1</span></span><br><span class="line">fmt.Printf(<span class="string">"260&amp;4   %s\n"</span>, util.BinaryFormat(a&amp;<span class="number">4</span>))</span><br><span class="line">fmt.Printf(<span class="string">"260|3   %s\n"</span>, util.BinaryFormat(a|<span class="number">3</span>))</span><br><span class="line">fmt.Printf(<span class="string">"260^7   %s\n"</span>, util.BinaryFormat(a^<span class="number">7</span>))     <span class="comment">//^作为二元运算符时表示异或</span></span><br><span class="line">fmt.Printf(<span class="string">"^-260   %s\n"</span>, util.BinaryFormat(^-a))     <span class="comment">//^作为一元运算符时表示按位取反，符号位也跟着变</span></span><br><span class="line">fmt.Printf(<span class="string">"-260&gt;&gt;10 %s\n"</span>, util.BinaryFormat(-a&gt;&gt;<span class="number">10</span>)) <span class="comment">//正数高位补0，负数高位补1</span></span><br><span class="line">fmt.Printf(<span class="string">"-260&lt;&lt;3 %s\n"</span>, util.BinaryFormat(-a&lt;&lt;<span class="number">3</span>))   <span class="comment">//负数左移，可能变成正数</span></span><br><span class="line"><span class="comment">//go语言没有循环（无符号）左/右移符号   &gt;&gt;&gt;  &lt;&lt;&lt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>位移运算</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正数右移：高位补<span class="number">0</span></span><br><span class="line">负数右移：高位补<span class="number">1</span></span><br><span class="line">负数左移：低位补<span class="number">0</span></span><br></pre></td></tr></table></figure><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/%E6%88%AA%E5%B1%8F2022-12-13%2019.39.31.png" alt="截屏2022-12-13 19.39.31">   </p><p>位运算的应用场景：  </p><ul><li>逻辑控制（运算快，省CPU）</li><li>bitmap和bloom filter（省内存）</li></ul><p>总之，位运算适用于对性能要求高的场景。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bit_application</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> gender <span class="keyword">string</span> = <span class="string">"男"</span></span><br><span class="line"><span class="keyword">var</span> degree <span class="keyword">string</span> = <span class="string">"本科"</span></span><br><span class="line"><span class="keyword">var</span> is985 <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> condition1 <span class="keyword">bool</span> = gender == <span class="string">"男"</span></span><br><span class="line"><span class="keyword">var</span> condition2 <span class="keyword">bool</span> = gender == <span class="string">"男"</span> &amp;&amp; is985</span><br><span class="line"><span class="keyword">var</span> condition3 <span class="keyword">bool</span> = gender == <span class="string">"男"</span> &amp;&amp; degree == <span class="string">"硕士"</span> &amp;&amp; is985</span><br><span class="line">fmt.Printf(<span class="string">"满足条件1 %t\n"</span>, condition1)</span><br><span class="line">fmt.Printf(<span class="string">"满足条件2 %t\n"</span>, condition2)</span><br><span class="line">fmt.Printf(<span class="string">"满足条件3 %t\n"</span>, condition3)</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">var</span> gender <span class="keyword">byte</span> = <span class="number">1</span>      <span class="comment">//末位，1：男，0：女</span></span><br><span class="line"><span class="keyword">var</span> degree <span class="keyword">byte</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span> <span class="comment">//倒数第二位，1：硕士，0：本科</span></span><br><span class="line"><span class="keyword">var</span> is985 <span class="keyword">byte</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>  <span class="comment">//倒数第三位，1：是985，2：不是985</span></span><br><span class="line"><span class="keyword">var</span> man <span class="keyword">byte</span> = gender | is985</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> condition1 <span class="keyword">byte</span> = gender</span><br><span class="line"><span class="keyword">var</span> condition2 <span class="keyword">byte</span> = gender | is985</span><br><span class="line"><span class="keyword">var</span> condition3 <span class="keyword">byte</span> = gender | is985 | degree</span><br><span class="line">fmt.Printf(<span class="string">"满足条件1 %t\n"</span>, man&amp;condition1 == condition1)</span><br><span class="line">fmt.Printf(<span class="string">"满足条件2 %t\n"</span>, man&amp;condition2 == condition2)</span><br><span class="line">fmt.Printf(<span class="string">"满足条件3 %t\n"</span>, man&amp;condition3 == condition3)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>赋值运算符</p><table><thead><tr><th align="center">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="center">=</td><td align="left">简单的赋值运算符，将一个表达式的值赋给一个左值</td></tr><tr><td align="center">+=</td><td align="left">相加后再赋值</td></tr><tr><td align="center">-=</td><td align="left">相减后再赋值</td></tr><tr><td align="center">*=</td><td align="left">相乘后再赋值</td></tr><tr><td align="center">/=</td><td align="left">相除后再赋值</td></tr><tr><td align="center">%=</td><td align="left">求余后再赋值</td></tr><tr><td align="center">&lt;&lt;=</td><td align="left">左移后赋值</td></tr><tr><td align="center">&gt;&gt;=</td><td align="left">右移后赋值</td></tr><tr><td align="center">&amp;=</td><td align="left">按位与后赋值</td></tr><tr><td align="center">|=</td><td align="left">按位或后赋值</td></tr><tr><td align="center">^=</td><td align="left">按位异或后赋值</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//assignment 赋值运算</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">assignment</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a += b</span><br><span class="line">fmt.Printf(<span class="string">"a+=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a -= b</span><br><span class="line">fmt.Printf(<span class="string">"a-=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a *= b</span><br><span class="line">fmt.Printf(<span class="string">"a*=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a /= b</span><br><span class="line">fmt.Printf(<span class="string">"a/=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a %= b</span><br><span class="line">fmt.Printf(<span class="string">"a%%=b %d\n"</span>, a) <span class="comment">//%在fmt里有特殊含意，所以需要前面再加个%转义一下</span></span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a &lt;&lt;= b</span><br><span class="line">fmt.Printf(<span class="string">"a&lt;&lt;=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a &gt;&gt;= b</span><br><span class="line">fmt.Printf(<span class="string">"a&gt;&gt;=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a &amp;= b</span><br><span class="line">fmt.Printf(<span class="string">"a&amp;=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a |= b</span><br><span class="line">fmt.Printf(<span class="string">"a|=b %d\n"</span>, a)</span><br><span class="line">a, b = <span class="number">8</span>, <span class="number">3</span></span><br><span class="line">a ^= b</span><br><span class="line">fmt.Printf(<span class="string">"a^=b %d\n"</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>按按取反</span><br><span class="line"><span class="number">2.</span>末位加<span class="number">1</span></span><br><span class="line"></span><br><span class="line">最高位为<span class="number">0</span>是正数</span><br><span class="line">最高位为<span class="number">1</span>是负数</span><br></pre></td></tr></table></figure><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/%E6%88%AA%E5%B1%8F2022-12-13%2019.27.14.png" alt="截屏2022-12-13 19.27.14"></p><h2 id="变量、常量、字面量"><a href="#变量、常量、字面量" class="headerlink" title="变量、常量、字面量"></a>变量、常量、字面量</h2><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><table><thead><tr><th align="center">类型</th><th align="center">go变量类型</th><th align="center">fmt输出</th></tr></thead><tbody><tr><td align="center">整型</td><td align="center">int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64</td><td align="center">%d %b %x</td></tr><tr><td align="center">浮点型</td><td align="center">float32 float64</td><td align="center">%f %e %g</td></tr><tr><td align="center">布尔型</td><td align="center">bool</td><td align="center">%t</td></tr><tr><td align="center">指针</td><td align="center">uintptr</td><td align="center">%p</td></tr><tr><td align="center">引用</td><td align="center">map slice channel</td><td align="center">%v</td></tr><tr><td align="center">字节</td><td align="center">byte</td><td align="center">%c</td></tr><tr><td align="center">任意字符</td><td align="center">rune</td><td align="center">%c</td></tr><tr><td align="center">字符串</td><td align="center">string</td><td align="center">%s</td></tr><tr><td align="center">错误</td><td align="center">error</td><td align="center">%v</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> = <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">uint</span>比<span class="keyword">int</span>的可用大小*<span class="number">2</span>（<span class="keyword">int</span>需要有<span class="number">1</span>位表示正负）</span><br></pre></td></tr></table></figure><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>Go语言变量必须先声明再使用，所谓使用指读取或修改。<br>标题声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> </span><br><span class="line"><span class="keyword">var</span> age <span class="keyword">int</span> </span><br><span class="line"><span class="keyword">var</span> isOk <span class="keyword">bool</span></span><br></pre></td></tr></table></figure><p>批量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ( </span><br><span class="line">name <span class="keyword">string</span> </span><br><span class="line">age <span class="keyword">int</span> </span><br><span class="line">isOk <span class="keyword">bool</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>如果声明后未显式初始化，数值型初始化0，字符串初始化为空字符串，布尔型初始化为false，引用类型、函数、指针、接口初始化为nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span>=<span class="string">"china"</span>  <span class="comment">//初始化一个变量</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="string">"china"</span>  <span class="comment">//类型推断为string</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="keyword">int</span>=<span class="number">3</span>,<span class="number">7</span>  <span class="comment">//初始化多个变量</span></span><br><span class="line"><span class="keyword">var</span> a,b=<span class="string">"china"</span>,<span class="number">7</span>  <span class="comment">//初始化多个变量，每个变量都单独地执行类型推断</span></span><br></pre></td></tr></table></figure><p>函数内部的变量(非全局变量)可以通过:=声明并初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>下划线表示匿名变量。匿名变量不占命名空间，不会分配内存，因此可以重复使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_=<span class="number">2</span>+<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量在定义时必须赋值，且程序运行期间其值不能改变。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI <span class="keyword">float32</span>=<span class="number">3.14</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    PI=<span class="number">3.14</span></span><br><span class="line">    E=<span class="number">2.71</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a=<span class="number">100</span></span><br><span class="line">    b<span class="comment">//100，跟上一行的值相同</span></span><br><span class="line">    c<span class="comment">//100，跟上一行的值相同</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>iota</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a=<span class="literal">iota</span><span class="comment">//0</span></span><br><span class="line">    b<span class="comment">//1</span></span><br><span class="line">    c<span class="comment">//2</span></span><br><span class="line">    d<span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a=<span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    b<span class="comment">//1</span></span><br><span class="line">    _<span class="comment">//2</span></span><br><span class="line">    d<span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a=<span class="literal">iota</span> <span class="comment">//0</span></span><br><span class="line">    b=<span class="number">30</span>    </span><br><span class="line">    c=<span class="literal">iota</span> <span class="comment">//2</span></span><br><span class="line">    d<span class="comment">//3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    _=<span class="literal">iota</span><span class="comment">// iota =0</span></span><br><span class="line">    KB=<span class="number">1</span>&lt;&lt;(<span class="number">10</span>* <span class="literal">iota</span>) <span class="comment">// iota =1</span></span><br><span class="line">    MB=<span class="number">1</span>&lt;&lt;(<span class="number">10</span>* <span class="literal">iota</span>) <span class="comment">// iota =2</span></span><br><span class="line">    GB=<span class="number">1</span>&lt;&lt;(<span class="number">10</span>* <span class="literal">iota</span>) <span class="comment">// iota =3</span></span><br><span class="line">    TB=<span class="number">1</span>&lt;&lt;(<span class="number">10</span>* <span class="literal">iota</span>) <span class="comment">// iota =4</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>(</span><br><span class="line">    a,b=<span class="literal">iota</span>+<span class="number">1</span>, <span class="literal">iota</span>+<span class="number">2</span><span class="comment">//1,2  iota =0</span></span><br><span class="line">     c,d<span class="comment">//2,3  iota =1</span></span><br><span class="line">     e,f<span class="comment">//3,4  iota =2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>字面量–没有出现变量名，直接出现了值。基础类型的字面量相当于是常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, <span class="number">04</span> == <span class="number">4.00</span>) <span class="comment">//用到了整型字面量和浮点型字面量</span></span><br><span class="line">fmt.Printf(<span class="string">"%v\n"</span>, <span class="number">.4i</span>) <span class="comment">//虚数字面量 0.4i</span></span><br><span class="line">fmt.Printf(<span class="string">"%t\n"</span>, <span class="string">'\u4f17'</span> == <span class="string">'众'</span>) <span class="comment">//Unicode和rune字面量</span></span><br><span class="line">fmt.Printf(<span class="string">"Hello\nWorld\n!\n"</span>) <span class="comment">//字符串字面量</span></span><br></pre></td></tr></table></figure><h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>&#8195;&#8195;对于全局变量，如果以大写字母开头，所有地方都可以访问，跨package访问时需要带上package名称；如果以小写字母开头，则本package内都可以访问。<br>&#8195;&#8195;函数内部的局部变量，仅本函数内可以访问。{}可以固定一个作用域。内部声明的变量可以跟外部声明的变量有冲突，以内部的为准–就近原则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    A=<span class="number">3</span><span class="comment">//所有地方都可以访问</span></span><br><span class="line">    b=<span class="number">4</span><span class="comment">//本package内可以访问</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    b:=<span class="number">5</span>  <span class="comment">//本函数内可以访问</span></span><br><span class="line">    &#123;</span><br><span class="line">        b:=<span class="number">6</span>  <span class="comment">//本作用域内可以访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释与godoc"><a href="#注释与godoc" class="headerlink" title="注释与godoc"></a>注释与godoc</h2><h3 id="注释的形式"><a href="#注释的形式" class="headerlink" title="注释的形式"></a>注释的形式</h3><ul><li>单行注释，以//打头。</li><li>多行注释有2种形式：<ol><li>连续多行以//打头，注意多行注释之间不能出现空行。</li><li>在段前使用/*，段尾使用*/。</li></ol></li><li>注释行前加缩进即可写go代码。</li><li>注释中给定的关键词。NOTE: 引人注意，TODO: 将来需要优化，Deprecated: 变量或函数强烈建议不要再使用。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Add 2个整数相加</span></span><br><span class="line"><span class="comment">//返回和。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//<span class="doctag">NOTE:</span> 注释可以有多行，但中间不能出现空行（仅有//不算空行）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sub 函数使用示例：</span></span><br><span class="line"><span class="comment">  for i:=0;i&lt;3;i++&#123;</span></span><br><span class="line"><span class="comment">  Sub(i+1, i)</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">看到了吗？只需要行前缩进，注释里就可以写go代码，是不是很简单。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sub</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//<span class="doctag">TODO:</span> Prod 该函数不能并发调用，需要优化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Prod</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Deprecated: Div 不要再调用了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注释的位置"><a href="#注释的位置" class="headerlink" title="注释的位置"></a>注释的位置</h3><p>针对行的注释在行上方或右侧。函数的上方在func xxx()上方。结构体的注释在type xxx struct上方。包注释在package xxx的上方。一个包只需要在一个地方写包注释，通常会专门写一个doc.go，里面只有一行package xxx和关于包的注释。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FormatBool, FormatFloat, FormatInt, and FormatUint convert values to strings:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//s := strconv.FormatBool(true)</span></span><br><span class="line"><span class="comment">//s := strconv.FormatFloat(3.1415, 'E', -1, 64)</span></span><br><span class="line"><span class="comment">//s := strconv.FormatInt(-42, 16)</span></span><br><span class="line"><span class="comment">//s := strconv.FormatUint(42, 16)</span></span><br><span class="line"><span class="keyword">package</span> fmt</span><br></pre></td></tr></table></figure><h3 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a>go doc</h3><p>go doc是go自带的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go doc entrance_class/util</span><br></pre></td></tr></table></figure><p>上述命令查看entrance_class/util包的注释。</p><h3 id="godoc"><a href="#godoc" class="headerlink" title="godoc"></a>godoc</h3><p>godoc是第三方工具，可以为项目代码导出网页版的注释文档。安装godoc命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u golang.org/x/tools/cmd/godoc</span><br><span class="line">go install golang.org/x/tools/cmd/godoc@latest</span><br></pre></td></tr></table></figure><p>启动http服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">godoc -http=:6060</span><br></pre></td></tr></table></figure><p>用浏览器访问<a href="http://127.0.0.1:6060" target="_blank" rel="noopener">http://127.0.0.1:6060</a> ，可以查看go标准库的文档。 </p>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[初识Go语言]</title>
    <link href="http://yoursite.com/2021/04/21/%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2021/04/21/%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80/</id>
    <published>2021-04-21T12:29:10.000Z</published>
    <updated>2021-04-21T13:11:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识Go语言"><a href="#初识Go语言" class="headerlink" title="初识Go语言"></a>初识Go语言</h1><h2 id="Go语言发展历史"><a href="#Go语言发展历史" class="headerlink" title="Go语言发展历史"></a>Go语言发展历史</h2><h3 id="阵容豪华的创使人团队"><a href="#阵容豪华的创使人团队" class="headerlink" title="阵容豪华的创使人团队"></a>阵容豪华的创使人团队</h3><p><strong>Ken Thompson</strong></p><ul><li>1966年：加入了贝尔实验室，在参与 Multics （多路信息计算）开发期间，创造出了B语言，并用一个月的时间用B语言开发了全新的操作系统UNICS，后来改名为我们所熟悉的UNIX 操作系统。</li><li>1971年：和丹尼斯·利奇（Dennis Ritchie）一起共同发明了C语言。</li><li>1973年：和丹尼斯·利奇（Dennis Ritchie）使用C语言重写了UNIX，并安装于PDP-11的机器之上。</li><li>1983年：美国计算机协会将图灵奖授予汤普森。</li><li>2000年：离开贝尔实验室，已退休的汤普森成为了一名飞行员。</li><li>2006年：加入Google工作。</li><li>2007年：64岁的高龄，与Rob Pike和Robert Griesemer主导了Go语言的开发。</li></ul><p><strong>Rob Pike</strong></p><ul><li>Go语言项目总负责人。</li><li>贝尔实验室Unix团队成员，参与的项目包括Plan 9，Inferno操作系统和Limbo编程语言。</li><li>UTF-8字符集规范唯二的发明人之一（另一位是Ken Thompson）。</li><li>《UNIX环境编程》和《程序设计实践》这两本书的作者之一。</li><li>第22届莫斯科夏季奥运会射箭项目的银牌得主。</li><li>业余天文学家，设计的珈玛射线望远镜差点被 NASA 用在航天飞机上。</li><li>他的媳妇Renee French 就是 Go 语言吉祥物的设计人。</li></ul><p><strong>Robert Griesemer</strong></p><ul><li>参与V8 JavaScript引擎的开发。</li><li>参与Java HotSpot虚拟机的研发。</li></ul><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>&#8195;&#8195;2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言吧，首先名字得简单好记，大腿一拍就叫“go”。<br>&#8195;&#8195;把事情搞复杂很容易，把事情搞简单才更深刻。</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><ul><li>2007年9月21日，开始雏形设计。</li><li>2009年10月30日，Rob Pike宣布了Go语言的存在。</li><li>2009年11月10日，以完全开源的方式公布了Linux和Mac OSX上的版本，11月22日公布了Windows版本。</li><li>2010年1月8日，当选2009年年度语言。</li><li>2010年5月，谷歌投入使用。</li><li>2011年4月，谷歌开始抽调员工全职开发Go语言，并于5月宣布Google APP Engine支持Go语言。</li></ul><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/tiobe_index_for_go.png" alt="tiobe_index_for_go"></p><p>参考网站<a href="https://www.test.tiobe.com/tiobe-index/go。" target="_blank" rel="noopener">https://www.test.tiobe.com/tiobe-index/go。</a> </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/git_hut_pull_request_for_go1.png" alt="avatar"><br><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/git_hut_pull_request_for_go2.png" alt="avatar">  </p><p>参考网站<a href="https://madnight.github.io/githut/#/pull_requests。" target="_blank" rel="noopener">https://madnight.github.io/githut/#/pull_requests。</a></p><h3 id="现状"><a href="#现状" class="headerlink" title="现状"></a>现状</h3><p>&#8195;&#8195;从世界范围看，Go语言在中国的发展势头最猛，且远超第二名。在很多互联网大厂Go已成为主要开发语言。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/chinese_company_use_go.png" alt="avatar"></p><p>&#8195;&#8195;不论大小公司，对Go人才需求紧迫，薪酬很高。  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/go_position.png" alt="avatar"></p><h2 id="Go语言的优劣"><a href="#Go语言的优劣" class="headerlink" title="Go语言的优劣"></a>Go语言的优劣</h2><p><strong>优势</strong></p><ul><li>语法简单，易于学习。类C的语法，同时比C/C++简洁和干净。</li><li>自带GC，方便使用。</li><li>快速编译，高效执行。</li><li>简单的依赖管理。</li><li>并发编程，轻松驾驭。</li><li>静态类型，同时有一些动态语言的特征(var声明)。</li><li>标准类库，规范统一。<br><strong>劣势</strong></li><li>不支持动态加载代码。</li><li>发展时间短，生态不及Java、C++庞大，但是够用。 </li></ul><h2 id="Go语言的应用场景"><a href="#Go语言的应用场景" class="headerlink" title="Go语言的应用场景"></a>Go语言的应用场景</h2><h3 id="应用场景总览"><a href="#应用场景总览" class="headerlink" title="应用场景总览"></a>应用场景总览</h3><ul><li>巨型中央服务器领域。</li><li>高性能分布式领域。</li><li>游戏服务端开发。</li><li>复杂事件处理。</li><li>对实时性要求很高的软件开发。</li><li>可以在Intel和ARM处理器上运行，因此也可以在安卓上运行。</li></ul><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/application_of_go.png" alt="avatar"></p><h3 id="go微服务开发"><a href="#go微服务开发" class="headerlink" title="go微服务开发"></a>go微服务开发</h3><ul><li>零依赖，让我们可以最小化我们的镜像,节省存储与拉取镜像带宽。</li><li>Runtime使用更小的内存，对比Java的JVM。</li><li>更好的并行能力，当你真的需求更多CPU的时候。</li><li>更高的性能，对比解释性语言，在处理数据已经并发方面优势明显。</li><li>简单，学习成本低，内部人员可以转入Go阵营。</li><li>使用Go能更接近云原生生态，比如docker，k8s, habor都是用Go开发的。 </li></ul><h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><ol><li>下载。到<a href="https://studygolang.com/dl上下载最新的Go稳定版本。" target="_blank" rel="noopener">https://studygolang.com/dl上下载最新的Go稳定版本。</a></li><li>安装。对于Windows和macOS用户，直接双击即可安装，留意一下安装路径。对于Linux用户，直接解压安装包即可，比如你打算把go安装到/usr/local目录下，则使用命令<br>tar zxvf goxxx.tar.gz –C /usr/local。这样go标准库及相关的可执行文件就安装到了/usr/local/go目录下，在后续的步骤中会把/usr/local/go赋给GOROOT环境变量。  </li><li>准确GOPATH。在任意目录下创建一个空目录，将来用于存放go语言第三方库文件。比如你打算使用/data/go_path这个目录，则在Linux下使用命令mkdir -p /data/go_path。在GOPATH目录建3个子目录：src、bin、pkg。  </li><li>配置环境变量。把第2步和第3步生成的目录分别赋给GOROOT和GOPATH环境变量，对于Linux和Mac用户在~/.bashrc文件中追加以下几行</li><li>GOPROXY的设置参考：<a href="https://goproxy.io/zh/" target="_blank" rel="noopener">https://goproxy.io/zh/</a></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/Users/Amor/go_path</span><br><span class="line">export PATH=$PATH:$GOROOT/bin::$GOPATH/bin</span><br><span class="line"></span><br><span class="line">source ~/.bashrc </span><br><span class="line"></span><br><span class="line">注意：apple M1在~/.zshrc下写入</span><br></pre></td></tr></table></figure><p>PATH环境变量下的可执行文件在任意目录下都可以直接访问。<br>对于Windows用户，编辑用户环境变量，新增GOROOT和GOPATH，把GOROOT/bin和GOPATH/bin添加到Path里。如下图<br><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/%E8%AE%BE%E7%BD%AEgo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F1.png" alt="avatar">  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/%E8%AE%BE%E7%BD%AEgo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F2.png" alt="avatar">   </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/%E8%AE%BE%E7%BD%AEgo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F3.png" alt="avatar">  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/%E8%AE%BE%E7%BD%AEgo%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F4.png" alt="avatar">  </p><p>在Windows下还可以通过go env -w来设置环境变量，比如设置GOPROXY用以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go env -w GOPROXY=https://goproxy.cn,direct</span><br></pre></td></tr></table></figure><p>有很多网站支持在线编辑Go代码并查看运行结果，这里列举一些<br><a href="https://play.golang.wiki" target="_blank" rel="noopener">https://play.golang.wiki</a><br><a href="https://play.studygolang.com" target="_blank" rel="noopener">https://play.studygolang.com</a><br><a href="https://goplay.space" target="_blank" rel="noopener">https://goplay.space</a><br><a href="https://goplay.tools" target="_blank" rel="noopener">https://goplay.tools</a><br>集成开发环境推荐GoLand和VSCode，后者是免费的。VSCode需要额外安装支持Go语言的插件，如下图  </p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/go_plugin_for_vscode.png" alt="avatar"></p><p>Debug工具安装</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-<span class="keyword">select</span> --install</span><br></pre></td></tr></table></figure><h2 id="第一个Go程序"><a href="#第一个Go程序" class="headerlink" title="第一个Go程序"></a>第一个Go程序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main()函数是Go程序的唯一入口，且main()函数必须位于package main中。fmt是Go标准库中的一个package，该package下有一个Println()函数用于输出字符串。Go语言会依次从以下3个目录里查找依赖包：</p><ol><li>当前工作目录</li><li>$GOPATH/pkg/mod</li><li>$GOROOT/src</li></ol><h2 id="Go命令介绍"><a href="#Go命令介绍" class="headerlink" title="Go命令介绍"></a>Go命令介绍</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">(base) zcymac:~ zcy$ go help</span><br><span class="line">Go is a tool for managing Go source code.</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"></span><br><span class="line">go &lt;command&gt; [arguments]</span><br><span class="line"></span><br><span class="line">The commands are:</span><br><span class="line"></span><br><span class="line">bug         start a bug report</span><br><span class="line">build       compile packages and dependencies</span><br><span class="line">clean       remove object files and cached files</span><br><span class="line">doc         show documentation for package or symbol</span><br><span class="line">env         print Go environment information</span><br><span class="line">fix         update packages to use new APIs</span><br><span class="line">fmt         gofmt (reformat) package sources</span><br><span class="line">generate    generate Go files by processing source</span><br><span class="line">get         add dependencies to current module and install them</span><br><span class="line">install     compile and install packages and dependencies</span><br><span class="line">list        list packages or modules</span><br><span class="line">mod         module maintenance</span><br><span class="line">run         compile and run Go program</span><br><span class="line">test        test packages</span><br><span class="line">tool        run specified go tool</span><br><span class="line">version     print Go version</span><br><span class="line">vet         report likely mistakes in packages</span><br><span class="line"></span><br><span class="line">Use "go help &lt;command&gt;" for more information about a command.</span><br><span class="line"></span><br><span class="line">Additional help topics:</span><br><span class="line"></span><br><span class="line">buildconstraint build constraints</span><br><span class="line">buildmode       build modes</span><br><span class="line">c               calling between Go and C</span><br><span class="line">cache           build and test caching</span><br><span class="line">environment     environment variables</span><br><span class="line">filetype        file types</span><br><span class="line">go.mod          the go.mod file</span><br><span class="line">gopath          GOPATH environment variable</span><br><span class="line">gopath-get      legacy GOPATH go get</span><br><span class="line">goproxy         module proxy protocol</span><br><span class="line">importpath      import path syntax</span><br><span class="line">modules         modules, module versions, and more</span><br><span class="line">module-get      module-aware go get</span><br><span class="line">module-auth     module authentication using go.sum</span><br><span class="line">packages        package lists and patterns</span><br><span class="line">private         configuration for downloading non-public code</span><br><span class="line">testflag        testing flags</span><br><span class="line">testfunc        testing functions</span><br><span class="line">vcs             controlling version control with GOVCS</span><br><span class="line"></span><br><span class="line">Use "go help &lt;topic&gt;" for more information about that topic.</span><br></pre></td></tr></table></figure><p>go help: 查看帮助文档。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go help build</span><br></pre></td></tr></table></figure><p>go build: 对源代码和依赖的文件进行打包，生成可执行文件。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go build -o my_first_go_exe entrance_class/demo.go</span><br></pre></td></tr></table></figure><p>go install: 编译并安装包或依赖，安装到$GOPATH/bin下。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install entrance_class/demo.go</span><br></pre></td></tr></table></figure><p>go get: 把依赖库添加到当前module中，如果本机之前从未下载过则先下载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/tinylib/msgp</span><br></pre></td></tr></table></figure><p>以上命令会在$GOPATH/pkg/mod目录下会生成github.com/tinylib/msgp目录。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go install github.com/tinylib/msgp@latest</span><br></pre></td></tr></table></figure><p>以上命令会在$GOPATH/bin下生成msgp可执行文件。<br>go mod init module_name<br>初始化一个Go项目。<br>go mod tidy通过扫描当前项目中的所有代码来添加未被记录的依赖至go.mod文件或从go.mod文件中删除不再被使用的依赖。<br>go run: 编译并运行程序。<br>go test: 执行测试代码。<br>go tool: 执行go自带的工具。go tool pprof对cpu、内存和协程进行监控；go tool trace跟踪协程的执行过程。<br>go vet: 检查代码中的静态错误。<br>go fmt: 对代码文件进行格式化，如果用了IDE这个命令就不需要了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go fmt entrance_class/demo.go</span><br></pre></td></tr></table></figure><p>go doc: 查看go标准库或第三方库的帮助文档。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go doc fmt</span><br><span class="line">go doc gonum.org/v1/gonum/stat</span><br></pre></td></tr></table></figure><p>go version: 查看go版本号。<br>go env: 查看go环境信息。   </p>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Golang基础]</title>
    <link href="http://yoursite.com/2021/04/01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2021/04/01/Go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/</id>
    <published>2021-04-01T12:29:20.000Z</published>
    <updated>2021-04-01T13:11:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://rogerxs80.github.io/2021/04/21/%E5%88%9D%E8%AF%86Go%E8%AF%AD%E8%A8%80/" target="_blank" rel="noopener">1.初识Go语言</a></p><p><a href="https://rogerxs80.github.io/2021/04/21/Go%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">2.Go基础语法</a></p><p><a href="https://rogerxs80.github.io/2021/04/21/Go%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">3.Go数据类型</a></p><p><a href="https://rogerxs80.github.io/2021/04/21/Go%E7%BB%93%E6%9E%84%E4%BD%93/" target="_blank" rel="noopener">4.Go结构体</a></p><p><a href="https://rogerxs80.github.io/2021/04/22/Go%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/" target="_blank" rel="noopener">5.Go流程控制语句</a></p><p><a href="https://rogerxs80.github.io/2021/04/23/Go%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">6.Go函数</a></p>]]></content>
    
    <summary type="html">
    
      2007年，Google的几位大牛正在用C++开发一些比较繁琐但是核心的工作，主要是分布式集群，大牛觉得很闹心。此时C++委员会来他们公司做技术演讲，说C++将要添加35个新特性，大牛心里飘过一万个CNM，“C++特性还不够多吗”。于是Rob Pike说要不自己搞个简单一点的语言...
    
    </summary>
    
    
      <category term="Golang" scheme="http://yoursite.com/categories/Golang/"/>
    
    
      <category term="Golang基础" scheme="http://yoursite.com/tags/Golang%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>[Django Rest Framework]</title>
    <link href="http://yoursite.com/2021/03/01/Django%20Rest%20Framework%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2021/03/01/Django%20Rest%20Framework%E6%A1%86%E6%9E%B6/</id>
    <published>2021-03-01T14:16:13.000Z</published>
    <updated>2021-03-01T13:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DRF框架"><a href="#DRF框架" class="headerlink" title="DRF框架"></a>DRF框架</h1><p>Django Rest Framework 是一个强大且灵活的工具包，用以构建Web API</p><p>为什么要使用Rest Framework</p><p>Django REST Framework可以在Django的基础上迅速实现API，并且自身还带有WEB的测试页面，可以方便的测试自己的API</p><p><a href="https://rogerxs80.github.io/2020/04/22/API%E8%A7%84%E8%8C%83%E4%B8%8Edrf%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">1.restful API规范与DRF安装</a></p><p><a href="https://rogerxs80.github.io/2020/04/22/%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8-Serializer/" target="_blank" rel="noopener">2.序列化器-Serializer</a></p><p><a href="https://rogerxs80.github.io/2020/04/22/http%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">3.HTTP请求处理</a></p><p><a href="https://rogerxs80.github.io/2020/04/22/%E8%A7%86%E5%9B%BEView%E4%B8%8E%E8%B7%AF%E7%94%B1Router/" target="_blank" rel="noopener">4.视图View与路由Router</a></p><p><a href="https://rogerxs80.github.io/2020/04/22/DRF%E6%A1%86%E6%9E%B6%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BB%84%E4%BB%B6/" target="_blank" rel="noopener">5.DRF框架中常用的组件</a></p><p><a href="https://www.notion.so/xadmin-2047b48498d2461e9f91191fe07a8738" target="_blank" rel="noopener">6.xadmin</a></p>]]></content>
    
    <summary type="html">
    
      Django 是用Python开发的一个免费开源的Web框架，可以用于快速搭建高性能，优雅的网站！采用了MVC的框架模式，即模型M，视图V和控制器C，也可以称为MVT模式，模型M，视图V，模板T...
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="Django Rest_Framework" scheme="http://yoursite.com/tags/Django-Rest-Framework/"/>
    
  </entry>
  
  <entry>
    <title>[Redis系列]</title>
    <link href="http://yoursite.com/2020/11/01/Redis%E7%B3%BB%E5%88%97/"/>
    <id>http://yoursite.com/2020/11/01/Redis%E7%B3%BB%E5%88%97/</id>
    <published>2020-10-31T23:23:33.000Z</published>
    <updated>2020-10-31T23:24:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis系列"><a href="#Redis系列" class="headerlink" title="Redis系列"></a>Redis系列</h2><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API…</p><p><a href="https://rogerxs80.github.io/2020/06/21/Redis%E5%88%9D%E8%AF%86/" target="_blank" rel="noopener">1.Redis介绍安装配置</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/API%E7%9A%84%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">2.API的使用</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">3.客户端使用</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95/" target="_blank" rel="noopener">4.高级用法</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E6%8C%81%E4%B9%85%E5%8C%96/" target="_blank" rel="noopener">5.持久化</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">6.使用常见问题</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">7.主从复制原理与优化</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/Sentinel/" target="_blank" rel="noopener">8.Sentinel</a></p><p><a href="https://rogerxs80.github.io/2020/06/21/%E7%BC%93%E5%AD%98%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">9.缓存的使用和优化</a></p>]]></content>
    
    <summary type="html">
    
      Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>[MySOL数据库]</title>
    <link href="http://yoursite.com/2020/10/01/MySOL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/2020/10/01/MySOL%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2020-10-01T04:13:25.000Z</published>
    <updated>2020-10-01T07:34:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><p>MySQL是一种开放源代码的关系型数据库管理系统（RDBMS），使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。 MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对其进行修改。 MySQL因为其速度、可靠性和适应性而备受关注。</p><p><a href="https://rogerxs80.github.io/2020/03/09/%E5%88%9D%E8%AF%86%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Emysql%E5%AE%89%E8%A3%85/" target="_blank" rel="noopener">1.mysql安装</a></p><p><a href="https://rogerxs80.github.io/2020/03/09/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">2.存储引擎与数据类型</a></p><p><a href="https://rogerxs80.github.io/2020/03/10/%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6%E4%B8%8E%E8%A1%A8%E5%85%B3%E7%B3%BB/" target="_blank" rel="noopener">3.约束条件与表关系</a></p><p><a href="https://rogerxs80.github.io/2020/03/11/%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0/" target="_blank" rel="noopener">4.聚合函数</a></p><p><a href="https://rogerxs80.github.io/2020/03/12/navicat%E5%AE%89%E8%A3%85%E4%B8%8Epymysql%E6%A8%A1%E5%9D%97/" target="_blank" rel="noopener">5.navicat安装与pymysql模块</a></p><p><a href="https://rogerxs80.github.io/2020/03/13/%E4%BA%8B%E5%8A%A1%E4%B8%8E%E5%85%B6%E4%BB%96%E4%BB%8B%E7%BB%8D/" target="_blank" rel="noopener">6.事务与开发模型</a></p>]]></content>
    
    <summary type="html">
    
      ySQL是一种开放源代码的关系型数据库管理系统（RDBMS），使用最常用的数据库管理语言--结构化查询语言（SQL）进行数据库管理。 MySQL是开放源代码的，因此任何人都可以在General Public License的许可下下载并根据个性化的需要对...
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>[前端开发]</title>
    <link href="http://yoursite.com/2020/05/01/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2020/05/01/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/</id>
    <published>2020-05-01T03:15:10.000Z</published>
    <updated>2020-05-01T05:20:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端开发"><a href="#前端开发" class="headerlink" title="前端开发"></a>前端开发</h1><p>前端开发是创建Web页面或app等前端界面呈现给用户的过程，通过HTML，CSS及JavaScript以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的用户界面交互 。它从网页制作演变而来，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0时代的产物，早期网站主要内容都是静态，以图片和文字为主，用户使用网站的行为也以浏览为主。随着互联网技术的发展和HTML5、CSS3的应用，现代网页更加美观，交互效果显著，功能更加强大。</p><p><a href="https://rogerxs80.github.io/2019/07/12/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E6%A0%87%E7%AD%BE%E4%BD%BF%E7%94%A8/" target="_blank" rel="noopener">1.前端入门与标签使用</a></p><p><a href="https://rogerxs80.github.io/2019/07/12/CSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%B8%8E%E5%B1%9E%E6%80%A7/" target="_blank" rel="noopener">2.CSS选择器与属性</a></p><p><a href="https://rogerxs80.github.io/2019/07/12/JavaScript%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">3.JavaScript入门</a></p><p><a href="https://rogerxs80.github.io/2019/07/12/JQuery%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">4.JQury入门</a></p><p><a href="https://rogerxs80.github.io/2019/07/13/Bootstrap%E6%A1%86%E6%9E%B6/" target="_blank" rel="noopener">5.BootStrap框架</a></p>]]></content>
    
    <summary type="html">
    
      前端开发是创建Web页面或app等前端界面呈现给用户的过程，通过HTML，CSS及JavaScript以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的...
    
    </summary>
    
    
      <category term="前端开发" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="前端入门" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>[Vue客户端项目搭建]</title>
    <link href="http://yoursite.com/2020/02/27/Vue%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/02/27/Vue%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA/</id>
    <published>2020-02-27T03:00:16.000Z</published>
    <updated>2020-02-28T14:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="客户端项目搭建"><a href="#客户端项目搭建" class="headerlink" title="客户端项目搭建"></a>客户端项目搭建</h1><h2 id="创建项目目录"><a href="#创建项目目录" class="headerlink" title="创建项目目录"></a>创建项目目录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 项目目录[荏苒资讯]</span><br><span class="line">vue init webpack renran</span><br></pre></td></tr></table></figure><p>例如，我要把项目保存在桌面下的子目录renran ~/Desktop/renran，可以如下操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop/renran</span><br><span class="line">vue init webpack renran_pc</span><br></pre></td></tr></table></figure><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1581901045861.png" alt="1581901045861"></p><p>打开项目已经，在pycharm的终端下运行vue项目，查看效果。</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1581901177538.png" alt="1581901177538"></p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1581901225429.png" alt="1581901225429"></p><p>上面的操作步骤，等同于执行了下面这句命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>接下来，我们根据终端上效果显示的对应地址来访问项目(如果有多个vue项目在运行，8080端口被占据了，服务器会自动改端口，所以根据自己实际在操作中看到的地址来访问。)</p><p>访问：<a href="http://localost:8080" target="_blank" rel="noopener">http://localost:8080</a></p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1581901294089.png" alt="1581901294089"></p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><p>清除默认的HelloWorld.vue组件和APP.vue中的默认模板代码和默认css样式</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1581901419680.png" alt="1581901419680"></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line"></span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>接下来，我们可以查看效果了，一张白纸~</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1556414476287.png" alt="1556414476287"></p><h2 id="安装路由vue-router"><a href="#安装路由vue-router" class="headerlink" title="安装路由vue-router"></a>安装路由vue-router</h2><p>官方文档：<a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">https://router.vuejs.org/zh/</a></p><h3 id="下载安装路由组件"><a href="#下载安装路由组件" class="headerlink" title="下载安装路由组件"></a>下载安装路由组件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue-router -S<span class="comment"># npm install vue-router --save</span></span><br></pre></td></tr></table></figure><h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><h4 id="初始化路由对象"><a href="#初始化路由对象" class="headerlink" title="初始化路由对象"></a>初始化路由对象</h4><p>在src目录下创建routes路由目录，在router目录下创建index.js路由文件</p><p>index.js路由文件中，编写初始化路由对象的代码 .</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">1.</span> 引入vue和vue-router组件核心对象，并在vue中通过use注册vue-router组件</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">// <span class="number">2.</span> 暴露vue-router对象，并在vue-router里面编写路由，提供给main.js调用</span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  // 设置路由模式为‘history’，去掉默认的<span class="comment">#</span></span><br><span class="line">  mode: <span class="string">"history"</span>,</span><br><span class="line">  routes:[</span><br><span class="line">    // 路由列表</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="注册路由信息"><a href="#注册路由信息" class="headerlink" title="注册路由信息"></a>注册路由信息</h4><p>打开main.js文件，把router路由规则对象注册到vue中，代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// The Vue build version to load <span class="keyword">with</span> the `<span class="keyword">import</span>` command</span><br><span class="line">// (runtime-only <span class="keyword">or</span> standalone) has been set <span class="keyword">in</span> webpack.base.conf <span class="keyword">with</span> an alias.</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router/index'</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="在视图中显示路由对应的内容"><a href="#在视图中显示路由对应的内容" class="headerlink" title="在视图中显示路由对应的内容"></a>在视图中显示路由对应的内容</h4><p>在App.vue组件中，添加显示路由对应的内容。代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签名必须是这个rouer-view --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'App'</span>,</span></span><br><span class="line">  components: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：如果在vue创建项目的时候，设置安装vue-router，则项目会自动帮我们生成上面的router目录和index.js里面的代码，以及自动到main.js里面注册路由对象。</p><h3 id="路由对象提供的操作"><a href="#路由对象提供的操作" class="headerlink" title="路由对象提供的操作"></a>路由对象提供的操作</h3><p>在我们安装注册了vue-router组件以后，vue-router在vue项目中会帮我们在全局范围内所有组件里面创建2个对象给我们使用：</p><ol><li><code>this.$router</code>，可用于在js代码中进行页面跳转。</li><li><code>this.$route</code>，可用于获取地址栏上面的url参数。</li></ol><h4 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h4><p>在vue-router提供的操作中， 进行页面跳转有2种方式：</p><ol><li><p>使用<code>&lt;router-link to=&quot;url地址&quot;&gt;</code>来跳转</p></li><li><p>在<code>&lt;script&gt;</code>中使用<code>this.$router.push(url地址)</code>来跳转</p><p>在<code>&lt;script&gt;</code>中还可以使用<code>this.$router.go(整数)</code>，表示跳转返回上一页或者上几页，下一个或者下几页</p></li></ol><h5 id="router-link标签"><a href="#router-link标签" class="headerlink" title="router-link标签"></a>router-link标签</h5><p>例如，我们就可以在Home.vue组件中，使用router-link跳转到User.vue组件中。</p><p>routes/index.js，代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">1.</span> 引入vue和vue-router组件核心对象，并在vue中通过use注册vue-router组件</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router); // Router是类</span><br><span class="line">// <span class="number">2.</span> 暴露vue-router对象，并在vue-router里面编写路由，提供给main.js调用</span><br><span class="line"></span><br><span class="line">// 导入组件</span><br><span class="line">// <span class="keyword">import</span> 组件名 <span class="keyword">from</span> <span class="string">"../components/组件名"</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"../components/Home"</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">"../components/User"</span>;</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  mode:<span class="string">"history"</span>,  // 路由地址的显示模式： 默认hash，表示地址栏上面出现<span class="comment">#</span></span><br><span class="line">  routes:[</span><br><span class="line">    // &#123;</span><br><span class="line">    //   name:<span class="string">"路由名称[对应组件的name值，将来用于跳转页面]"</span>,</span><br><span class="line">    //   path: <span class="string">"访问url路径"</span>,</span><br><span class="line">    //   component: 组件名</span><br><span class="line">    // &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name:<span class="string">"Home"</span>,</span><br><span class="line">      path: <span class="string">"/"</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      name:<span class="string">"User"</span>,</span><br><span class="line">      path: <span class="string">"/user"</span>,</span><br><span class="line">      component: User</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// vue-router除了可以进行组件和url地址的绑定以外，还可以</span><br><span class="line">// 进行不同组件的页面跳转，</span><br></pre></td></tr></table></figure><p>Home.vue代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      首页页面组件</span><br><span class="line">      &lt;a href=<span class="string">"/user"</span>&gt;个人中心&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">      &lt;!-- router-link标签，本质上就是a标签，只是由vue-router进行加工处理</span></span><br><span class="line"><span class="regexp">      可以显示局部页面刷新，不会重新加载内容，进行ajax跳转</span></span><br><span class="line"><span class="regexp">       --&gt;</span></span><br><span class="line"><span class="regexp">      &lt;router-link to="/u</span>ser<span class="string">"&gt;个人中心&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">      &lt;router-link :to="</span>url<span class="string">"&gt;个人中心&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">      &lt;router-link :to="</span>&#123;<span class="attr">name</span>:<span class="string">'User'</span>&#125;<span class="string">"&gt;个人中心&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    export default &#123;</span></span><br><span class="line"><span class="string">        name: "</span>Home<span class="string">",</span></span><br><span class="line"><span class="string">        data()&#123;</span></span><br><span class="line"><span class="string">          return &#123;</span></span><br><span class="line"><span class="string">              url: "</span>/user<span class="string">",</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        methods:&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1581908101280.png" alt="1581908101280"></p><h5 id="this-router-push-跳转"><a href="#this-router-push-跳转" class="headerlink" title="this.$router.push()跳转"></a><code>this.$router.push()</code>跳转</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      首页页面组件</span><br><span class="line">      &lt;a href=<span class="string">"/user"</span>&gt;个人中心&lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">      &lt;!-- router-link标签，本质上就是a标签，只是由vue-router进行加工处理</span></span><br><span class="line"><span class="regexp">      可以显示局部页面刷新，不会重新加载内容，进行ajax跳转</span></span><br><span class="line"><span class="regexp">       --&gt;</span></span><br><span class="line"><span class="regexp">      &lt;router-link to="/u</span>ser<span class="string">"&gt;个人中心&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">      &lt;router-link :to="</span>url<span class="string">"&gt;个人中心&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">      &lt;router-link :to="</span>&#123;<span class="attr">name</span>:<span class="string">'User'</span>&#125;<span class="string">"&gt;个人中心&lt;/router-link&gt;</span></span><br><span class="line"><span class="string">      &lt;button @click="</span>jump<span class="string">"&gt;个人中心&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    export default &#123;</span></span><br><span class="line"><span class="string">        name: "</span>Home<span class="string">",</span></span><br><span class="line"><span class="string">        data()&#123;</span></span><br><span class="line"><span class="string">          return &#123;</span></span><br><span class="line"><span class="string">              url: "</span>/user<span class="string">",</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        methods:&#123;</span></span><br><span class="line"><span class="string">          jump()&#123;</span></span><br><span class="line"><span class="string">              // 开发中可以先进行权限，登录之类的判断，然后再进行跳转</span></span><br><span class="line"><span class="string">                // this.$router.back(); // 返回上一页，本质上就是 location.back()</span></span><br><span class="line"><span class="string">                // this.$router.go(-1); // 返回上一页，本质上就是 location.go()</span></span><br><span class="line"><span class="string">                // this.$router.forward(); // 跳转到下一页，本质上就是 location.forward()</span></span><br><span class="line"><span class="string">                this.$router.push("</span>/user<span class="string">"); // 跳转到站内的制定地址页面中，本质上就是 location.href</span></span><br><span class="line"><span class="string">                // 注意,this.$router.push() 不能跳转到其他网站。如果真的要跳转外站，则使用location.href="</span>站外地址，记得加上http:<span class="comment">//协议"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><h4 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h4><p><code>vue-router</code>提供了<code>this.$route</code>，可以让我们接收来自其他页面的附带参数。参数有2种：</p><ol><li><p>查询字符串(<code>query string</code>)，就是地址栏上面<code>?</code>号后面的参数，</p><p>例如：<code>http://localhost:8008/user?name=xiaoming&amp;pwd=123</code>，这里<code>name=xiaoming&amp;pwd=123</code>就是查询字符串参数。</p></li><li><p>路由参数(<code>router params</code>)，就是地址栏上面路由路径的一部分，</p><p>例如：<code>http://localhost:8080/user/300/xiaoming</code>，此时，300属于路由路径的一部分，这个300就是路由参数.，当然，xiaoming,或者user也可以理解是路由参数，就是看我们的页面中是否需要接收而已。</p></li></ol><h5 id="获取查询字符串"><a href="#获取查询字符串" class="headerlink" title="获取查询字符串"></a>获取查询字符串</h5><p>必须先有一个页面跳转发送参数。例如，在Home组件中跳转到User组件中，需要传递name和pwd查询字符串。</p><p>Home.vue代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      首页页面组件</span><br><span class="line">&lt;!--      <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/user"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">      &amp;lt;!&amp;ndash; router-link标签，本质上就是a标签，只是由vue-router进行加工处理</span><br><span class="line">      可以显示局部页面刷新，不会重新加载内容，进行ajax跳转</span><br><span class="line">       &amp;ndash;&amp;gt;</span><br><span class="line">      &lt;router-link to=<span class="string">"/user"</span>&gt;个人中心&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;router-link :to="url"&gt;个人中心&lt;/</span>router-link&gt;</span><br><span class="line">      &lt;router-link :to=<span class="string">"&#123;name:'User'&#125;"</span>&gt;个人中心&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button @click="jump"&gt;个人中心&lt;/</span>button&gt;--&gt;</span><br><span class="line"></span><br><span class="line">      &lt;router-link :to=<span class="string">"`/user?name=$&#123;name&#125;&amp;pwd=$&#123;pwd&#125;`"</span>&gt;查询字符串参数&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;router-link :to="'/u</span>ser?name=<span class="string">'+name+'</span>&amp;pwd=<span class="string">'+pwd"&gt;查询字符串参数&lt;/router-link&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">    export default &#123;</span></span><br><span class="line"><span class="string">        name: "Home",</span></span><br><span class="line"><span class="string">        data()&#123;</span></span><br><span class="line"><span class="string">          return &#123;</span></span><br><span class="line"><span class="string">              name: "xiaoming",</span></span><br><span class="line"><span class="string">              pwd: "123",</span></span><br><span class="line"><span class="string">              url: "/user",</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        methods:&#123;</span></span><br><span class="line"><span class="string">          jump()&#123;</span></span><br><span class="line"><span class="string">              // 开发中可以先进行权限，登录之类的判断，然后再进行跳转</span></span><br><span class="line"><span class="string">                // this.$router.back(); // 返回上一页，本质上就是 location.back()</span></span><br><span class="line"><span class="string">                // this.$router.go(-1); // 返回上一页，本质上就是 location.go()</span></span><br><span class="line"><span class="string">                // this.$router.forward(); // 跳转到下一页，本质上就是 location.forward()</span></span><br><span class="line"><span class="string">                this.$router.push("/user"); // 跳转到站内的制定地址页面中，本质上就是 location.href</span></span><br><span class="line"><span class="string">                // 注意,this.$router.push 不能跳转到其他网站。如果真的要跳转外站，则使用location.href="站外地址，记得加上http://协议"</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;style scoped&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br></pre></td></tr></table></figure><p>可以下一个页面中，这里代表的就是User组件，接收来自Home组件的参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      用户中心页面组件</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"User"</span>,</span><br><span class="line">        created() &#123;</span><br><span class="line">            <span class="comment">// 接收地址栏上面的参数</span></span><br><span class="line">            <span class="comment">// this.$route是vue-router提供的一个用于接收地址参数的对象。</span></span><br><span class="line">            <span class="comment">// 经过main.js里面注册router对象以后，</span></span><br><span class="line">            <span class="comment">// 将来在所有的子组件中，可以通过this.$route来获取参数或者通过this.$router跳转页面</span></span><br><span class="line">            <span class="comment">// 查询字符串参数</span></span><br><span class="line">            <span class="comment">// query是this.$route里面的一个数组，this.$route会自动收集地址栏上所有的参数保存到query里面</span></span><br><span class="line">            <span class="comment">// let name = this.$route.query.name;</span></span><br><span class="line">            <span class="comment">// let pwd = this.$route.query.pwd;</span></span><br><span class="line">            <span class="comment">// console.log(`name=$&#123;name&#125;&amp;pwd=$&#123;pwd&#125;`);  // ``里面，$&#123;&#125;圈住的内容会被js当成变量来解析</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><h4 id="获取路由参数"><a href="#获取路由参数" class="headerlink" title="获取路由参数"></a>获取路由参数</h4><p>例如：我们用户的界面都是一样的，但是每一个用户来到自己的页面中，显示的内容肯定都是不一样的，此时，我们需要使用不同的路径来区分不同的用户。这时候，可以在路由路径中使用路由参数表示不同用户的id</p><p>例如：我们就需要设置一个route/index.js中路由信息里面，哪一段路由属于路由参数。</p><p>src/routes/index.js设置路由参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// <span class="number">1.</span> 引入vue和vue-router组件核心对象，并在vue中通过use注册vue-router组件</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router); // Router是类</span><br><span class="line">// <span class="number">2.</span> 暴露vue-router对象，并在vue-router里面编写路由，提供给main.js调用</span><br><span class="line"></span><br><span class="line">// 导入组件</span><br><span class="line">// <span class="keyword">import</span> 组件名 <span class="keyword">from</span> <span class="string">"../components/组件名"</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"../components/Home"</span>;</span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">"../components/User"</span>;</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  mode:<span class="string">"history"</span>,  // 路由地址的显示模式： 默认hash，表示地址栏上面出现<span class="comment">#</span></span><br><span class="line">  routes:[</span><br><span class="line">    // &#123;</span><br><span class="line">    //   name:<span class="string">"路由名称[对应组件的name值，将来用于跳转页面]"</span>,</span><br><span class="line">    //   path: <span class="string">"访问url路径"</span>,</span><br><span class="line">    //   component: 组件名</span><br><span class="line">    // &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      name:<span class="string">"Home"</span>,</span><br><span class="line">      path: <span class="string">"/"</span>,</span><br><span class="line">      component: Home</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      name:<span class="string">"User"</span>,</span><br><span class="line">      path: <span class="string">"/user/:id/img-:img_id"</span>,</span><br><span class="line">      component: User</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// vue-router除了可以进行组件和url地址的绑定以外，还可以</span><br><span class="line">// 进行不同组件的页面跳转，</span><br></pre></td></tr></table></figure><p>然后我们就是在Home中如果需要转到User里面。</p><p>Home.vue代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      首页页面组件</span><br><span class="line">&lt;!--      <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/user"</span>&gt;</span>个人中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">      &amp;lt;!&amp;ndash; router-link标签，本质上就是a标签，只是由vue-router进行加工处理</span><br><span class="line">      可以显示局部页面刷新，不会重新加载内容，进行ajax跳转</span><br><span class="line">       &amp;ndash;&amp;gt;</span><br><span class="line">      &lt;router-link to=<span class="string">"/user"</span>&gt;个人中心&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;router-link :to="url"&gt;个人中心&lt;/</span>router-link&gt;</span><br><span class="line">      &lt;router-link :to=<span class="string">"&#123;name:'User'&#125;"</span>&gt;个人中心&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button @click="jump"&gt;个人中心&lt;/</span>button&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--      <span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"`/user?name=$&#123;name&#125;&amp;pwd=$&#123;pwd&#125;`"</span>&gt;</span>查询字符串参数<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span>--&gt;</span><br><span class="line">&lt;!--      <span class="xml"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">"'/user?name='+name+'&amp;pwd='+pwd"</span>&gt;</span>查询字符串参数<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span>--&gt;</span><br><span class="line">      &lt;router-link to=<span class="string">"/user/100/img-10086"</span>&gt;路由参数&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">    export default &#123;</span></span><br><span class="line"><span class="regexp">        name: "Home",</span></span><br><span class="line"><span class="regexp">        data()&#123;</span></span><br><span class="line"><span class="regexp">          return &#123;</span></span><br><span class="line"><span class="regexp">              name: "xiaoming",</span></span><br><span class="line"><span class="regexp">              pwd: "123",</span></span><br><span class="line"><span class="regexp">              url: "/u</span>ser<span class="string">",</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;,</span></span><br><span class="line"><span class="string">        methods:&#123;</span></span><br><span class="line"><span class="string">          jump()&#123;</span></span><br><span class="line"><span class="string">              // 开发中可以先进行权限，登录之类的判断，然后再进行跳转</span></span><br><span class="line"><span class="string">                // this.$router.back(); // 返回上一页，本质上就是 location.back()</span></span><br><span class="line"><span class="string">                // this.$router.go(-1); // 返回上一页，本质上就是 location.go()</span></span><br><span class="line"><span class="string">                // this.$router.forward(); // 跳转到下一页，本质上就是 location.forward()</span></span><br><span class="line"><span class="string">                this.$router.push("</span>/user<span class="string">"); // 跳转到站内的制定地址页面中，本质上就是 location.href</span></span><br><span class="line"><span class="string">                // 注意,this.$router.push 不能跳转到其他网站。如果真的要跳转外站，则使用location.href="</span>站外地址，记得加上http:<span class="comment">//协议"</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>User.vue，组件中可以通过<code>this.$route.params</code>接收路由参数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      用户中心页面组件</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"User"</span>,</span><br><span class="line">        created() &#123;</span><br><span class="line">            <span class="comment">// 接收地址栏上面的参数</span></span><br><span class="line">            <span class="comment">// this.$route是vue-router提供的一个用于接收地址参数的对象。</span></span><br><span class="line">            <span class="comment">// 经过main.js里面注册router对象以后，</span></span><br><span class="line">            <span class="comment">// 将来在所有的子组件中，可以通过this.$route来获取参数或者通过this.$router跳转页面</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询字符串参数</span></span><br><span class="line">            <span class="comment">// query是this.$route里面的一个数组，this.$route会自动收集地址栏上所有的参数保存到query里面</span></span><br><span class="line">            <span class="comment">// let name = this.$route.query.name;</span></span><br><span class="line">            <span class="comment">// let pwd = this.$route.query.pwd;</span></span><br><span class="line">            <span class="comment">// console.log(`name=$&#123;name&#125;&amp;pwd=$&#123;pwd&#125;`);  // ``里面，$&#123;&#125;圈住的内容会被js当成变量来解析</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 路由参数</span></span><br><span class="line">            <span class="comment">// params是this.$route里面的一个数组，this.$route会自动收集路由列表中已经标记为路由参数所有内容保存到params中</span></span><br><span class="line">            <span class="keyword">let</span> id = <span class="keyword">this</span>.$route.params.id;</span><br><span class="line">            <span class="built_in">console</span>.log(id);</span><br><span class="line">            <span class="keyword">let</span> img_id = <span class="keyword">this</span>.$route.params.img_id;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`img_id = <span class="subst">$&#123;img_id&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><h1 id="ElementUI"><a href="#ElementUI" class="headerlink" title="ElementUI"></a>ElementUI</h1><p>对于前端页面布局，我们可以使用一些开源的UI框架来配合开发，常用的UI框: bootstap，H-ui框架，lay-UI框架，Amaze UI，zui框架，ElementUI.</p><p>Vue开发前端项目中，比较常用的就是ElementUI了。</p><p>ElementUI是饿了么团队开发的一个UI组件框架，这个框架提前帮我们提供了很多已经写好的通用模块，我们可以在Vue项目中引入来使用，这个框架的使用类似于我们前面学习的bootstrap框架，也就是说，我们完全可以把官方文档中的组件代码拿来就用，有定制性的内容，可以直接通过样式进行覆盖修改就可以了。</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552501300174.png" alt="1552501300174"></p><p>中文官网：<a href="http://element-cn.eleme.io/#/zh-CN" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN</a></p><p>文档快速入门：<a href="http://element-cn.eleme.io/#/zh-CN/component/quickstart" target="_blank" rel="noopener">http://element-cn.eleme.io/#/zh-CN/component/quickstart</a></p><h2 id="快速安装ElementUI"><a href="#快速安装ElementUI" class="headerlink" title="快速安装ElementUI"></a>快速安装ElementUI</h2><p>项目根目录执行以下命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure><p>上面的命令等同于 <code>npm install element-ui --save</code></p><p>执行命令效果：</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1556417812874.png" alt="1556417812874"></p><h2 id="配置ElementUI到项目中"><a href="#配置ElementUI到项目中" class="headerlink" title="配置ElementUI到项目中"></a>配置ElementUI到项目中</h2><p>在main.js中导入ElementUI，并调用。代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// elementUI 导入</span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'element-ui/lib/theme-chalk/index.css'</span>;</span><br><span class="line">// 调用插件</span><br><span class="line">Vue.use(ElementUI);</span><br></pre></td></tr></table></figure><p>成功引入了ElementUI以后，接下来我们就可以开始进入前端页面开发，首先是首页。</p><h1 id="首页"><a href="#首页" class="headerlink" title="首页"></a>首页</h1><p>首页采用了上下页面布局，首页是导航栏、轮播图。。。脚部等几个小模块。所以我们可以把首页作为一个组件进行开发，然后把首页的这些小模块作为单独的组件来进行开发。</p><h2 id="创建首页组件"><a href="#创建首页组件" class="headerlink" title="创建首页组件"></a>创建首页组件</h2><p>在src/components目录下创建文件 Home.vue</p><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"home"</span>&gt;</span></span><br><span class="line">    首页</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name:<span class="string">"Home"</span>,</span></span><br><span class="line">  data()&#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建首页对应的路由"><a href="#创建首页对应的路由" class="headerlink" title="创建首页对应的路由"></a>创建首页对应的路由</h3><p>在router/index.js中引入Home组件，并设置Home组件作为首页路由。</p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"vue-router"</span></span><br><span class="line"></span><br><span class="line">// 后面这里引入可以被用户访问的页面组件</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">"../components/Home"</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  // 路由跳转模式，注意使用 history</span><br><span class="line">  mode: <span class="string">"history"</span>,</span><br><span class="line"></span><br><span class="line">  // 路由规则</span><br><span class="line">  routes:[</span><br><span class="line">    &#123;</span><br><span class="line">      // name:<span class="string">"路由别名"</span>,</span><br><span class="line">      name:<span class="string">"Home"</span>,</span><br><span class="line">      // path: <span class="string">"路由地址"</span>,</span><br><span class="line">      path: <span class="string">"/"</span>,</span><br><span class="line">      // component: 组件类名,</span><br><span class="line">      component: Home,</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      下载安装路由组件,在src目录下创建routes路由目录，在router目录下创建index.js路由文件,index.js路由文件中，编写初始化路由对象的代码...
    
    </summary>
    
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="vue框架" scheme="http://yoursite.com/tags/vue%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>[Vue自动化工具（Vue-cli）]</title>
    <link href="http://yoursite.com/2020/02/26/Vue%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%88Vue-cli%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/26/Vue%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7%EF%BC%88Vue-cli%EF%BC%89/</id>
    <published>2020-02-26T02:00:16.000Z</published>
    <updated>2020-02-27T12:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue自动化工具（Vue-cli）"><a href="#Vue自动化工具（Vue-cli）" class="headerlink" title="Vue自动化工具（Vue-cli）"></a>Vue自动化工具（Vue-cli）</h1><p>前面学习了普通组件以后，接下来我们继续学习单文件组件则需要提前先安装准备一些组件开发工具。否则无法使用和学习单文件组件。</p><p>一般情况下，单文件组件，我们运行在 自动化工具vue-CLI中，可以帮我们把单文件组件编译成普通的js代码。所以我们需要在电脑先安装搭建vue-CLI工具。</p><p>官网：<a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">https://cli.vuejs.org/zh/</a></p><p>Vue CLI 需要 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a> 或 <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">nvm-windows</a>在同一台电脑中管理多个 Node 版本。</p><p>nvm工具的下载和安装： </p><p><a href="https://www.jianshu.com/p/d0e0935b150a" target="_blank" rel="noopener">https://www.jianshu.com/p/d0e0935b150a</a></p><p> <a href="https://www.jianshu.com/p/622ad36ee020" target="_blank" rel="noopener">https://www.jianshu.com/p/622ad36ee020</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://github.com/nvm-sh/nvm/v0.35.3/install.sh | bash</span><br></pre></td></tr></table></figure><p>安装记录:</p><p>打开:<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p><p>安装完成以后,先查看环境变量是否设置好了.</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552357036022.png" alt="1552357036022"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用的nvm命令</span><br><span class="line"></span><br><span class="line">nvm list   <span class="comment"># 列出目前在nvm里面安装的所有node版本</span></span><br><span class="line">nvm install node版本号      <span class="comment"># 安装指定版本的node.js</span></span><br><span class="line">nvm uninstall node版本号    <span class="comment"># 卸载指定版本的node.js</span></span><br><span class="line">nvm use node版本号          <span class="comment"># 切换当前使用的node.js版本</span></span><br></pre></td></tr></table></figure><p>如果使用nvm工具，则直接可以不用自己手动下载，如果使用nvm下载安装 node的npm比较慢的时候，可以修改nvm的配置文件(在安装根目录下)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># settings.txt</span><br><span class="line">root: C:\tool\nvm    [这里的目录地址是安装nvm时自己设置的地址,要根据实际修改]</span><br><span class="line">path: C:\tool\nodejs</span><br><span class="line">arch: 64</span><br><span class="line">proxy: none</span><br><span class="line">node_mirror: http:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F; </span><br><span class="line">npm_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F;</span><br></pre></td></tr></table></figure><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>Node.js是一个新的后端(后台)语言，它的语法和JavaScript类似，所以可以说它是属于前端的后端语言，后端语言和前端语言的区别：</p><ul><li>运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上</li><li>功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。</li></ul><p>我们一般安装LTS(长线支持版本 Long-Time Support)：</p><p>下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a>【上面已经安装了nvm，那么这里不用手动安装了】</p><p>node.js的版本有两大分支：</p><p>官方发布的node.js版本：0.xx.xx 这种版本号就是官方发布的版本</p><p>社区发布的node.js版本：xx.xx.x 就是社区开发的版本</p><p>Node.js如果安装成功，可以查看Node.js的版本,在终端输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在安装node.js完成后，在node.js中会同时帮我们安装一个npm包管理器npm。我们可以借助npm命令来安装node.js的包。这个工具相当于python的pip管理器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install -g 包名              <span class="comment"># 安装模块   -g表示全局安装，如果没有-g，则表示在当前项目安装</span></span><br><span class="line">npm list                        <span class="comment"># 查看当前目录下已安装的node包</span></span><br><span class="line">npm view 包名 engines            <span class="comment"># 查看包所依赖的Node的版本 </span></span><br><span class="line">npm outdated                    <span class="comment"># 检查包是否已经过时，命令会列出所有已过时的包</span></span><br><span class="line">npm update 包名                  <span class="comment"># 更新node包</span></span><br><span class="line">npm uninstall 包名               <span class="comment"># 卸载node包</span></span><br><span class="line">npm 命令 -h                      <span class="comment"># 查看指定命令的帮助文档</span></span><br></pre></td></tr></table></figure><h2 id="安装Vue-cli"><a href="#安装Vue-cli" class="headerlink" title="安装Vue-cli"></a>安装Vue-cli</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure><p>如果安装速度过慢，一直超时，可以考虑切换npm镜像源：<a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a></p><h2 id="使用Vue-CLI初始化创建前端项目"><a href="#使用Vue-CLI初始化创建前端项目" class="headerlink" title="使用Vue-CLI初始化创建前端项目"></a>使用Vue-CLI初始化创建前端项目</h2><h3 id="生成项目目录"><a href="#生成项目目录" class="headerlink" title="生成项目目录"></a>生成项目目录</h3><p>使用vue-cli自动化工具可以快速搭建单页应用项目目录。</p><p>该工具为现代化的前端开发工作流提供了开箱即用的构建配置。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个基于 webpack 模板的新项目</span><br><span class="line">vue init webpack 项目目录名</span><br><span class="line">例如：</span><br><span class="line">vue init webpack myproject</span><br><span class="line"></span><br><span class="line">// 启动开发服务器 ctrl+c 停止服务</span><br><span class="line"><span class="built_in">cd</span> myproject</span><br><span class="line">npm run dev           <span class="comment"># 运行这个命令就可以启动node提供的测试http服务器</span></span><br></pre></td></tr></table></figure><p>运行了上面代码以后,终端下会出现以下效果提示：</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552187745456.png" alt="1552187745456"></p><p>那么访问：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552187794989.png" alt="1552187794989"></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><p>src 主开发目录，要开发的单文件组件全部在这个目录下的components目录下</p><p>static 静态资源目录，所有的css，js，图片等资源文件放在这个文件夹</p><p>dist项目打包发布文件夹，最后要上线单文件项目文件都在这个文件夹中[后面打包项目,让项目中的vue组件经过编译变成js 代码以后,dist就出现了]</p><p>node_modules目录是node的依赖包目录</p><p>config是配置目录，</p><p>build是项目打包时依赖的目录</p><p>src/router 路由,后面需要我们在使用Router路由的时候,自己声明.</p><h3 id="vue项目执行流程图"><a href="#vue项目执行流程图" class="headerlink" title="vue项目执行流程图"></a>vue项目执行流程图</h3><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/page_structrue.png" alt="page_structrue"></p><p>page_structrue</p><p>整个项目是一个主文件index.html,index.html中会引入src文件夹中的main.js,main.js中会导入顶级单文件组件App.vue,App.vue中会通过组件嵌套或者路由来引用components文件夹中的其他单文件组件。</p><h2 id="单文件组件的使用"><a href="#单文件组件的使用" class="headerlink" title="单文件组件的使用"></a>单文件组件的使用</h2><p>组件有两种：普通组件、单文件组件</p><p>普通组件的缺点：</p><ol><li>html代码是作为js的字符串进行编写，所以组装和开发的时候不易理解，而且没有高亮效果。</li><li>普通组件用在小项目中非常合适，但是复杂的大项目中，如果把更多的组件放在html文件中，那么维护成本就会变得非常昂贵。</li><li>普通组件只是整合了js和html，但是css代码被剥离出去了。使用的时候的时候不好处理。</li></ol><p>将一个组件相关的html结构，css样式，以及交互的JavaScript代码从html文件中剥离出来，合成一个文件，这种文件就是单文件组件，相当于一个组件具有了结构、表现和行为的完整功能，方便组件之间随意组合以及组件的重用，这种文件的扩展名为“.vue”，比如：“Home.vue”。</p><ol><li>创建组件</li></ol><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552362045478.png" alt="1552362045478"></p><p>在组件中编辑三个标签，编写视图、vm对象和css样式代码。</p><h3 id="template-编写html代码的地方"><a href="#template-编写html代码的地方" class="headerlink" title="template 编写html代码的地方"></a>template 编写html代码的地方</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"Home"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">"num--"</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"1"</span> <span class="attr">v-model</span>=<span class="string">"num"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">"num++"</span> <span class="attr">class</span>=<span class="string">"add"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="script编写vue-js代码"><a href="#script编写vue-js代码" class="headerlink" title="script编写vue.js代码"></a>script编写vue.js代码</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"Home"</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        num:<span class="number">0</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="style编写当前组件的样式代码"><a href="#style编写当前组件的样式代码" class="headerlink" title="style编写当前组件的样式代码"></a>style编写当前组件的样式代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.sub</span>,<span class="selector-class">.add</span>&#123;</span></span><br><span class="line">    border: 1px solid red;</span><br><span class="line">    padding: 4px 7px;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="完成案例-点击加减数字"><a href="#完成案例-点击加减数字" class="headerlink" title="完成案例-点击加减数字"></a>完成案例-点击加减数字</h3><p>创建Homes.vue</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"add_num"</span>&gt;</span><br><span class="line">      &lt;span @click=<span class="string">"num++"</span>&gt;+&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input type="text" size="2" v-model="num"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span @click="num--"&gt;-&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    name:<span class="string">"AddNum"</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        num: <span class="number">0</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">   .add_num&#123;</span></span><br><span class="line"><span class="regexp">      font-size: 32px;</span></span><br><span class="line"><span class="regexp">   &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>在App.vue组件中调用上面的组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"Home"</span>&gt;</span><br><span class="line">    &lt;span @click=<span class="string">"num--"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"sub"</span>&gt;-&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="text" size="1" v-model="num"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span @click="num++" class="add"&gt;+&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"Home"</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        num:<span class="number">0</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">  .sub,.add&#123;</span></span><br><span class="line"><span class="regexp">    border: 1px solid red;</span></span><br><span class="line"><span class="regexp">    padding: 4px 7px;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>在开发vue项目之前，需要手动把 App.vue的HelloWorld组件代码以及默认的css样式，清楚。</p><p>上面的代码效果：</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552362182984.png" alt="1552362182984"></p><h3 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h3><p>有时候开发vue项目时,页面也可以算是一个大组件,同时页面也可以分成多个子组件.</p><p>因为,产生了父组件调用子组件的情况.</p><p>例如,我们可以声明一个组件,作为父组件</p><p>在components/创建一个保存子组件的目录HomeSon</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552363669256.png" alt="1552363669256"></p><p>在HomeSon目录下,可以创建当前页面的子组件,例如,是Menu.vue</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  组件中代码必须写在同一个标签中</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"menu"</span>&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;hello&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"Menu"</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        msg:<span class="string">"这是Menu组件里面的菜单"</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>然后，在父组件中调用上面声明的子组件。</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552363770013.png" alt="1552363770013"></p><p>最后,父组件被App.vue调用.就可以看到页面效果.</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552363834171.png" alt="1552363834171"></p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552363702858.png" alt="1552363702858"></p><p>效果:</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552363849977.png" alt="1552363849977"></p><h3 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h3><h3 id="父组件的数据传递给子组件"><a href="#父组件的数据传递给子组件" class="headerlink" title="父组件的数据传递给子组件"></a>父组件的数据传递给子组件</h3><p>例如,我们希望把父组件的数据传递给子组件.</p><p>可以通过props属性来进行数据传递.</p><p>传递数据三个步骤：</p><ol><li><p>在父组件中，调用子组件的组名处，使用属性值的方式往下传递数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Menu</span> <span class="attr">:mynum</span>=<span class="string">"num"</span> <span class="attr">title</span>=<span class="string">"home里面写的数据"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"># 上面表示在父组件调用Menu子组件的时候传递了2个数据：</span><br><span class="line">  如果要传递变量[变量可以各种类型的数据]，属性名左边必须加上冒号:，同时，属性名是自定义的，会在子组件中使用。</span><br><span class="line">  如果要传递普通字符串数据，则不需要加上冒号:</span><br></pre></td></tr></table></figure></li><li><p>在子组件中接受上面父组件传递的数据，需要在vm组件对象中，使用props属性类接受。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"Menu"</span>,</span><br><span class="line">    props:[<span class="string">"mynum"</span>,<span class="string">"title"</span>],</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        msg:<span class="string">"这是Menu组件里面的菜单"</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 上面 props属性中表示接受了两个数据。</span></span><br></pre></td></tr></table></figure></li><li><p>在子组件中的template中使用父组件传递过来的数据.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;，&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello，&#123;&#123;mynum&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>效果：</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552364511546.png" alt="1552364511546"></p><p>步骤流程:</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552364590540.png" alt="1552364590540"></p><p>使用父组件传递数据给子组件时, 注意一下几点:</p><ol><li><p>传递数据是变量,则需要在属性左边添加冒号.</p><p>传递数据是变量,这种数据称之为“动态数据传递”</p><p>传递数据不是变量,这种数据称之为“静态数据传递”</p></li><li><p>父组件中修改了数据,在子组件中会被同步修改,但是,子组件中的数据修改了,是不是影响到父组件中的数据.</p><p>这种情况,在开发时,也被称为“单向数据流”</p></li></ol><h3 id="子组件传递数据给父组件"><a href="#子组件传递数据给父组件" class="headerlink" title="子组件传递数据给父组件"></a>子组件传递数据给父组件</h3><ol><li><p>在子组件中，通过<code>this.$emit()</code>来调用父组件中定义的事件.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Post的子组件&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;&#123;&#123;fnum&#125;&#125;&lt;/</span>h2&gt;</span><br><span class="line">      &lt;p&gt;data=&#123;&#123;data&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;fnum=&#123;&#123;fnum&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"fnum"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"PostSon"</span>,</span><br><span class="line">        <span class="comment">// 父组件传递数据给子组件: 1. 在父组件中调用子组件的组件名称标签上面声明属性和传递值，2. 在子组件中通过props进行接收</span></span><br><span class="line">        props:[<span class="string">"data"</span>,<span class="string">"fnum"</span>],  <span class="comment">// 接受父组件中传递过来的数据</span></span><br><span class="line">        <span class="comment">// 子组件传递数据给父组件[事件的方式进行传递]：</span></span><br><span class="line">        watch:&#123;</span><br><span class="line">          fnum()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.fnum);</span><br><span class="line">            <span class="comment">// this.$emit("父元素的自定义事件","要传递的数据");  // 通过this.$emit()方法，子组件可以把数据传递给父组件</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">"postparentdata"</span>,<span class="keyword">this</span>.fnum);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure></li><li><p>父组件中声明一个和子组件中<code>this.$emit(&quot;自定义事件名称&quot;)</code>对应的事件属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>num=&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Son</span> <span class="attr">data</span>=<span class="string">"我是付组件里面的内容"</span> <span class="attr">:fnum</span>=<span class="string">"num"</span> @<span class="attr">postparentdata</span>=<span class="string">"getsondata"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>父组件中，声明一个自定义方法，在事件被调用时，执行的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">"./PostSon"</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"Post"</span>,</span><br><span class="line">        data()&#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            num: <span class="number">100</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">          Son:Son,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">          getsondata(message)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"父组件"</span>+message);</span><br><span class="line">            <span class="keyword">this</span>.num = message;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="在组件中使用axios获取数据"><a href="#在组件中使用axios获取数据" class="headerlink" title="在组件中使用axios获取数据"></a>在组件中使用axios获取数据</h2><p>默认情况下，我们的项目中并没有对axios包的支持，所以我们需要下载安装。</p><p>在项目根目录中使用 npm安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>接着在main.js文件中，导入axios并把axios对象 挂载到vue属性中多为一个子对象，这样我们才能在组件中使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// The Vue build version to load <span class="keyword">with</span> the `<span class="keyword">import</span>` command</span><br><span class="line">// (runtime-only <span class="keyword">or</span> standalone) has been set <span class="keyword">in</span> webpack.base.conf <span class="keyword">with</span> an alias.</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span> // 这里表示从别的目录下导入 单文件组件</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>; // 从node_modules目录中导入包</span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">Vue.prototype.$axios = axios; // 把对象挂载vue中</span><br><span class="line"></span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="在组建中使用axios获取数据"><a href="#在组建中使用axios获取数据" class="headerlink" title="在组建中使用axios获取数据"></a>在组建中使用axios获取数据</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">。。。</span><br><span class="line">methods:&#123;</span><br><span class="line">      get_data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="comment">// 使用axios请求数据</span></span><br><span class="line">        <span class="keyword">this</span>.$axios.get(<span class="string">"http://wthrcdn.etouch.cn/weather_mini?city=深圳"</span>).then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(response);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552202922168.png" alt="1552202922168">使用的时候，因为本质上来说，我们还是原来的axios，所以也会收到同源策略的影响。</p>]]></content>
    
    <summary type="html">
    
      组件（Component）是自定义封装代码的功能。在前端开发过程中，经常出现多个网页的功能是重复的，而且很多不同的页面之间，也存在同样的功能,而在网页中实现一个功能，需要使用html定义功能的内容结构，使用css声明功能的外观样式，还要使用js来定义功能的...
    
    </summary>
    
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="vue框架" scheme="http://yoursite.com/tags/vue%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>[axios与组件化开发]</title>
    <link href="http://yoursite.com/2020/02/24/axios%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2020/02/24/axios%E4%B8%8E%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</id>
    <published>2020-02-24T12:00:16.000Z</published>
    <updated>2020-02-25T12:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过axios实现数据请求"><a href="#通过axios实现数据请求" class="headerlink" title="通过axios实现数据请求"></a>通过axios实现数据请求</h1><p>vue.js默认没有提供ajax功能的。</p><p>所以使用vue的时候，一般都会使用axios的插件来实现ajax与后端服务器的数据交互。</p><p>注意，axios本质上就是javascript的ajax封装，所以会被<strong>同源策略</strong>限制。</p><p>下载地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;unpkg.com&#x2F;axios@0.18.0&#x2F;dist&#x2F;axios.js</span><br><span class="line">https:&#x2F;&#x2F;unpkg.com&#x2F;axios@0.18.0&#x2F;dist&#x2F;axios.min.js</span><br></pre></td></tr></table></figure><p>使用文档：<a href="https://www.kancloud.cn/yunye/axios/234845" target="_blank" rel="noopener">https://www.kancloud.cn/yunye/axios/234845</a> </p><p>axios提供发送http请求的常用方法有两个：axios.get() 和 axios.post() 。</p><p>增 post</p><p>删 delete</p><p>改 put/patch</p><p>查 get</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送get请求</span></span><br><span class="line">    <span class="comment">// 参数1: 必填，字符串，请求的数据接口的url地址，例如请求地址：http://www.baidu.com?id=200</span></span><br><span class="line">    <span class="comment">// 参数2：可选，请求参数和请求头内容，json对象，要提供给数据接口的参数</span></span><br><span class="line">axios.get(<span class="string">'服务器的资源地址'</span>,&#123; <span class="comment">// http://www.baidu.com</span></span><br><span class="line">    params:&#123;</span><br><span class="line">    参数名:<span class="string">'参数值'</span>, <span class="comment">// id: 200,</span></span><br><span class="line">    &#125;,</span><br><span class="line">        headers:&#123;</span><br><span class="line">            选项名:<span class="string">'选项值'</span>, <span class="comment">// 请求头</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123; <span class="comment">// 请求成功以后的回调函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"请求成功"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(response.data); <span class="comment">// 获取服务端提供的数据</span></span><br><span class="line">    </span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;   <span class="comment">// 请求失败以后的回调函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"请求失败"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(error.response);  <span class="comment">// 获取错误信息</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送post请求，参数和使用和axios.get()类似。</span></span><br><span class="line">    <span class="comment">// 参数1: 必填，字符串，请求的数据接口的url地址</span></span><br><span class="line">    <span class="comment">// 参数2：必填，json对象，要提供给数据接口的参数,如果没有参数，则必须使用&#123;&#125;</span></span><br><span class="line">    <span class="comment">// 参数3：可选，json对象，请求头信息</span></span><br><span class="line">    axios.post(<span class="string">'服务器的资源地址'</span>,&#123;</span><br><span class="line">    username: <span class="string">'xiaoming'</span>,</span><br><span class="line">    password: <span class="string">'123456'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        headers:&#123;</span><br><span class="line">            选项名:<span class="string">"选项值"</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">response</span>=&gt;</span>&#123; <span class="comment">// 请求成功以后的回调函数</span></span><br><span class="line">      <span class="built_in">console</span>.log(response);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;   <span class="comment">// 请求失败以后的回调函数</span></span><br><span class="line">      <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// b'firstName=Fred&amp;lastName=Flintstone'</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：axios.delete() 的用法和参数与axios.get()一样，axios.put()或者axios.patch的用法和参数与axios.post()一样。在http协议中，不同的请求动作都有不同的含义，例如：get 代表向目标服务器请求获取数据post 代表向目标服务器请求上传数据put 代表向目标服务器请求更新数据【修改全部数据】patch 代表向目标服务器请求更新数据【修改部分数据】patch 代表向目标服务器请求更新数据delete 代表向目标服务器请求删除数据</p></blockquote><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>json是 JavaScript Object Notation 的首字母缩写，单词的意思是javascript对象表示法，这里说的json指的是类似于javascript对象的一种数据格式。</p><p>json的作用：在不同的系统平台，或不同编程语言之间传递数据。</p><h3 id="json数据的语法"><a href="#json数据的语法" class="headerlink" title="json数据的语法"></a>json数据的语法</h3><p>json数据对象类似于JavaScript中的对象，但是它的键对应的值里面是没有函数方法的，值可以是普通变量，不支持undefined，值还可以是数组或者json对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生的js的json对象</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  age:<span class="number">10</span>,</span><br><span class="line">  sex: <span class="string">'女'</span>,</span><br><span class="line">  work()&#123;                     <span class="comment">// work: function()&#123;&#125;的简写</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"好好学习"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// json数据的对象格式,json数据格式,是没有方法的,只有属性,属性值：字符串，数值(整数，浮点数，布尔值), json，</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>:<span class="string">"tom"</span>,</span><br><span class="line">    <span class="string">"age"</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// json数据的数组格式：</span></span><br><span class="line">[<span class="string">"tom"</span>,<span class="number">18</span>,<span class="string">"programmer"</span>]</span><br></pre></td></tr></table></figure><p>复杂的json格式数据可以包含对象和数组的写法。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>:<span class="string">"小明"</span>,</span><br><span class="line">  <span class="attr">"age"</span>:<span class="number">200</span>,</span><br><span class="line">  <span class="attr">"is_delete"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">"fav"</span>:[<span class="string">"code"</span>,<span class="string">"eat"</span>,<span class="string">"swim"</span>,<span class="string">"read"</span>],</span><br><span class="line">  <span class="attr">"son"</span>:&#123;</span><br><span class="line">    <span class="attr">"name"</span>:<span class="string">"小小明"</span>,</span><br><span class="line">    <span class="attr">"age"</span>:<span class="number">100</span>,</span><br><span class="line">    <span class="attr">"lve"</span>:[<span class="string">"code"</span>,<span class="string">"eat"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组结构也可以作为json传输数据。</span></span><br></pre></td></tr></table></figure><p>json数据可以保存在.json文件中，一般里面就只有一个json对象。</p><p>总结：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. json文件的后缀是.json</span><br><span class="line">2. json文件一般保存一个单一的json数据</span><br><span class="line">3. json数据的属性不能是方法或者undefined，属性值只能：数值[整数,小数,布尔值]、字符串、json和数组</span><br><span class="line">4. json数据只使用双引号、每一个属性成员之间使用逗号隔开，并且最后一个成员没有逗号。</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="attr">"name"</span>:<span class="string">"小明"</span>,</span><br><span class="line">      <span class="attr">"age"</span>:<span class="number">200</span>,</span><br><span class="line">      <span class="attr">"fav"</span>:[<span class="string">"code"</span>,<span class="string">"eat"</span>,<span class="string">"swim"</span>,<span class="string">"read"</span>],</span><br><span class="line">      <span class="attr">"son"</span>:&#123;</span><br><span class="line">        <span class="attr">"name"</span>:<span class="string">"小小明"</span>,</span><br><span class="line">        <span class="attr">"age"</span>:<span class="number">100</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>工具：postman可以用于测试开发的数据接口。</p><p>postman就是一个软件，专门提供给开发者组织和测试http请求的。</p><h3 id="js中提供的json数据转换方法"><a href="#js中提供的json数据转换方法" class="headerlink" title="js中提供的json数据转换方法"></a>js中提供的json数据转换方法</h3><p>javascript提供了一个JSON对象来操作json数据的数据转换.</p><table><thead><tr><th>方法</th><th>参数</th><th>返回值</th><th>描述</th></tr></thead><tbody><tr><td>stringify</td><td>json对象</td><td>字符串</td><td>json对象转成字符串</td></tr><tr><td>parse</td><td>字符串</td><td>json对象</td><td>字符串格式的json数据转成json对象</td></tr></tbody></table><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">// json语法</span></span><br><span class="line">    <span class="keyword">let</span> humen = &#123;</span><br><span class="line">        <span class="string">"username"</span>:<span class="string">"xiaohui"</span>,</span><br><span class="line">        <span class="string">"password"</span>:<span class="string">"1234567"</span>,</span><br><span class="line">        <span class="string">"age"</span>:<span class="number">20</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(humen);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> humen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON对象提供对json格式数据的转换功能</span></span><br><span class="line">    <span class="comment">// stringify(json对象)  # 用于把json转换成字符串</span></span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">JSON</span>.stringify(humen);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> result);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse(字符串类型的json数据)  # 用于把字符串转成json对象</span></span><br><span class="line">    <span class="keyword">let</span> json_str = <span class="string">'&#123;"password":"1123","age":20,"name":"xiaobai"&#125;'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(json_str)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> json_str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> json_obj = <span class="built_in">JSON</span>.parse(json_str);</span><br><span class="line">    <span class="built_in">console</span>.log(json_obj);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">typeof</span> json_obj)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(json_obj.age)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><p>ajax，一般中文称之为：“阿贾克斯”，是英文 “Async Javascript And Xml”的简写，译作：异步js和xml数据传输数据。</p><p>ajax的作用： ajax可以让js代替浏览器向后端程序发送http请求，与后端通信，在用户不知道的情况下操作数据和信息，从而实现页面局部刷新数据/无刷新更新数据。</p><p>所以web开发中ajax是很常用的技术，主要用于操作后端提供的<code>数据接口</code>，从而实现网站的<code>前后端分离</code>。</p><p>ajax技术的原理是实例化js的XMLHttpRequest对象，使用此对象提供的内置方法就可以与后端进行数据通信。</p><blockquote><p>实际而言，axios或者jQuery提供的ajax，本质上就是XMLHttpRequest对象操作的封装。</p></blockquote><h3 id="数据接口"><a href="#数据接口" class="headerlink" title="数据接口"></a>数据接口</h3><p>数据接口，也叫api接口，表示<code>后端提供</code>操作数据/功能的url地址给客户端使用。</p><p>客户端通过发起请求向服务端提供的url地址申请操作数据【操作一般：增删查改】</p><p>同时在工作中，大部分数据接口都不是手写，而是通过函数库/框架来生成。</p><h3 id="ajax的使用"><a href="#ajax的使用" class="headerlink" title="ajax的使用"></a>ajax的使用</h3><p>ajax的使用必须与服务端程序配合使用，但是目前我们先学习ajax的使用，所以暂时先不涉及到服务端python代码的编写。因此，我们可以使用别人写好的数据接口进行调用。</p><p>jQuery将ajax封装成了一个函数$.ajax()，我们可以直接用这个函数来执行ajax请求。</p><table><thead><tr><th>接口</th><th>地址</th></tr></thead><tbody><tr><td>天气接口</td><td><a href="http://wthrcdn.etouch.cn/weather_mini?city=城市名称" target="_blank" rel="noopener">http://wthrcdn.etouch.cn/weather_mini?city=城市名称</a></td></tr><tr><td>音乐接口搜索</td><td><a href="http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.search.catalogSug&amp;query=歌曲标题" target="_blank" rel="noopener">http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.search.catalogSug&amp;query=歌曲标题</a></td></tr><tr><td>音乐信息接口</td><td><a href="http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.song.play&amp;songid=音乐ID" target="_blank" rel="noopener">http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.song.play&amp;songid=音乐ID</a></td></tr></tbody></table><p>编写代码获取接口提供的数据：</p><p>jQ版本</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>jquery<span class="number">-1.12</span><span class="number">.4</span>.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">    $(function()&#123;</span></span><br><span class="line">        $("#btn").on("click",function()&#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                <span class="comment">// 后端程序的url地址</span></span><br><span class="line">                url: <span class="string">'http://wthrcdn.etouch.cn/weather_mini'</span>,</span><br><span class="line">                <span class="comment">// 也可以使用method，提交数据的方式，默认是'GET'，常用的还有'POST'</span></span><br><span class="line">                type: <span class="string">'get'</span>, </span><br><span class="line">                dataType: <span class="string">'json'</span>,  <span class="comment">// 返回的数据格式，常用的有是'json','html',"jsonp"</span></span><br><span class="line">                data:&#123; <span class="comment">// 设置发送给服务器的数据，如果是get请求，也可以写在url地址的?后面</span></span><br><span class="line">                    <span class="string">"city"</span>:<span class="string">'北京'</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .done(<span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;     <span class="comment">// 请求成功以后的操作</span></span><br><span class="line">                <span class="built_in">console</span>.log(resp);</span><br><span class="line">            &#125;)</span><br><span class="line">            .fail(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;    <span class="comment">// 请求失败以后的操作</span></span><br><span class="line">                <span class="built_in">console</span>.log(error);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=<span class="string">"btn"</span>&gt;点击获取数据&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>vue版本：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>vue.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script src="</span>js/axios.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="</span>app<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="</span>text<span class="string">" v-model="</span>city<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;button @click="</span>get_weather<span class="string">"&gt;点击获取天气&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">        let vm = new Vue(&#123;</span></span><br><span class="line">            el:"#app",</span><br><span class="line">            data:&#123;</span><br><span class="line">                city:<span class="string">""</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                get_weather()&#123;</span><br><span class="line">                    <span class="comment">// http://wthrcdn.etouch.cn/weather_mini?city=城市名称</span></span><br><span class="line">                    axios.get(<span class="string">"http://wthrcdn.etouch.cn/weather_mini?city="</span>+<span class="keyword">this</span>.city)</span><br><span class="line">                        .then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(response);</span><br><span class="line"></span><br><span class="line">                        &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(error.response)</span><br><span class="line">                    &#125;);</span><br><span class="line">                  <span class="comment">// 上面的参数写法,也可以是下面这种格式:</span></span><br><span class="line">                  <span class="comment">// axios.get("http://wthrcdn.etouch.cn/weather_mini",&#123;</span></span><br><span class="line">                  <span class="comment">//     // get请求的附带参数</span></span><br><span class="line">                  <span class="comment">//     params:&#123;</span></span><br><span class="line">                  <span class="comment">//         "city":"广州",</span></span><br><span class="line">                  <span class="comment">//     &#125;</span></span><br><span class="line">                  <span class="comment">// &#125;).then(response=&gt;&#123;</span></span><br><span class="line">                  <span class="comment">//     console.log(response.data);  // 获取接口数据</span></span><br><span class="line">                  <span class="comment">// &#125;).catch(error=&gt;&#123;</span></span><br><span class="line">                  <span class="comment">//     console.log(error.response); // 获取错误信息</span></span><br><span class="line">                  <span class="comment">// &#125;)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>同源策略，是浏览器为了保护用户信息安全的一种安全机制。所谓的同源就是指代通信的两个地址（例如服务端接口地址与浏览器客户端页面地址）之间比较，是否协议、域名(IP)和端口相同。不同源的客户端脚本[javascript]在没有得到服务端的明确授权的情况下，浏览器会拒绝显示服务端信息提供给前端ajax。</p><p>ajax本质上还是javascript，是运行在浏览器中的脚本语言，所以会被受到浏览器的同源策略所限制。</p><table><thead><tr><th>前端地址：<code>http://www.oldboy.cn/index.html</code></th><th>是否同源</th><th>原因</th></tr></thead><tbody><tr><td><code>http://www.oldboy.cn/user/login.html</code></td><td>是</td><td>协议、域名、端口相同</td></tr><tr><td><code>http://www.oldboy.cn/about.html</code></td><td>是</td><td>协议、域名、端口相同</td></tr><tr><td><code>https://www.oldboy.cn:443/user/login.html</code></td><td>否</td><td>协议不同 ( https和http )</td></tr><tr><td><code>http:/www.oldboy.cn:5000/user/login.html</code></td><td>否</td><td>端口 不同( 5000和80)</td></tr><tr><td><code>http://bbs.oldboy.cn/user/login.html</code></td><td>否</td><td>域名不同 ( bbs和www )</td></tr></tbody></table><p>同源策略针对ajax的拦截，代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script src="js/</span>vue.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">    &lt;script src="</span>js/axios.js<span class="string">"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div id="</span>app<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        &lt;input type="</span>text<span class="string">" v-model="</span>music<span class="string">"&gt;&lt;button @click="</span>get_music<span class="string">"&gt;查询歌曲&lt;/button&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script&gt;</span></span><br><span class="line"><span class="string">        var vm = new Vue(&#123;</span></span><br><span class="line">            el:"#app",</span><br><span class="line">            data:&#123;</span><br><span class="line">                music:<span class="string">""</span>, <span class="comment">// 歌曲标题</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods:&#123;</span><br><span class="line">                get_music()&#123;</span><br><span class="line">                    axios.get(<span class="string">`http://tingapi.ting.baidu.com/v1/restserver/ting`</span>,&#123;</span><br><span class="line">                        params:&#123;</span><br><span class="line">                            method:<span class="string">"baidu.ting.search.catalogSug"</span>,</span><br><span class="line">                            query:<span class="keyword">this</span>.music,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).then(<span class="function"><span class="params">response</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">"查询数据成功！"</span>);</span><br><span class="line">                    &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">"查询数据失败！"</span>);</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码运行错误如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">'http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.search.catalogSug&amp;query=%E6%88%91%E7%9A%84%E4%B8%AD%E5%9B%BD%E5%BF%83'</span> <span class="keyword">from</span> origin <span class="string">'http://localhost:63342'</span> has been blocked by CORS policy: No <span class="string">'Access-Control-Allow-Origin'</span> header <span class="keyword">is</span> present on the requested resource.</span><br></pre></td></tr></table></figure><p>上面错误，关键词：Access-Control-Allow-Origin</p><p>只要出现这个关键词，就是访问受限。出现同源策略的拦截问题。</p><h3 id="ajax跨域-跨源-方案之CORS"><a href="#ajax跨域-跨源-方案之CORS" class="headerlink" title="ajax跨域(跨源)方案之CORS"></a>ajax跨域(跨源)方案之CORS</h3><p>ajax跨域(跨源)方案：服务端授权[CORS]，jsonp，服务端代理</p><p> CORS是一个W3C标准，全称是“跨域资源共享”，它允许浏览器向跨源的后端服务器发出ajax请求，从而克服了AJAX只能同源使用的限制。</p><p> 实现CORS主要依靠后端服务器中响应数据中设置响应头信息返回的。</p><p>django的视图[伪代码]</p><p>def post(request):</p><p> response = new Response()</p><p> response .set_header(“Access-Control-Allow-Origin”,“<a href="http://localhost:63342”">http://localhost:63342”</a>)</p><p> return response;</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 在响应行信息里面设置以下内容：</span><br><span class="line">Access-Control-Allow-Origin: ajax所在的域名地址</span><br><span class="line"></span><br><span class="line">Access-Control-Allow-Origin: www.oldboy.cn  <span class="comment"># 表示只允许www.oldboy.cn域名的客户端的ajax跨域访问</span></span><br><span class="line"></span><br><span class="line">// * 表示任意源，表示允许任意源下的客户端的ajax都可以访问当前服务端信息</span><br><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p><img src="/images/1556074087897.png" alt=""></p><p>总结：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0. 同源策略：浏览器的一种保护用户数据的一种安全机制。</span><br><span class="line">   浏览器会限制ajax不能跨源访问其他源的数据地址。</span><br><span class="line">   同源：判断两个通信的地址之间，是否协议，域名[IP]，端口一致。</span><br><span class="line">   </span><br><span class="line">   ajax：  http:&#x2F;&#x2F;127.0.0.1&#x2F;index.html</span><br><span class="line">   api数据接口：  http:&#x2F;&#x2F;localhost&#x2F;index</span><br><span class="line">   </span><br><span class="line">   这两个是同源么？不是同源的。是否同源的判断依据不会根据电脑来判断，而是通过协议、域名、端口的字符串是否来判断。</span><br><span class="line">   </span><br><span class="line">1. ajax默认情况下会受到同源策略的影响，一旦受到影响会报错误如下：</span><br><span class="line"> No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource</span><br><span class="line"></span><br><span class="line">2. 解决ajax只能同源访问数据接口的方式：</span><br><span class="line">   1. CORS，跨域资源共享，在服务端的响应行中设置：</span><br><span class="line">      Access-Control-Allow-Origin: 允许访问的域名地址</span><br><span class="line">   2. jsonp</span><br><span class="line">     所谓的jsonp本质上来说不是ajax技术，jsonp的核心实现是依靠script本身加载外部js文件来实现的。</span><br><span class="line">     当然，实现jsonp技术，也需要服务端的配合</span><br><span class="line">   3. 是否服务端代理</span><br><span class="line">      思路：通过python来请求对应的服务器接口，客户端和python这边处于同源，那么就实现了服务端代理</span><br></pre></td></tr></table></figure><h1 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h1><h2 id="组件-component"><a href="#组件-component" class="headerlink" title="组件[component]"></a>组件[component]</h2><p>组件（Component）是自定义封装的功能。在前端开发过程中，经常出现多个网页的功能是重复的，而且很多不同的页面之间，也存在同样的功能。</p><p>而在网页中实现一个功能，需要使用html定义功能的内容结构，使用css声明功能的外观样式，还要使用js来定义功能的特效，因此就产生了把一个功能相关的[HTML、css和javascript]代码封装在一起组成一个整体的代码块封装模式，我们称之为“组件”。</p><p>所以，组件就是一个html网页中的功能，一般就是一个标签，标签中有自己的html内容结构，css样式和js特效。</p><p>这样，前端人员就可以在组件化开发时，只需要书写一次代码，随处引入即可使用。</p><p>vue的组件有两种：默认组件[全局组件] 和 单文件组件</p><h3 id="5-1-1-默认组件"><a href="#5-1-1-默认组件" class="headerlink" title="5.1.1 默认组件"></a>5.1.1 默认组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">addnum</span>&gt;</span><span class="tag">&lt;/<span class="name">addnum</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">addnum</span>&gt;</span><span class="tag">&lt;/<span class="name">addnum</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">addnum</span>&gt;</span><span class="tag">&lt;/<span class="name">addnum</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">addnum</span>&gt;</span><span class="tag">&lt;/<span class="name">addnum</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">addnum</span>&gt;</span><span class="tag">&lt;/<span class="name">addnum</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    Vue.component(<span class="string">"addnum"</span>,&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template:'<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"num"</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"num+=1"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>',</span></span></span><br><span class="line"><span class="actionscript">        data: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 写在这里的数据只有当前组件可以使用</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                num:1,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#app"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 这里写的数据是全局公用的，整个文件共享</span></span></span><br><span class="line">        data:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Vue自动化工具（Vue-cli）"><a href="#Vue自动化工具（Vue-cli）" class="headerlink" title="Vue自动化工具（Vue-cli）"></a>Vue自动化工具（Vue-cli）</h1><p>前面学习了普通组件以后，接下来我们继续学习单文件组件则需要提前先安装准备一些组件开发工具。否则无法使用和学习单文件组件。</p><p>一般情况下，单文件组件，我们运行在 自动化工具vue-CLI中，可以帮我们编译单文件组件。所以我们需要在系统中先搭建vue-CLI工具，</p><p>官网：<a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">https://cli.vuejs.org/zh/</a></p><p>Vue CLI 需要 <a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a> 或 <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">nvm-windows</a>在同一台电脑中管理多个 Node 版本。</p><p>nvm工具的下载和安装： </p><p><a href="https://www.jianshu.com/p/d0e0935b150a" target="_blank" rel="noopener">https://www.jianshu.com/p/d0e0935b150a</a></p><p><a href="https://www.jianshu.com/p/622ad36ee020" target="_blank" rel="noopener">​https://www.jianshu.com/p/622ad36ee020</a></p><p>安装记录:</p><p>打开:<a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener">https://github.com/coreybutler/nvm-windows/releases</a></p><p>安装完成以后,先查看环境变量是否设置好了.</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552357036022.png" alt="1552357036022"></p><p>常用的nvm命令</p><p>nvm list # 列出目前在nvm里面安装的所有node版本 nvm install node版本号 # 安装指定版本的node.js nvm uninstall node版本号 # 卸载指定版本的node.js nvm use node版本号 # 切换当前使用的node.js版本</p><p>如果使用nvm工具，则直接可以不用自己手动下载，如果使用nvm下载安装 node的npm比较慢的时候，可以修改nvm的配置文件(在安装根目录下)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># settings.txt</span><br><span class="line">root: C:\tool\nvm    [这里的目录地址是安装nvm时自己设置的地址,要根据实际修改]</span><br><span class="line">path: C:\tool\nodejs</span><br><span class="line">arch: 64</span><br><span class="line">proxy: none</span><br><span class="line">node_mirror: http:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F; </span><br><span class="line">npm_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F;</span><br></pre></td></tr></table></figure><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>Node.js是一个新的后端(后台)语言，它的语法和JavaScript类似，所以可以说它是属于前端的后端语言，后端语言和前端语言的区别：</p><ul><li>运行环境：后端语言一般运行在服务器端，前端语言运行在客户端的浏览器上</li><li>功能：后端语言可以操作文件，可以读写数据库，前端语言不能操作文件，不能读写数据库。</li></ul><p>我们一般安装LTS(长线支持版本 Long-Time Support)：</p><p>下载地址：<a href="https://nodejs.org/en/download/【上面已经安装了nvm，那么这里不用手动安装了】" target="_blank" rel="noopener">https://nodejs.org/en/download/【上面已经安装了nvm，那么这里不用手动安装了】</a></p><p>node.js的版本有两大分支：</p><p>官方发布的node.js版本：0.xx.xx 这种版本号就是官方发布的版本</p><p>社区发布的node.js版本：xx.xx.x 就是社区开发的版本</p><p>Node.js如果安装成功，可以查看Node.js的版本,在终端输入如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>在安装node.js完成后，在node.js中会同时帮我们安装一个npm包管理器npm。我们可以借助npm命令来安装node.js的包。这个工具相当于python的pip管理器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install -g 包名              <span class="comment"># 安装模块   -g表示全局安装，如果没有-g，则表示在当前项目安装</span></span><br><span class="line">npm list                        <span class="comment"># 查看当前目录下已安装的node包</span></span><br><span class="line">npm view 包名 engines            <span class="comment"># 查看包所依赖的Node的版本 </span></span><br><span class="line">npm outdated                    <span class="comment"># 检查包是否已经过时，命令会列出所有已过时的包</span></span><br><span class="line">npm update 包名                  <span class="comment"># 更新node包</span></span><br><span class="line">npm uninstall 包名               <span class="comment"># 卸载node包</span></span><br><span class="line">npm 命令 -h                      <span class="comment"># 查看指定命令的帮助文档</span></span><br></pre></td></tr></table></figure><h2 id="安装Vue-cli"><a href="#安装Vue-cli" class="headerlink" title="安装Vue-cli"></a>安装Vue-cli</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g vue-cli</span><br></pre></td></tr></table></figure><p>如果安装速度过慢，一直超时，可以考虑切换npm镜像源：<a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a></p><h2 id="使用Vue-CLI初始化创建前端项目"><a href="#使用Vue-CLI初始化创建前端项目" class="headerlink" title="使用Vue-CLI初始化创建前端项目"></a>使用Vue-CLI初始化创建前端项目</h2><h3 id="生成项目目录"><a href="#生成项目目录" class="headerlink" title="生成项目目录"></a>生成项目目录</h3><p>使用vue自动化工具可以快速搭建单页应用项目目录。</p><p>该工具为现代化的前端开发工作流提供了开箱即用的构建配置。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 生成一个基于 webpack 模板的新项目</span><br><span class="line">vue init webpack 项目目录名</span><br><span class="line">例如：</span><br><span class="line">vue init webpack myproject</span><br><span class="line"></span><br><span class="line">// 启动开发服务器 ctrl+c 停止服务</span><br><span class="line"><span class="built_in">cd</span> myproject</span><br><span class="line">npm run dev           <span class="comment"># 运行这个命令就可以启动node提供的测试http服务器</span></span><br></pre></td></tr></table></figure><p>运行了上面代码以后,终端下会出现以下效果提示：</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552187745456.png" alt="1552187745456"></p><p>那么访问：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552187794989.png" alt="1552187794989"></p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><p>src 主开发目录，要开发的单文件组件全部在这个目录下的components目录下</p><p>static 静态资源目录，所有的css，js文件放在这个文件夹</p><p>dist项目打包发布文件夹，最后要上线单文件项目文件都在这个文件夹中[后面打包项目,让项目中的vue组件经过编译变成js 代码以后,dist就出现了]</p><p>node_modules目录是node的包目录，</p><p>config是配置目录，</p><p>build是项目打包时依赖的目录</p><p>src/router 路由,后面需要我们在使用Router路由的时候,自己声明.</p><h3 id="项目执行流程图"><a href="#项目执行流程图" class="headerlink" title="项目执行流程图"></a>项目执行流程图</h3><p><img src="/images/page_structrue.png" alt=""></p><p>page_structrue</p><p>整个项目是一个主文件index.html,index.html中会引入src文件夹中的main.js,main.js中会导入顶级单文件组件App.vue,App.vue中会通过组件嵌套或者路由来引用components文件夹中的其他单文件组件。</p><h2 id="单文件组件的使用"><a href="#单文件组件的使用" class="headerlink" title="单文件组件的使用"></a>单文件组件的使用</h2><p>组件有两种：普通组件、单文件组件</p><p>普通组件的缺点：</p><ol><li>html代码是作为js的字符串进行编写，所以组装和开发的时候不易理解，而且没有高亮效果。</li><li>普通组件用在小项目中非常合适，但是复杂的大项目中，如果把更多的组件放在html文件中，那么维护成本就会变得非常昂贵。</li><li>普通组件只是整合了js和html，但是css代码被剥离出去了。使用的时候的时候不好处理。</li></ol><p>将一个组件相关的html结构，css样式，以及交互的JavaScript代码从html文件中剥离出来，合成一个文件，这种文件就是单文件组件，相当于一个组件具有了结构、表现和行为的完整功能，方便组件之间随意组合以及组件的重用，这种文件的扩展名为“.vue”，比如：“Home.vue”。</p><ol><li>创建组件</li></ol><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552362045478.png" alt="1552362045478"></p><p>在组件中编辑三个标签，编写视图、vm对象和css样式代码。</p><h3 id="template-编写html代码的地方"><a href="#template-编写html代码的地方" class="headerlink" title="template 编写html代码的地方"></a>template 编写html代码的地方</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"Home"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">"num--"</span> <span class="attr">class</span>=<span class="string">"sub"</span>&gt;</span>-<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">size</span>=<span class="string">"1"</span> <span class="attr">v-model</span>=<span class="string">"num"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">"num++"</span> <span class="attr">class</span>=<span class="string">"add"</span>&gt;</span>+<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="script编写vue-js代码"><a href="#script编写vue-js代码" class="headerlink" title="script编写vue.js代码"></a>script编写vue.js代码</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"Home"</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        num:<span class="number">0</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="style编写当前组件的样式代码"><a href="#style编写当前组件的样式代码" class="headerlink" title="style编写当前组件的样式代码"></a>style编写当前组件的样式代码</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">  <span class="selector-class">.sub</span>,<span class="selector-class">.add</span>&#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">4px</span> <span class="number">7px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="完成案例-点击加减数字"><a href="#完成案例-点击加减数字" class="headerlink" title="完成案例-点击加减数字"></a>完成案例-点击加减数字</h3><p>创建Homes.vue</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"add_num"</span>&gt;</span><br><span class="line">      &lt;span @click=<span class="string">"num++"</span>&gt;+&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input type="text" size="2" v-model="num"&gt;</span></span><br><span class="line"><span class="regexp">      &lt;span @click="num--"&gt;-&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    name:<span class="string">"AddNum"</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        num: <span class="number">0</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">   .add_num&#123;</span></span><br><span class="line"><span class="regexp">      font-size: 32px;</span></span><br><span class="line"><span class="regexp">   &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>在App.vue组件中调用上面的组件</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"Home"</span>&gt;</span><br><span class="line">    &lt;span @click=<span class="string">"num--"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"sub"</span>&gt;-&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;input type="text" size="1" v-model="num"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;span @click="num++" class="add"&gt;+&lt;/</span>span&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"Home"</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        num:<span class="number">0</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp">  .sub,.add&#123;</span></span><br><span class="line"><span class="regexp">    border: 1px solid red;</span></span><br><span class="line"><span class="regexp">    padding: 4px 7px;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure><p>在开发vue项目之前，需要手动把 App.vue的HelloWorld组件代码以及默认的css样式，清楚。</p><p>上面的代码效果：</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552362182984.png" alt="1552362182984"></p><h3 id="组件的嵌套"><a href="#组件的嵌套" class="headerlink" title="组件的嵌套"></a>组件的嵌套</h3><p>有时候开发vue项目时,页面也可以算是一个大组件,同时页面也可以分成多个子组件.</p><p>因为,产生了父组件调用子组件的情况.</p><p>例如,我们可以声明一个组件,作为父组件</p><p>在components/创建一个保存子组件的目录HomeSon</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552363669256.png" alt="1552363669256"></p><p>在HomeSon目录下,可以创建当前页面的子组件,例如,是Menu.vue</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  组件中代码必须写在同一个标签中</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=<span class="string">"menu"</span>&gt;</span><br><span class="line">      &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;hello&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"Menu"</span>,</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        msg:<span class="string">"这是Menu组件里面的菜单"</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>然后，在父组件中调用上面声明的子组件。</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552363770013.png" alt="1552363770013"></p><p>最后,父组件被App.vue调用.就可以看到页面效果.</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552363834171.png" alt="1552363834171"></p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552363849977.png" alt="1552363849977"></p><p>效果:</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552363702858.png" alt="1552363702858"></p><h3 id="7-5-传递数据"><a href="#7-5-传递数据" class="headerlink" title="7.5 传递数据"></a>7.5 传递数据</h3><h3 id="父组件的数据传递给子组件"><a href="#父组件的数据传递给子组件" class="headerlink" title="父组件的数据传递给子组件"></a>父组件的数据传递给子组件</h3><p>例如,我们希望把父组件的数据传递给子组件.</p><p>可以通过props属性来进行数据传递.</p><p>传递数据三个步骤：</p><ol><li><p>在父组件中，调用子组件的组名处，使用属性值的方式往下传递数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Menu :mynum&#x3D;&quot;num&quot; title&#x3D;&quot;home里面写的数据&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line"># 上面表示在父组件调用Menu子组件的时候传递了2个数据：</span><br><span class="line">  如果要传递变量[变量可以各种类型的数据]，属性名左边必须加上冒号:，同时，属性名是自定义的，会在子组件中使用。</span><br><span class="line">  如果要传递普通字符串数据，则不需要加上冒号:</span><br></pre></td></tr></table></figure></li><li><p>在子组件中接受上面父组件传递的数据，需要在vm组件对象中，使用props属性类接受。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    name:<span class="string">"Menu"</span>,</span><br><span class="line">    props:[<span class="string">"mynum"</span>,<span class="string">"title"</span>],</span><br><span class="line">    data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        msg:<span class="string">"这是Menu组件里面的菜单"</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 上面 props属性中表示接受了两个数据。</span></span><br></pre></td></tr></table></figure></li><li><p>在子组件中的template中使用父组件传递过来的数据.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;，&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello，&#123;&#123;mynum&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>效果：</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552364511546.png" alt="1552364511546"></p><p>步骤流程:</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552364590540.png" alt="1552364590540"></p><p>使用父组件传递数据给子组件时, 注意一下几点:</p><ol><li><p>传递数据是变量,则需要在属性左边添加冒号.</p><p>传递数据是变量,这种数据称之为“动态数据传递”</p><p>传递数据不是变量,这种数据称之为“静态数据传递”</p></li><li><p>父组件中修改了数据,在子组件中会被同步修改,但是,子组件中的数据修改了,是不是影响到父组件中的数据.</p><p>这种情况,在开发时,也被称为“单向数据流”</p></li></ol><h3 id="子组件传递数据给父组件"><a href="#子组件传递数据给父组件" class="headerlink" title="子组件传递数据给父组件"></a>子组件传递数据给父组件</h3><ol><li><p>在子组件中，通过<code>this.$emit()</code>来调用父组件中定义的事件.</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Post的子组件&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;h2&gt;&#123;&#123;fnum&#125;&#125;&lt;/</span>h2&gt;</span><br><span class="line">      &lt;p&gt;data=&#123;&#123;data&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;fnum=&#123;&#123;fnum&#125;&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;div&gt;<span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"fnum"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"PostSon"</span>,</span><br><span class="line">        <span class="comment">// 父组件传递数据给子组件: 1. 在父组件中调用子组件的组件名称标签上面声明属性和传递值，2. 在子组件中通过props进行接收</span></span><br><span class="line">        props:[<span class="string">"data"</span>,<span class="string">"fnum"</span>],  <span class="comment">// 接受父组件中传递过来的数据</span></span><br><span class="line">        <span class="comment">// 子组件传递数据给父组件[事件的方式进行传递]：</span></span><br><span class="line">        watch:&#123;</span><br><span class="line">          fnum()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.fnum);</span><br><span class="line">            <span class="comment">// this.$emit("父元素的自定义事件","要传递的数据");  // 通过this.$emit()方法，子组件可以把数据传递给父组件</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.$emit(<span class="string">"postparentdata"</span>,<span class="keyword">this</span>.fnum);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style scoped&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure></li><li><p>父组件中声明一个和子组件中<code>this.$emit(&quot;自定义事件名称&quot;)</code>对应的事件属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>num=&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">Son</span> <span class="attr">data</span>=<span class="string">"我是付组件里面的内容"</span> <span class="attr">:fnum</span>=<span class="string">"num"</span> @<span class="attr">postparentdata</span>=<span class="string">"getsondata"</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>父组件中，声明一个自定义方法，在事件被调用时，执行的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">"./PostSon"</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">        name: <span class="string">"Post"</span>,</span><br><span class="line">        data()&#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            num: <span class="number">100</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">          Son:Son,</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">          getsondata(message)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"父组件"</span>+message);</span><br><span class="line">            <span class="keyword">this</span>.num = message;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>作业：</p><ol><li>使用组件化开发，完成之前的选项卡练习功能</li><li>使用组件化开发，完成之前的todolist功能</li><li>使用组件化开发，完成table表格的增删查改作业，数据使用本地存储进行保存</li></ol><h2 id="在组件中使用axios获取数据"><a href="#在组件中使用axios获取数据" class="headerlink" title="在组件中使用axios获取数据"></a>在组件中使用axios获取数据</h2><p>默认情况下，我们的项目中并没有对axios包的支持，所以我们需要下载安装。</p><p>在项目根目录中使用 npm安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><p>接着在main.js文件中，导入axios并把axios对象 挂载到vue属性中多为一个子对象，这样我们才能在组件中使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// The Vue build version to load <span class="keyword">with</span> the `<span class="keyword">import</span>` command</span><br><span class="line">// (runtime-only <span class="keyword">or</span> standalone) has been set <span class="keyword">in</span> webpack.base.conf <span class="keyword">with</span> an alias.</span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span> // 这里表示从别的目录下导入 单文件组件</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>; // 从node_modules目录中导入包</span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line"></span><br><span class="line">Vue.prototype.$axios = axios; // 把对象挂载vue中</span><br><span class="line"></span><br><span class="line">/* eslint-disable no-new */</span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="在组建中使用axios获取数据"><a href="#在组建中使用axios获取数据" class="headerlink" title="在组建中使用axios获取数据"></a>在组建中使用axios获取数据</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">。。。</span><br><span class="line">methods:&#123;</span><br><span class="line">      get_data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="comment">// 使用axios请求数据</span></span><br><span class="line">        <span class="keyword">this</span>.$axios.get(<span class="string">"http://wthrcdn.etouch.cn/weather_mini?city=深圳"</span>).then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(response);</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>效果:</p><p><img src="https://roger-hub.oss-cn-shanghai.aliyuncs.com/img_sre/1552202922168.png" alt="1552202922168"></p><p>使用的时候，因为本质上来说，我们还是原来的axios，所以也会收到同源策略的影响。</p><h2 id="组件-component-1"><a href="#组件-component-1" class="headerlink" title="组件[component]"></a>组件[component]</h2><p>组件（Component）是自定义封装代码的功能。在前端开发过程中，经常出现多个网页的功能是重复的，而且很多不同的页面之间，也存在同样的功能。</p><p>而在网页中实现一个功能，需要使用html定义功能的内容结构，使用css声明功能的外观样式，还要使用js来定义功能的特效，因此就产生了把一个功能相关的[HTML、css和javascript]代码封装在一起组成一个整体的代码块封装模式，我们称之为“组件”。</p><p>所以，组件就是一个html网页中的功能，一般就是一个标签，标签中有自己的html内容结构，css样式和js特效。</p><p>这样，前端人员就可以在组件化开发时，只需要书写一次代码，随处引入即可使用。</p><p>vue的组件有两种：默认组件[全局组件] 和 单文件组件</p><h3 id="默认组件"><a href="#默认组件" class="headerlink" title="默认组件"></a>默认组件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;addnum&gt;&lt;<span class="regexp">/addnum&gt;</span></span><br><span class="line"><span class="regexp">    &lt;addnum&gt;&lt;/</span>addnum&gt;</span><br><span class="line">    &lt;addnum&gt;&lt;<span class="regexp">/addnum&gt;</span></span><br><span class="line"><span class="regexp">    &lt;addnum&gt;&lt;/</span>addnum&gt;</span><br><span class="line">    &lt;addnum&gt;&lt;<span class="regexp">/addnum&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(<span class="string">"addnum"</span>,&#123;</span><br><span class="line">        template:<span class="string">'&lt;div&gt;&lt;input type="text" v-model="num"&gt;&lt;button @click="num+=1"&gt;点击&lt;/button&gt;&lt;/div&gt;'</span>,</span><br><span class="line">        data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 写在这里的数据只有当前组件可以使用</span></span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                num:<span class="number">1</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">        el:<span class="string">"#app"</span>,</span><br><span class="line">        <span class="comment">// 这里写的数据是全局公用的，整个文件共享</span></span><br><span class="line">        data:&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      通过axios实现数据请求,vue.js默认没有提供ajax功能的,所以使用vue的时候，一般都会使用axios的插件来实现ajax与后端服务器的数据交互,注意，axios本质上就是javascript的ajax封装，所以会被同源策略限制...
    
    </summary>
    
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="vue框架" scheme="http://yoursite.com/tags/vue%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>[Vue对象的属性功能]</title>
    <link href="http://yoursite.com/2020/02/14/Vue%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2020/02/14/Vue%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8A%9F%E8%83%BD/</id>
    <published>2020-02-14T09:50:38.000Z</published>
    <updated>2020-02-14T10:23:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue对象提供的属性功能"><a href="#Vue对象提供的属性功能" class="headerlink" title="Vue对象提供的属性功能"></a>Vue对象提供的属性功能</h1><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>过滤器，就是vue允许开发者自定义的文本格式化函数，可以使用在两个地方：输出内容和操作数据中。</p><p>定义过滤器的方式有两种。</p><h3 id="使用Vue-filter-进行全局定义"><a href="#使用Vue-filter-进行全局定义" class="headerlink" title="使用Vue.filter()进行全局定义"></a>使用Vue.filter()进行全局定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">"RMB1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//就是来格式化(处理)v这个数据的</span></span><br><span class="line">  <span class="keyword">if</span>(v==<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> v+<span class="string">"元"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="在vue对象中通过filters属性来定义"><a href="#在vue对象中通过filters属性来定义" class="headerlink" title="在vue对象中通过filters属性来定义"></a>在vue对象中通过filters属性来定义</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el:<span class="string">"#app"</span>,</span><br><span class="line">  data:&#123;&#125;,</span><br><span class="line">  filters:&#123;</span><br><span class="line">    RMB2:<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(value==<span class="string">''</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'¥ '</span>+value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="计算和侦听属性"><a href="#计算和侦听属性" class="headerlink" title="计算和侦听属性"></a>计算和侦听属性</h2><h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>我们之前学习过字符串反转，如果直接把反转的代码写在元素中，则会使得其他同事在开发时时不易发现数据被调整了，所以vue提供了一个计算属性(computed)，可以让我们把调整data数据的代码存在在该属性中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line"><span class="actionscript">                str1: <span class="string">"abcdefgh"</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            computed:&#123;   <span class="comment">//计算属性：里面的函数都必须有返回值</span></span></span><br><span class="line"><span class="actionscript">                strRevs: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> ret = <span class="keyword">this</span>.str1.split(<span class="string">""</span>).reverse().join(<span class="string">""</span>);</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> ret</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; str1 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; strRevs &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="监听属性"><a href="#监听属性" class="headerlink" title="监听属性"></a>监听属性</h3><p>侦听属性，可以帮助我们侦听data某个数据的变化，从而做相应的自定义操作。</p><p>侦听属性是一个对象，它的键是要监听的对象或者变量，值一般是函数，当侦听的data数据发生变化时，会自定执行的对应函数，这个函数在被调用时，vue会传入两个形参，第一个是变化前的数据值，第二个是变化后的数据值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">         <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                num:20</span><br><span class="line">            &#125;,</span><br><span class="line">            watch:&#123;</span><br><span class="line"><span class="actionscript">                num:<span class="function"><span class="keyword">function</span><span class="params">(newval,oldval)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//num发生变化的时候，要执行的代码</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">console</span>.log(<span class="string">"num已经发生了变化！"</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; num &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"num++"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="vue对象的生命周期"><a href="#vue对象的生命周期" class="headerlink" title="vue对象的生命周期"></a>vue对象的生命周期</h2><p>每个Vue对象在创建时都要经过一系列的初始化过程。在这个过程中Vue.js会自动运行一些叫做生命周期的的钩子函数，我们可以使用这些函数，在对象创建的不同阶段加上我们需要的代码，实现特定的功能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;</span><br><span class="line">                num:0</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            beforeCreate:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"beforeCreate,vm对象尚未创建,num="</span>+ <span class="keyword">this</span>.num);  <span class="comment">//undefined</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.name=<span class="number">10</span>; <span class="comment">// 此时没有this对象呢，所以设置的name无效，被在创建对象的时候被覆盖为0</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            created:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"created,vm对象创建完成,设置好了要控制的元素范围,num="</span>+<span class="keyword">this</span>.num );  <span class="comment">// 0</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.num = <span class="number">20</span>;</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            beforeMount:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log( <span class="keyword">this</span>.$el.innerHTML ); <span class="comment">// &lt;p&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt;</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"beforeMount,vm对象尚未把data数据显示到页面中,num="</span>+<span class="keyword">this</span>.num ); <span class="comment">// 20</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.num = <span class="number">30</span>;</span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            mounted:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log( <span class="keyword">this</span>.$el.innerHTML ); <span class="comment">// &lt;p&gt;30&lt;/p&gt;</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"mounted,vm对象已经把data数据显示到页面中,num="</span>+<span class="keyword">this</span>.num); <span class="comment">// 30</span></span></span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            beforeUpdate:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// this.$el 就是我们上面的el属性了，$el表示当前vue.js所控制的元素#app</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log( <span class="keyword">this</span>.$el.innerHTML );  <span class="comment">// &lt;p&gt;30&lt;/p&gt;</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"beforeUpdate,vm对象尚未把更新后的data数据显示到页面中,num="</span>+<span class="keyword">this</span>.num); <span class="comment">// beforeUpdate----31</span></span></span><br><span class="line">                </span><br><span class="line">            &#125;,</span><br><span class="line"><span class="actionscript">            updated:<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log( <span class="keyword">this</span>.$el.innerHTML ); <span class="comment">// &lt;p&gt;31&lt;/p&gt;</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"updated,vm对象已经把过呢更新后的data数据显示到页面中,num="</span> + <span class="keyword">this</span>.num ); <span class="comment">// updated----31</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;num&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"num++"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在vue使用的过程中，如果要初始化操作，把初始化操作的代码放在 mounted 中执行。</span><br><span class="line">mounted阶段就是在vm对象已经把data数据实现到页面以后。一般页面初始化使用。例如，用户访问页面加载成功以后，就要执行的ajax请求。</span><br><span class="line"></span><br><span class="line">另一个就是created，这个阶段就是在 vue对象创建以后，把ajax请求后端数据的代码放进 created</span><br></pre></td></tr></table></figure><h2 id="阻止事件冒泡和刷新页面"><a href="#阻止事件冒泡和刷新页面" class="headerlink" title="阻止事件冒泡和刷新页面"></a>阻止事件冒泡和刷新页面</h2><p>使用.stop和.prevent</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.box1</span>&#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line"><span class="css">            <span class="selector-tag">background</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.box2</span>&#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">            el:<span class="string">"#app"</span>,</span></span><br><span class="line">            data:&#123;&#125;</span><br><span class="line">        &#125;)        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box1"</span> @<span class="attr">click</span>=<span class="string">"alert('box1')"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box2"</span> @<span class="attr">click.stop.prevent</span>=<span class="string">"alert('box2')"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>   <span class="comment">&lt;!-- @click.stop来阻止事件冒泡 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交02"</span> @<span class="attr">click.prevent</span>=<span class="string">""</span>&gt;</span> <span class="comment">&lt;!-- @click.prevent来阻止表单提交 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="综合案例-todolist"><a href="#综合案例-todolist" class="headerlink" title="综合案例-todolist"></a>综合案例-todolist</h2><p>我的计划列表</p><p>html代码:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>todolist<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.list_con</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:600px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">margin</span><span class="selector-pseudo">:50px</span> <span class="selector-tag">auto</span> 0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.inputtxt</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:550px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">height</span><span class="selector-pseudo">:30px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">padding</span><span class="selector-pseudo">:0px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">text-indent</span><span class="selector-pseudo">:10px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.inputbtn</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">height</span><span class="selector-pseudo">:32px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">padding</span><span class="selector-pseudo">:0px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.list</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">margin</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">list-style</span><span class="selector-pseudo">:none</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">margin-top</span><span class="selector-pseudo">:20px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.list</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">height</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">line-height</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">border-bottom</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.list</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.list</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">float</span><span class="selector-pseudo">:right</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">text-decoration</span><span class="selector-pseudo">:none</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> 10<span class="selector-tag">px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"list_con"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>To do list<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">id</span>=<span class="string">"txt1"</span> <span class="attr">class</span>=<span class="string">"inputtxt"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">"增加"</span> <span class="attr">id</span>=<span class="string">"btn1"</span> <span class="attr">class</span>=<span class="string">"inputbtn"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- javascript:; # 阻止a标签跳转 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>学习html<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"up"</span>&gt;</span> ↑ <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"down"</span>&gt;</span> ↓ <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"del"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>学习css<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"up"</span>&gt;</span> ↑ <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"down"</span>&gt;</span> ↓ <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"del"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>学习javascript<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"up"</span>&gt;</span> ↑ <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"down"</span>&gt;</span> ↓ <span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">class</span>=<span class="string">"del"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>特效实现效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>todolist<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.list_con</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:600px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">margin</span><span class="selector-pseudo">:50px</span> <span class="selector-tag">auto</span> 0;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.inputtxt</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:550px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">height</span><span class="selector-pseudo">:30px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">padding</span><span class="selector-pseudo">:0px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">text-indent</span><span class="selector-pseudo">:10px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.inputbtn</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">width</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">height</span><span class="selector-pseudo">:32px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">padding</span><span class="selector-pseudo">:0px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.list</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">margin</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">padding</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">list-style</span><span class="selector-pseudo">:none</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">margin-top</span><span class="selector-pseudo">:20px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.list</span> <span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">height</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">line-height</span><span class="selector-pseudo">:40px</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">border-bottom</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.list</span> <span class="selector-tag">li</span> <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="selector-class">.list</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span>&#123;</span></span><br><span class="line"><span class="css"><span class="selector-tag">float</span><span class="selector-pseudo">:right</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">text-decoration</span><span class="selector-pseudo">:none</span>;</span></span><br><span class="line"><span class="css"><span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> 10<span class="selector-tag">px</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"todolist"</span> <span class="attr">class</span>=<span class="string">"list_con"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>To do list<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"message"</span> <span class="attr">class</span>=<span class="string">"inputtxt"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> @<span class="attr">click</span>=<span class="string">"addItem"</span> <span class="attr">value</span>=<span class="string">"增加"</span> <span class="attr">class</span>=<span class="string">"inputbtn"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item,key in dolist"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"upItem(key)"</span> <span class="attr">class</span>=<span class="string">"up"</span> &gt;</span> ↑ <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"downItem(key)"</span> <span class="attr">class</span>=<span class="string">"down"</span>&gt;</span> ↓ <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">"delItem(key)"</span> <span class="attr">class</span>=<span class="string">"del"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 计划列表代码</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="actionscript">        el:<span class="string">"#todolist"</span>,</span></span><br><span class="line">        data:&#123;</span><br><span class="line"><span class="actionscript">            message:<span class="string">""</span>,</span></span><br><span class="line">            dolist:[</span><br><span class="line"><span class="actionscript">                <span class="string">"学习html"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="string">"学习css"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="string">"学习javascript"</span>,</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            addItem()&#123;</span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(<span class="keyword">this</span>.messsage==<span class="string">""</span>)&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.dolist.push(<span class="keyword">this</span>.message);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.message = <span class="string">""</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            delItem(key)&#123;</span><br><span class="line"><span class="actionscript">                <span class="comment">// 删除和替换</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 参数1: 开始下表</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 参数2: 元素长度，如果不填默认删除到最后</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 参数3: 表示使用当前参数替换已经删除内容的位置</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.dolist.splice(key, <span class="number">1</span>);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            upItem(key)&#123;</span><br><span class="line">                if(key==0)&#123;</span><br><span class="line"><span class="actionscript">                    <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="actionscript">                <span class="comment">// 向上移动</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> result = <span class="keyword">this</span>.dolist.splice(key,<span class="number">1</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.dolist.splice(key<span class="number">-1</span>,<span class="number">0</span>,result[<span class="number">0</span>]);</span></span><br><span class="line">            &#125;,</span><br><span class="line">            downItem(key)&#123;</span><br><span class="line"><span class="actionscript">                <span class="comment">// 向下移动</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> result = <span class="keyword">this</span>.dolist.splice(key, <span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(result);</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">this</span>.dolist.splice(key+<span class="number">1</span>,<span class="number">0</span>,result[<span class="number">0</span>]);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Vue对象提供的属性功能，过滤器，就是vue允许开发者自定义的文本格式化函数，可以使用在两个地方：输出内容和操作数据中。定义过滤器的方式有两种，使用Vue.filter()进行全局定义...
    
    </summary>
    
    
      <category term="前端框架" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="vue框架" scheme="http://yoursite.com/tags/vue%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
